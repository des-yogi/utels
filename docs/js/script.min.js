/**
 * @popperjs/core v2.9.3 - MIT License
 */
"use strict";

!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).Popper = {});
}(this, function (e) {
  function t(e) {
    return null == e ? window : "[object Window]" !== e.toString() ? (e = e.ownerDocument) && e.defaultView || window : e;
  }

  function n(e) {
    return e instanceof t(e).Element || e instanceof Element;
  }

  function o(e) {
    return e instanceof t(e).HTMLElement || e instanceof HTMLElement;
  }

  function r(e) {
    return "undefined" != typeof ShadowRoot && (e instanceof t(e).ShadowRoot || e instanceof ShadowRoot);
  }

  function i(e, t) {
    void 0 === t && (t = !1);
    var n = e.getBoundingClientRect(),
        r = 1,
        i = 1;
    return o(e) && t && (r = n.width / e.offsetWidth || 1, i = n.height / e.offsetHeight || 1), {
      width: q(n.width / r),
      height: q(n.height / i),
      top: q(n.top / i),
      right: q(n.right / r),
      bottom: q(n.bottom / i),
      left: q(n.left / r),
      x: q(n.left / r),
      y: q(n.top / i)
    };
  }

  function a(e) {
    return {
      scrollLeft: (e = t(e)).pageXOffset,
      scrollTop: e.pageYOffset
    };
  }

  function s(e) {
    return e ? (e.nodeName || "").toLowerCase() : null;
  }

  function f(e) {
    return ((n(e) ? e.ownerDocument : e.document) || window.document).documentElement;
  }

  function p(e) {
    return i(f(e)).left + a(e).scrollLeft;
  }

  function c(e) {
    return t(e).getComputedStyle(e);
  }

  function l(e) {
    return e = c(e), /auto|scroll|overlay|hidden/.test(e.overflow + e.overflowY + e.overflowX);
  }

  function u(e, n, r) {
    void 0 === r && (r = !1);
    var c,
        u = o(n);

    if (c = o(n)) {
      var d = (c = n.getBoundingClientRect()).height / n.offsetHeight || 1;
      c = 1 !== (c.width / n.offsetWidth || 1) || 1 !== d;
    }

    d = c, c = f(n), e = i(e, d), d = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var h = {
      x: 0,
      y: 0
    };
    return (u || !u && !r) && (("body" !== s(n) || l(c)) && (d = n !== t(n) && o(n) ? {
      scrollLeft: n.scrollLeft,
      scrollTop: n.scrollTop
    } : a(n)), o(n) ? ((h = i(n, !0)).x += n.clientLeft, h.y += n.clientTop) : c && (h.x = p(c))), {
      x: e.left + d.scrollLeft - h.x,
      y: e.top + d.scrollTop - h.y,
      width: e.width,
      height: e.height
    };
  }

  function d(e) {
    var t = i(e),
        n = e.offsetWidth,
        o = e.offsetHeight;
    return 1 >= Math.abs(t.width - n) && (n = t.width), 1 >= Math.abs(t.height - o) && (o = t.height), {
      x: e.offsetLeft,
      y: e.offsetTop,
      width: n,
      height: o
    };
  }

  function h(e) {
    return "html" === s(e) ? e : e.assignedSlot || e.parentNode || (r(e) ? e.host : null) || f(e);
  }

  function m(e) {
    return 0 <= ["html", "body", "#document"].indexOf(s(e)) ? e.ownerDocument.body : o(e) && l(e) ? e : m(h(e));
  }

  function v(e, n) {
    var o;
    void 0 === n && (n = []);
    var r = m(e);
    return e = r === (null == (o = e.ownerDocument) ? void 0 : o.body), o = t(r), r = e ? [o].concat(o.visualViewport || [], l(r) ? r : []) : r, n = n.concat(r), e ? n : n.concat(v(h(r)));
  }

  function g(e) {
    return o(e) && "fixed" !== c(e).position ? e.offsetParent : null;
  }

  function y(e) {
    for (var n = t(e), r = g(e); r && 0 <= ["table", "td", "th"].indexOf(s(r)) && "static" === c(r).position;) r = g(r);

    if (r && ("html" === s(r) || "body" === s(r) && "static" === c(r).position)) return n;
    if (!r) e: {
      if (r = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"), -1 === navigator.userAgent.indexOf("Trident") || !o(e) || "fixed" !== c(e).position) for (e = h(e); o(e) && 0 > ["html", "body"].indexOf(s(e));) {
        var i = c(e);

        if ("none" !== i.transform || "none" !== i.perspective || "paint" === i.contain || -1 !== ["transform", "perspective"].indexOf(i.willChange) || r && "filter" === i.willChange || r && i.filter && "none" !== i.filter) {
          r = e;
          break e;
        }

        e = e.parentNode;
      }
      r = null;
    }
    return r || n;
  }

  function b(e) {
    function t(e) {
      o.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) {
        o.has(e) || (e = n.get(e)) && t(e);
      }), r.push(e);
    }

    var n = new Map(),
        o = new Set(),
        r = [];
    return e.forEach(function (e) {
      n.set(e.name, e);
    }), e.forEach(function (e) {
      o.has(e.name) || t(e);
    }), r;
  }

  function w(e) {
    var t;
    return function () {
      return t || (t = new Promise(function (n) {
        Promise.resolve().then(function () {
          t = void 0, n(e());
        });
      })), t;
    };
  }

  function x(e) {
    return e.split("-")[0];
  }

  function O(e, t) {
    var n = t.getRootNode && t.getRootNode();
    if (e.contains(t)) return !0;
    if (n && r(n)) do {
      if (t && e.isSameNode(t)) return !0;
      t = t.parentNode || t.host;
    } while (t);
    return !1;
  }

  function j(e) {
    return Object.assign({}, e, {
      left: e.x,
      top: e.y,
      right: e.x + e.width,
      bottom: e.y + e.height
    });
  }

  function E(e, n) {
    if ("viewport" === n) {
      n = t(e);
      var r = f(e);
      n = n.visualViewport;
      var s = r.clientWidth;
      r = r.clientHeight;
      var l = 0,
          u = 0;
      n && (s = n.width, r = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (l = n.offsetLeft, u = n.offsetTop)), e = j(e = {
        width: s,
        height: r,
        x: l + p(e),
        y: u
      });
    } else o(n) ? ((e = i(n)).top += n.clientTop, e.left += n.clientLeft, e.bottom = e.top + n.clientHeight, e.right = e.left + n.clientWidth, e.width = n.clientWidth, e.height = n.clientHeight, e.x = e.left, e.y = e.top) : (u = f(e), e = f(u), s = a(u), n = null == (r = u.ownerDocument) ? void 0 : r.body, r = U(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), l = U(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), u = -s.scrollLeft + p(u), s = -s.scrollTop, "rtl" === c(n || e).direction && (u += U(e.clientWidth, n ? n.clientWidth : 0) - r), e = j({
      width: r,
      height: l,
      x: u,
      y: s
    }));

    return e;
  }

  function D(e, t, r) {
    return t = "clippingParents" === t ? function (e) {
      var t = v(h(e)),
          r = 0 <= ["absolute", "fixed"].indexOf(c(e).position) && o(e) ? y(e) : e;
      return n(r) ? t.filter(function (e) {
        return n(e) && O(e, r) && "body" !== s(e);
      }) : [];
    }(e) : [].concat(t), (r = (r = [].concat(t, [r])).reduce(function (t, n) {
      return n = E(e, n), t.top = U(n.top, t.top), t.right = z(n.right, t.right), t.bottom = z(n.bottom, t.bottom), t.left = U(n.left, t.left), t;
    }, E(e, r[0]))).width = r.right - r.left, r.height = r.bottom - r.top, r.x = r.left, r.y = r.top, r;
  }

  function L(e) {
    return 0 <= ["top", "bottom"].indexOf(e) ? "x" : "y";
  }

  function M(e) {
    var t = e.reference,
        n = e.element,
        o = (e = e.placement) ? x(e) : null;
    e = e ? e.split("-")[1] : null;
    var r = t.x + t.width / 2 - n.width / 2,
        i = t.y + t.height / 2 - n.height / 2;

    switch (o) {
      case "top":
        r = {
          x: r,
          y: t.y - n.height
        };
        break;

      case "bottom":
        r = {
          x: r,
          y: t.y + t.height
        };
        break;

      case "right":
        r = {
          x: t.x + t.width,
          y: i
        };
        break;

      case "left":
        r = {
          x: t.x - n.width,
          y: i
        };
        break;

      default:
        r = {
          x: t.x,
          y: t.y
        };
    }

    if (null != (o = o ? L(o) : null)) switch (i = "y" === o ? "height" : "width", e) {
      case "start":
        r[o] -= t[i] / 2 - n[i] / 2;
        break;

      case "end":
        r[o] += t[i] / 2 - n[i] / 2;
    }
    return r;
  }

  function P(e) {
    return Object.assign({}, {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, e);
  }

  function k(e, t) {
    return t.reduce(function (t, n) {
      return t[n] = e, t;
    }, {});
  }

  function W(e, t) {
    void 0 === t && (t = {});
    var o = t;
    t = void 0 === (t = o.placement) ? e.placement : t;
    var r = o.boundary,
        a = void 0 === r ? "clippingParents" : r,
        s = void 0 === (r = o.rootBoundary) ? "viewport" : r;
    r = void 0 === (r = o.elementContext) ? "popper" : r;
    var p = o.altBoundary,
        c = void 0 !== p && p;
    o = P("number" != typeof (o = void 0 === (o = o.padding) ? 0 : o) ? o : k(o, N));
    var l = e.elements.reference;
    p = e.rects.popper, a = D(n(c = e.elements[c ? "popper" === r ? "reference" : "popper" : r]) ? c : c.contextElement || f(e.elements.popper), a, s), c = M({
      reference: s = i(l),
      element: p,
      strategy: "absolute",
      placement: t
    }), p = j(Object.assign({}, p, c)), s = "popper" === r ? p : s;
    var u = {
      top: a.top - s.top + o.top,
      bottom: s.bottom - a.bottom + o.bottom,
      left: a.left - s.left + o.left,
      right: s.right - a.right + o.right
    };

    if (e = e.modifiersData.offset, "popper" === r && e) {
      var d = e[t];
      Object.keys(u).forEach(function (e) {
        var t = 0 <= ["right", "bottom"].indexOf(e) ? 1 : -1,
            n = 0 <= ["top", "bottom"].indexOf(e) ? "y" : "x";
        u[e] += d[n] * t;
      });
    }

    return u;
  }

  function A() {
    for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];

    return !t.some(function (e) {
      return !(e && "function" == typeof e.getBoundingClientRect);
    });
  }

  function B(e) {
    void 0 === e && (e = {});
    var t = e.defaultModifiers,
        o = void 0 === t ? [] : t,
        r = void 0 === (e = e.defaultOptions) ? X : e;
    return function (e, t, i) {
      function a() {
        f.forEach(function (e) {
          return e();
        }), f = [];
      }

      void 0 === i && (i = r);
      var s = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, X, r),
        modifiersData: {},
        elements: {
          reference: e,
          popper: t
        },
        attributes: {},
        styles: {}
      },
          f = [],
          p = !1,
          c = {
        state: s,
        setOptions: function (i) {
          return a(), s.options = Object.assign({}, r, s.options, i), s.scrollParents = {
            reference: n(e) ? v(e) : e.contextElement ? v(e.contextElement) : [],
            popper: v(t)
          }, i = function (e) {
            var t = b(e);
            return _.reduce(function (e, n) {
              return e.concat(t.filter(function (e) {
                return e.phase === n;
              }));
            }, []);
          }(function (e) {
            var t = e.reduce(function (e, t) {
              var n = e[t.name];
              return e[t.name] = n ? Object.assign({}, n, t, {
                options: Object.assign({}, n.options, t.options),
                data: Object.assign({}, n.data, t.data)
              }) : t, e;
            }, {});
            return Object.keys(t).map(function (e) {
              return t[e];
            });
          }([].concat(o, s.options.modifiers))), s.orderedModifiers = i.filter(function (e) {
            return e.enabled;
          }), s.orderedModifiers.forEach(function (e) {
            var t = e.name,
                n = e.options;
            n = void 0 === n ? {} : n, "function" == typeof (e = e.effect) && (t = e({
              state: s,
              name: t,
              instance: c,
              options: n
            }), f.push(t || function () {}));
          }), c.update();
        },
        forceUpdate: function () {
          if (!p) {
            var e = s.elements,
                t = e.reference;
            if (A(t, e = e.popper)) for (s.rects = {
              reference: u(t, y(e), "fixed" === s.options.strategy),
              popper: d(e)
            }, s.reset = !1, s.placement = s.options.placement, s.orderedModifiers.forEach(function (e) {
              return s.modifiersData[e.name] = Object.assign({}, e.data);
            }), t = 0; t < s.orderedModifiers.length; t++) if (!0 === s.reset) s.reset = !1, t = -1;else {
              var n = s.orderedModifiers[t];
              e = n.fn;
              var o = n.options;
              o = void 0 === o ? {} : o, n = n.name, "function" == typeof e && (s = e({
                state: s,
                options: o,
                name: n,
                instance: c
              }) || s);
            }
          }
        },
        update: w(function () {
          return new Promise(function (e) {
            c.forceUpdate(), e(s);
          });
        }),
        destroy: function () {
          a(), p = !0;
        }
      };
      return A(e, t) ? (c.setOptions(i).then(function (e) {
        !p && i.onFirstUpdate && i.onFirstUpdate(e);
      }), c) : c;
    };
  }

  function H(e) {
    var n,
        o = e.popper,
        r = e.popperRect,
        i = e.placement,
        a = e.offsets,
        s = e.position,
        p = e.gpuAcceleration,
        l = e.adaptive;

    if (!0 === (e = e.roundOffsets)) {
      e = a.y;
      var u = window.devicePixelRatio || 1;
      e = {
        x: F(F(a.x * u) / u) || 0,
        y: F(F(e * u) / u) || 0
      };
    } else e = "function" == typeof e ? e(a) : a;

    e = void 0 === (e = (u = e).x) ? 0 : e, u = void 0 === (u = u.y) ? 0 : u;
    var d = a.hasOwnProperty("x");
    a = a.hasOwnProperty("y");
    var h,
        m = "left",
        v = "top",
        g = window;

    if (l) {
      var b = y(o),
          w = "clientHeight",
          x = "clientWidth";
      b === t(o) && "static" !== c(b = f(o)).position && (w = "scrollHeight", x = "scrollWidth"), "top" === i && (v = "bottom", u -= b[w] - r.height, u *= p ? 1 : -1), "left" === i && (m = "right", e -= b[x] - r.width, e *= p ? 1 : -1);
    }

    return o = Object.assign({
      position: s
    }, l && K), p ? Object.assign({}, o, ((h = {})[v] = a ? "0" : "", h[m] = d ? "0" : "", h.transform = 2 > (g.devicePixelRatio || 1) ? "translate(" + e + "px, " + u + "px)" : "translate3d(" + e + "px, " + u + "px, 0)", h)) : Object.assign({}, o, ((n = {})[v] = a ? u + "px" : "", n[m] = d ? e + "px" : "", n.transform = "", n));
  }

  function T(e) {
    return e.replace(/left|right|bottom|top/g, function (e) {
      return ee[e];
    });
  }

  function R(e) {
    return e.replace(/start|end/g, function (e) {
      return te[e];
    });
  }

  function S(e, t, n) {
    return void 0 === n && (n = {
      x: 0,
      y: 0
    }), {
      top: e.top - t.height - n.y,
      right: e.right - t.width + n.x,
      bottom: e.bottom - t.height + n.y,
      left: e.left - t.width - n.x
    };
  }

  function C(e) {
    return ["top", "right", "bottom", "left"].some(function (t) {
      return 0 <= e[t];
    });
  }

  var q = Math.round,
      N = ["top", "bottom", "right", "left"],
      V = N.reduce(function (e, t) {
    return e.concat([t + "-start", t + "-end"]);
  }, []),
      I = [].concat(N, ["auto"]).reduce(function (e, t) {
    return e.concat([t, t + "-start", t + "-end"]);
  }, []),
      _ = "beforeRead read afterRead beforeMain main afterMain beforeWrite write afterWrite".split(" "),
      U = Math.max,
      z = Math.min,
      F = Math.round,
      X = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  },
      Y = {
    passive: !0
  },
      G = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: function (e) {
      var n = e.state,
          o = e.instance,
          r = (e = e.options).scroll,
          i = void 0 === r || r,
          a = void 0 === (e = e.resize) || e,
          s = t(n.elements.popper),
          f = [].concat(n.scrollParents.reference, n.scrollParents.popper);
      return i && f.forEach(function (e) {
        e.addEventListener("scroll", o.update, Y);
      }), a && s.addEventListener("resize", o.update, Y), function () {
        i && f.forEach(function (e) {
          e.removeEventListener("scroll", o.update, Y);
        }), a && s.removeEventListener("resize", o.update, Y);
      };
    },
    data: {}
  },
      J = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: function (e) {
      var t = e.state;
      t.modifiersData[e.name] = M({
        reference: t.rects.reference,
        element: t.rects.popper,
        strategy: "absolute",
        placement: t.placement
      });
    },
    data: {}
  },
      K = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  },
      Q = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: function (e) {
      var t = e.state,
          n = e.options;
      e = void 0 === (e = n.gpuAcceleration) || e;
      var o = n.adaptive;
      o = void 0 === o || o, n = void 0 === (n = n.roundOffsets) || n, e = {
        placement: x(t.placement),
        popper: t.elements.popper,
        popperRect: t.rects.popper,
        gpuAcceleration: e
      }, null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, H(Object.assign({}, e, {
        offsets: t.modifiersData.popperOffsets,
        position: t.options.strategy,
        adaptive: o,
        roundOffsets: n
      })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, H(Object.assign({}, e, {
        offsets: t.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: n
      })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
      });
    },
    data: {}
  },
      Z = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: function (e) {
      var t = e.state;
      Object.keys(t.elements).forEach(function (e) {
        var n = t.styles[e] || {},
            r = t.attributes[e] || {},
            i = t.elements[e];
        o(i) && s(i) && (Object.assign(i.style, n), Object.keys(r).forEach(function (e) {
          var t = r[e];
          !1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t);
        }));
      });
    },
    effect: function (e) {
      var t = e.state,
          n = {
        popper: {
          position: t.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () {
        Object.keys(t.elements).forEach(function (e) {
          var r = t.elements[e],
              i = t.attributes[e] || {};
          e = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce(function (e, t) {
            return e[t] = "", e;
          }, {}), o(r) && s(r) && (Object.assign(r.style, e), Object.keys(i).forEach(function (e) {
            r.removeAttribute(e);
          }));
        });
      };
    },
    requires: ["computeStyles"]
  },
      $ = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: function (e) {
      var t = e.state,
          n = e.name,
          o = void 0 === (e = e.options.offset) ? [0, 0] : e,
          r = (e = I.reduce(function (e, n) {
        var r = t.rects,
            i = x(n),
            a = 0 <= ["left", "top"].indexOf(i) ? -1 : 1,
            s = "function" == typeof o ? o(Object.assign({}, r, {
          placement: n
        })) : o;
        return r = (r = s[0]) || 0, s = ((s = s[1]) || 0) * a, i = 0 <= ["left", "right"].indexOf(i) ? {
          x: s,
          y: r
        } : {
          x: r,
          y: s
        }, e[n] = i, e;
      }, {}))[t.placement],
          i = r.x;
      r = r.y, null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += i, t.modifiersData.popperOffsets.y += r), t.modifiersData[n] = e;
    }
  },
      ee = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  },
      te = {
    start: "end",
    end: "start"
  },
      ne = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t = e.state,
          n = e.options;

      if (e = e.name, !t.modifiersData[e]._skip) {
        var o = n.mainAxis;
        o = void 0 === o || o;
        var r = n.altAxis;
        r = void 0 === r || r;
        var i = n.fallbackPlacements,
            a = n.padding,
            s = n.boundary,
            f = n.rootBoundary,
            p = n.altBoundary,
            c = n.flipVariations,
            l = void 0 === c || c,
            u = n.allowedAutoPlacements;
        c = x(n = t.options.placement), i = i || (c !== n && l ? function (e) {
          if ("auto" === x(e)) return [];
          var t = T(e);
          return [R(e), t, R(t)];
        }(n) : [T(n)]);
        var d = [n].concat(i).reduce(function (e, n) {
          return e.concat("auto" === x(n) ? function (e, t) {
            void 0 === t && (t = {});
            var n = t.boundary,
                o = t.rootBoundary,
                r = t.padding,
                i = t.flipVariations,
                a = t.allowedAutoPlacements,
                s = void 0 === a ? I : a,
                f = t.placement.split("-")[1];
            0 === (i = (t = f ? i ? V : V.filter(function (e) {
              return e.split("-")[1] === f;
            }) : N).filter(function (e) {
              return 0 <= s.indexOf(e);
            })).length && (i = t);
            var p = i.reduce(function (t, i) {
              return t[i] = W(e, {
                placement: i,
                boundary: n,
                rootBoundary: o,
                padding: r
              })[x(i)], t;
            }, {});
            return Object.keys(p).sort(function (e, t) {
              return p[e] - p[t];
            });
          }(t, {
            placement: n,
            boundary: s,
            rootBoundary: f,
            padding: a,
            flipVariations: l,
            allowedAutoPlacements: u
          }) : n);
        }, []);
        n = t.rects.reference, i = t.rects.popper;
        var h = new Map();
        c = !0;

        for (var m = d[0], v = 0; v < d.length; v++) {
          var g = d[v],
              y = x(g),
              b = "start" === g.split("-")[1],
              w = 0 <= ["top", "bottom"].indexOf(y),
              O = w ? "width" : "height",
              j = W(t, {
            placement: g,
            boundary: s,
            rootBoundary: f,
            altBoundary: p,
            padding: a
          });

          if (b = w ? b ? "right" : "left" : b ? "bottom" : "top", n[O] > i[O] && (b = T(b)), O = T(b), w = [], o && w.push(0 >= j[y]), r && w.push(0 >= j[b], 0 >= j[O]), w.every(function (e) {
            return e;
          })) {
            m = g, c = !1;
            break;
          }

          h.set(g, w);
        }

        if (c) for (o = function (e) {
          var t = d.find(function (t) {
            if (t = h.get(t)) return t.slice(0, e).every(function (e) {
              return e;
            });
          });
          if (t) return m = t, "break";
        }, r = l ? 3 : 1; 0 < r && "break" !== o(r); r--);
        t.placement !== m && (t.modifiersData[e]._skip = !0, t.placement = m, t.reset = !0);
      }
    },
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  },
      oe = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t = e.state,
          n = e.options;
      e = e.name;
      var o = n.mainAxis,
          r = void 0 === o || o,
          i = void 0 !== (o = n.altAxis) && o;
      o = void 0 === (o = n.tether) || o;
      var a = n.tetherOffset,
          s = void 0 === a ? 0 : a,
          f = W(t, {
        boundary: n.boundary,
        rootBoundary: n.rootBoundary,
        padding: n.padding,
        altBoundary: n.altBoundary
      });
      n = x(t.placement);
      var p = t.placement.split("-")[1],
          c = !p,
          l = L(n);
      n = "x" === l ? "y" : "x", a = t.modifiersData.popperOffsets;
      var u = t.rects.reference,
          h = t.rects.popper,
          m = "function" == typeof s ? s(Object.assign({}, t.rects, {
        placement: t.placement
      })) : s;

      if (s = {
        x: 0,
        y: 0
      }, a) {
        if (r || i) {
          var v = "y" === l ? "top" : "left",
              g = "y" === l ? "bottom" : "right",
              b = "y" === l ? "height" : "width",
              w = a[l],
              O = a[l] + f[v],
              j = a[l] - f[g],
              E = o ? -h[b] / 2 : 0,
              D = "start" === p ? u[b] : h[b];
          p = "start" === p ? -h[b] : -u[b], h = t.elements.arrow, h = o && h ? d(h) : {
            width: 0,
            height: 0
          };
          var M = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          };
          v = M[v], g = M[g], h = U(0, z(u[b], h[b])), D = c ? u[b] / 2 - E - h - v - m : D - h - v - m, u = c ? -u[b] / 2 + E + h + g + m : p + h + g + m, c = t.elements.arrow && y(t.elements.arrow), m = t.modifiersData.offset ? t.modifiersData.offset[t.placement][l] : 0, c = a[l] + D - m - (c ? "y" === l ? c.clientTop || 0 : c.clientLeft || 0 : 0), u = a[l] + u - m, r && (r = o ? z(O, c) : O, j = o ? U(j, u) : j, r = U(r, z(w, j)), a[l] = r, s[l] = r - w), i && (r = (i = a[n]) + f["x" === l ? "top" : "left"], f = i - f["x" === l ? "bottom" : "right"], r = o ? z(r, c) : r, o = o ? U(f, u) : f, o = U(r, z(i, o)), a[n] = o, s[n] = o - i);
        }

        t.modifiersData[e] = s;
      }
    },
    requiresIfExists: ["offset"]
  },
      re = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t,
          n = e.state,
          o = e.name,
          r = e.options,
          i = n.elements.arrow,
          a = n.modifiersData.popperOffsets,
          s = x(n.placement);

      if (e = L(s), s = 0 <= ["left", "right"].indexOf(s) ? "height" : "width", i && a) {
        r = P("number" != typeof (r = "function" == typeof (r = r.padding) ? r(Object.assign({}, n.rects, {
          placement: n.placement
        })) : r) ? r : k(r, N));
        var f = d(i),
            p = "y" === e ? "top" : "left",
            c = "y" === e ? "bottom" : "right",
            l = n.rects.reference[s] + n.rects.reference[e] - a[e] - n.rects.popper[s];
        a = a[e] - n.rects.reference[e], a = (i = (i = y(i)) ? "y" === e ? i.clientHeight || 0 : i.clientWidth || 0 : 0) / 2 - f[s] / 2 + (l / 2 - a / 2), s = U(r[p], z(a, i - f[s] - r[c])), n.modifiersData[o] = ((t = {})[e] = s, t.centerOffset = s - a, t);
      }
    },
    effect: function (e) {
      var t = e.state;

      if (null != (e = void 0 === (e = e.options.element) ? "[data-popper-arrow]" : e)) {
        if ("string" == typeof e && !(e = t.elements.popper.querySelector(e))) return;
        O(t.elements.popper, e) && (t.elements.arrow = e);
      }
    },
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  },
      ie = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: function (e) {
      var t = e.state;
      e = e.name;
      var n = t.rects.reference,
          o = t.rects.popper,
          r = t.modifiersData.preventOverflow,
          i = W(t, {
        elementContext: "reference"
      }),
          a = W(t, {
        altBoundary: !0
      });
      n = S(i, n), o = S(a, o, r), r = C(n), a = C(o), t.modifiersData[e] = {
        referenceClippingOffsets: n,
        popperEscapeOffsets: o,
        isReferenceHidden: r,
        hasPopperEscaped: a
      }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": r,
        "data-popper-escaped": a
      });
    }
  },
      ae = B({
    defaultModifiers: [G, J, Q, Z]
  }),
      se = [G, J, Q, Z, $, ne, oe, re, ie],
      fe = B({
    defaultModifiers: se
  });

  e.applyStyles = Z, e.arrow = re, e.computeStyles = Q, e.createPopper = fe, e.createPopperLite = ae, e.defaultModifiers = se, e.detectOverflow = W, e.eventListeners = G, e.flip = ne, e.hide = ie, e.offset = $, e.popperGenerator = B, e.popperOffsets = J, e.preventOverflow = oe, Object.defineProperty(e, "__esModule", {
    value: !0
  });
});
/******/
(function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        /******/
        configurable: false,

        /******/
        enumerable: true,

        /******/
        get: getter
        /******/

      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "";
  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 0);
  /******/
})([
  /* 0 */

  /***/

  /******/
function (module, exports, __webpack_require__) {
  "use strict";

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  /**
  Drooltip.js
  Developed by: Prev Wong	(imprev.co)
  Documentation: https://prevwong.github.io/drooltip.js/
  Github: https://github.com/prevwong/drooltip.js/
  License: MIT (https://raw.githubusercontent.com/prevwong/drooltip.js/master/LICENSE)
  **/


  (function () {
    window["Drooltip"] = function () {
      this.tooltips = {};
      var defaults = {
        "element": ".drooltip",
        "trigger": "hover",
        "position": "top",
        "background": "#2175ff",
        "color": "#fff",
        "animation": "bounce",
        "content": null,
        "callback": null
      };

      if (arguments[0] && _typeof(arguments[0]) === "object") {
        this.options = extendDefaults(defaults, arguments[0]);
      }

      this.build();
    };

    function formatPrivateContent(content) {
      if (content.match(/(?![^{]+})(?:\.|#)([_a-zA-Z]+[_a-zA-Z0-9-]*)/) !== null && content.replace(content.match(/(?![^{]+})(?:\.|#)([_a-zA-Z]+[_a-zA-Z0-9-]*)/)[0], "").replace(/ /g, "") === "") {
        // use element
        return {
          "type": "element",
          "element": content.match(/(?![^{]+})(?:\.|#)([_a-zA-Z]+[_a-zA-Z0-9-]*)/)[0]
        };
      } else if (content.match(/\:(.*)\:/) !== null && content.replace(content.match(/\:(.*)\:/)[0], "") === "") {
        var pattern = content.match(/\:(.*)\:/);
        var dataString = pattern[1].match(/\[(.*)\]/);
        var type = pattern[1].replace(dataString[0], "").replace(/ /g, "");
        var url = dataString[1].split(',')[0];
        var json = null;

        if (dataString[1].split(',')[1] !== null) {
          json = dataString[1].split(',')[1].replace(/ /g, '');
        }

        return {
          url: url,
          json: json,
          type: type
        };
      } else {
        return content;
      }
    }

    function createTooltip(id, sourceElem, options) {
      var content = options["content"];

      if (_typeof(options["content"]) === "object") {
        if (options["content"]["type"] === "jsonp" || options["content"]["type"] === "ajax") {
          requests[id] = {
            info: {
              source: sourceElem,
              position: options["position"]
            },
            data: options["content"],
            loaded: false
          };
          content = "<div class = 'drooltipLoaderWrapper'><span style='background:" + options["color"] + "' class = 'drooltipLoader'></span></div>";
        } else if (options["content"]["type"] === "element") {
          var elem = document.querySelector(options["content"]["element"]);

          if (elem !== null) {
            elem.style.display = "none";
            content = elem.outerHTML;
            elem.parentNode.removeChild(elem);
          } else {
            content = "HTML element not found";
          }
        }
      }

      var tooltip = document.createElement("div");
      tooltip.setAttribute("data-identifiers", id);
      tooltip.setAttribute("class", "drooltip");
      tooltip.setAttribute("style", "color: " + options["background"]); // for arrow

      document.body.appendChild(tooltip);
      var html = "";
      html += "<div style='background:" + options["background"] + "' class = 'bg'></div>";
      html += "<div style='color:" + options["color"] + "' class = 'content'>";
      html += content;
      html += "</div>";
      tooltip.innerHTML = html;

      if (options["content"]["element"] !== undefined) {
        if (tooltip.querySelector(options["content"]["element"]) !== null) {
          tooltip.querySelector(options["content"]["element"]).style.display = "";
        }
      }

      return document.querySelector("[data-identifiers='" + id + "']");
    }

    function jsonp(url, callback) {
      var callbackName = "jsonp_callback_" + Math.round(100000 * Math.random());

      window[callbackName] = function (data) {
        delete window[callbackName];
        document.body.removeChild(script);
        callback(data);
      };

      var script = document.createElement("script");
      script.src = url + (url.indexOf("?") >= 0 ? "&" : "?") + "callback=" + callbackName;
      document.body.appendChild(script);
    }

    function requestsHandler(id, element) {
      var type = requests[id]["data"]["type"],
          json = requests[id]["data"]["json"],
          url = requests[id]["data"]["url"],
          source = requests[id]["info"]["source"],
          loaded = requests[id]["loaded"],
          position = requests[id]["info"]["position"];

      if (loaded !== true) {
        if (type === "ajax") {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url);

          if (json !== undefined) {
            //json format
            xhr.setRequestHeader("Content-Type", "application/json");
          }

          xhr.onload = function () {
            if (xhr.status === 200) {
              var content;

              if (json !== undefined) {
                //json format
                if (json.slice(-2) === "()") {
                  content = window[json.replace("()", "")](JSON.parse(xhr.responseText));
                } else {
                  content = JSON.parse(xhr.responseText)[json];
                }
              } else {
                content = xhr.responseText;
              }

              updateDynamicContent(id, element, source, position, content);
            }
          };

          xhr.send();
        } else if (type === "jsonp") {
          jsonp(url, function (jsObject) {
            var content;

            if (json.slice(-2) === "()") {
              content = window[json.replace("()", "")](jsObject);
            } else {
              content = jsObject[json];
            }

            updateDynamicContent(id, element, source, position, content);
          });
        }
      }
    }

    function updateDynamicContent(id, element, source, position, content) {
      element.querySelector(".content .drooltipLoader").classList.add("stop");
      setTimeout(function () {
        element.querySelector(".content").classList.add("showDynamic");
        setTimeout(function () {
          element.querySelector(".content").innerHTML = content;
          element.querySelector(".content").classList.remove("showDynamic");
          getPosition(element, source, position, {
            "x": 0,
            "y": 0
          });
        }, 200);
        requests[id]["loaded"] = true;
      }, 400);
    }

    function extendDefaults(source, properties) {
      var property;

      for (property in properties) {
        if (properties.hasOwnProperty(property)) {
          source[property] = properties[property];
        }
      }

      return source;
    }
    /** Replicating jQuery Offset Method @thanks ubugnu **/


    function isWindow(obj) {
      return obj !== null && obj === obj.window;
    }

    function getWindow(elem) {
      return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    function offset(elem) {
      var docElem,
          win,
          box = {
        top: 0,
        left: 0
      },
          doc = elem && elem.ownerDocument;
      docElem = doc.documentElement;

      if (_typeof(elem.getBoundingClientRect) !== (true ? "undefined" : _typeof(undefined))) {
        box = elem.getBoundingClientRect();
      }

      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    }

    function getElemDimensions(element) {
      var top = window.pageYOffset;
      var info = {
        "left": offset(element).left,
        "top": offset(element).top
      };
      element.classList.add("fake");
      info["width"] = element.offsetWidth;
      info["height"] = element.offsetHeight;
      element.classList.remove("fake");
      return info;
    }

    function getPosition(tooltip, source, required) {
      var _tooltip$classList;

      var _pos = ["top", "bottom", "right", "left"],
          sourceDimensions = getElemDimensions(source),
          tooltipDimensions = getElemDimensions(tooltip),
          arrowSize = 6;
      var imaginaryPositions = {
        "if_top_y": sourceDimensions["top"] - tooltipDimensions["height"] - arrowSize,
        "if_vertical_x": sourceDimensions["left"] + sourceDimensions["width"] / 2 - tooltipDimensions["width"] / 2,
        "if_bottom_y": sourceDimensions["top"] + sourceDimensions["height"],
        "if_horizontal_y": sourceDimensions["top"] + (sourceDimensions["height"] / 2 - tooltipDimensions["height"] / 2) - arrowSize,
        "if_left_x": sourceDimensions["left"] - tooltipDimensions["width"],
        "if_right_x": sourceDimensions["left"] + sourceDimensions["width"]
      };
      var positions = {
        "top": {
          "y_pos": imaginaryPositions["if_top_y"],
          "x_pos": imaginaryPositions["if_vertical_x"]
        },
        "bottom": {
          "y_pos": imaginaryPositions["if_bottom_y"],
          "x_pos": imaginaryPositions["if_vertical_x"]
        },
        "right": {
          "y_pos": imaginaryPositions["if_horizontal_y"],
          "x_pos": imaginaryPositions["if_right_x"]
        },
        "left": {
          "y_pos": imaginaryPositions["if_horizontal_y"],
          "x_pos": imaginaryPositions["if_left_x"]
        }
      };
      var key = Object.keys(positions)[computeBestPosition(imaginaryPositions, tooltipDimensions, required)];

      (_tooltip$classList = tooltip.classList).remove.apply(_tooltip$classList, _pos);

      tooltip.classList.add(key);

      _extends(tooltip.style, {
        "left": positions[key]["x_pos"] + "px",
        "top": positions[key]["y_pos"] + "px"
      });
    }

    function computeBestPosition(imaginaryPositions, tooltipDimensions, required) {
      var screenTop = window.pageYOffset,
          screenWidth = window.innerWidth,
          screenHeight = window.innerHeight,
          selector = [0, 0, 0, 0];

      if (screenTop < imaginaryPositions["if_top_y"]) {
        selector[0] += 1;

        if (required === "top") {
          selector[0] += 2;
        }
      }

      if (screenTop > imaginaryPositions["if_top_y"] || screenTop < imaginaryPositions["if_bottom_y"]) {
        selector[1] += 1;

        if (required === "bottom") {
          selector[1] += 2;
        }
      }

      if (imaginaryPositions["if_vertical_x"] < 0 || required === "right" && imaginaryPositions["if_right_x"] + tooltipDimensions["width"] < screenWidth) {
        selector[2] += 1;

        if (required === "right") {
          selector[2] += 2;
        }
      }

      if (imaginaryPositions["if_left_x"] > 0) {
        selector[3] += 1;

        if (required === "left") {
          selector[3] += 2;
        }
      }

      return selector.indexOf(Math.max.apply(Math, selector));
    }

    function showTooltip() {
      var _ = this;

      var elem = _["tooltip"];
      var options = _["options"];
      var callback = options["callback"];
      var animateEffect = options["animation"];
      getPosition(_["tooltip"], _["source"], _["options"]["position"]);
      setTimeout(function () {
        elem.classList.remove("hideTooltip");

        if (elem.classList.contains("open") === false) {
          if (standardAnimations.indexOf(animateEffect) === -1) {
            window[animateEffect]("animate", _, callback);
          } else {
            addStandardEffect(elem, animateEffect, callback);
          }
        }

        elem.classList.add("open");
        setTimeout(function () {
          if (options["content"]["type"] === "ajax" || options["content"]["type"] === "jsonp" && requests[_["id"]]["loaded"] === false) {
            elem.style.transition = "none";
            requestsHandler(_["id"], elem);
            element.style.transition = "";
          }
        }, 500);
      }, 200);
    }

    function hideTooltip() {
      var _ = this;

      var elem = _["tooltip"];
      var options = _["options"];
      var callback = options["callback"];
      var animateEffect = options["animation"];
      var timeout = 0;

      if (elem.classList.contains("animating") !== false) {
        // User clicked even though tooltip is still animating
        timeout = 400;
      }

      setTimeout(function () {
        if (elem.classList.contains("open") === true) {
          if (standardAnimations.indexOf(animateEffect) === -1) {
            window[animateEffect]("deanimate", _, callback);
          } else {
            removeStandardEffect(elem, animateEffect);
          }

          elem.classList.remove("open");
        }
      }, timeout);
    }
    /** Custom Effects **/


    function floatEffect(fn, elem, callback) {
      if (fn === "animate") {
        addStandardEffect(elem, "bounce", null);
        setTimeout(function () {
          elem.classList.add("drooltipFloat");

          if (callback !== null && callback !== undefined) {
            window[callback]();
          }
        }, 100);
      } else {
        elem.classList.remove("drooltipFloat");
        removeStandardEffect(elem, "bounce");
      }
    }

    function materialEffect(fn, elem, callback) {
      if (fn === "animate") {
        elem.classList.add("drooltipMaterial");
        setTimeout(function () {
          elem.classList.remove("hideTooltip");
          setTimeout(function () {
            elem.classList.add("animate");
            setTimeout(function () {
              arrowDisplay(elem, "show");
            }, 100);
          }, 200);
        }, 100);
      } else {
        arrowDisplay(elem, "hide");
        setTimeout(function () {
          elem.classList.remove("animate");
          setTimeout(function () {
            elem.classList.remove("drooltipMaterial");
            elem.classList.add("hideTooltip");
          }, 100);
        }, 200);
      }
    }
    /** Standard Effects **/


    function addStandardEffect(elem, animateEffect, callback) {
      if (animateEffect === "material") {
        materialEffect("animate", elem, callback);
        return false;
      }

      if (animateEffect === "float") {
        floatEffect("animate", elem, callback);
        return false;
      }

      var animateEffectClass = "drooltip" + animateEffect[0].toUpperCase() + animateEffect.slice(1);
      elem.classList.remove("out");
      elem.classList.add(animateEffectClass, "animating");
      arrowDisplay(elem, "show");
      setTimeout(function () {
        elem.classList.remove("hideTooltip");
        setTimeout(function () {
          elem.classList.remove(animateEffectClass, "animating");
        }, 200);

        if (callback !== null && callback !== undefined) {
          window[callback]();
        }
      }, 200);
    }

    function removeStandardEffect(elem, animateEffect) {
      if (animateEffect === "material") {
        materialEffect("deanimate", elem);
        return false;
      }

      if (animateEffect === "float") {
        floatEffect("deanimate", elem);
        return false;
      }

      var animateEffectClass = "drooltip" + animateEffect[0].toUpperCase() + animateEffect.slice(1);
      elem.classList.add(animateEffectClass);
      elem.classList.add("out");
      arrowDisplay(elem, "hide");
      setTimeout(function () {
        elem.classList.add("hideTooltip");
        elem.classList.remove(animateEffectClass);
      }, 400);
    }

    function arrowDisplay(elem, action) {
      if (action === "show") {
        elem.classList.add("showArrow");
      } else {
        elem.classList.remove("showArrow");
      }
    }

    function listenerAdd(data, trigger) {
      var standardTriggers = ["hover", "click", "none"]; //var tooltips = Object.assign({}, publicTooltips);

      if (standardTriggers.indexOf(trigger) === -1) {
        window[trigger].call(this, data);
        return false;
      } else {
        data["tooltip"].classList.add("hideTooltip");

        if (trigger === "hover") {
          drooltipHover(data);
        } else if (trigger === "click") {
          drooltipClick(data);
        } else if (trigger === "none") {
          showTooltip.call(data);
        }
      }
      /**
      for ( var i in tooltips ) {
        publicTooltips[i]["tooltip"].classList.add("hideTooltip");
        if ( trigger === "hover" ) {
          drooltipHover(publicTooltips[i]);
        } else if ( trigger === "click" ) {
          drooltipClick(publicTooltips[i]);
        } else if ( trigger === "none" ) {
          showTooltip.call(publicTooltips[i]);
        }
      }
      **/

    }

    function drooltipHover(data) {
      var mouseover = function mouseover(data) {
        var timeout = null;
        var exit = null;
        window.addEventListener("mouseover", function (e) {
          if (data["source"].contains(e.target) || data["tooltip"].contains(e.target)) {
            clearTimeout(exit);
          } else {
            exit = setTimeout(function () {
              if (data["tooltip"].classList.contains("open")) {
                hideTooltip.call(data);
              }
            }, 200);
          }
        });
        data["source"].addEventListener("mouseenter", function (e) {
          timeout = setTimeout(function () {
            showTooltip.call(data);
          }, 200);
        });
        data["source"].addEventListener("mouseleave", function (e) {
          clearTimeout(timeout);
        });
      };

      mouseover(data);
    }

    function drooltipClick(data) {
      window.addEventListener("click", function (e) {
        if (data["source"].contains(e.target) || data["tooltip"].contains(e.target)) {
          showTooltip.call(data);
        } else {
          hideTooltip.call(data);
        }
      });
    }

    function animateOrDeanimate(fn, data) {
      if (fn === "animate") {
        showTooltip.call(data);
      } else {
        hideTooltip.call(data);
      }
    }

    function animateOrDeanimateAll(fn) {
      var instances = this.tooltips;

      for (var i in instances) {
        if (fn === "animate") {
          showTooltip.call(instances[i], this.tooltips[i]["options"]);
        } else {
          hideTooltip.call(instances[i], this.tooltips[i]["options"]);
        }
      }
    }

    function showOrHideAllTooltips(fn) {
      var instances = this.tooltips;

      for (var i in instances) {
        if (fn === "show") {
          instances[i]["tooltip"].classList.remove("hideTooltip");
        } else {
          instances[i]["tooltip"].classList.add("hideTooltip");
        }
      }
    }
    /** Global Objects, contains tooltips across all instances in a page; 
    required for setting positions and processing ajax/jsonp requests **/


    var tooltips = {},
        requests = {},
        standardAnimations = ["bounce", "fade", "material", "float"];
    /** Build(); Creates tooltips for given element(s) **/

    Drooltip.prototype.build = function () {
      var elems = document.querySelectorAll(this.options["element"]),
          id = this.options["element"];

      var _ = this;

      tooltips[id] = {};
      this.tooltips = {};

      for (var i = 0; i < elems.length; ++i) {
        elems[i].setAttribute("data-id", i);

        var options = _extends({}, this.options),
            privateOptions = elems[i].getAttribute("data-options"),
            privateContent = elems[i].getAttribute("title");

        if (privateOptions !== null) {
          for (var x in privateOptions.split(";")) {
            var property = privateOptions.split(";")[x].split(":")[0];

            if (property !== "content") {
              var value = privateOptions.split(";")[x].split(":")[1];
              options[property] = value;
            }
          }
        }

        if (privateContent !== null && privateContent !== "") {
          options["content"] = formatPrivateContent(privateContent);
          elems[i].removeAttribute("title");
        }

        if (options["content"] !== null) {
          var tooltip = createTooltip(id + "_" + i, elems[i], options);
          tooltips[id][i] = {
            "id": id + "_" + i,
            "source": elems[i],
            tooltip: tooltip,
            options: options
          };
          this.tooltips[i] = {
            "id": id + "_" + i,
            "source": elems[i],
            tooltip: tooltip,
            options: options
          };
        }

        attachTriggerEvent.call(_, this.tooltips[i]);
      }
    };

    Drooltip.prototype.animateAllTooltips = function () {
      animateOrDeanimateAll.call(this, "animate");
    };

    Drooltip.prototype.deanimateAllTooltips = function () {
      animateOrDeanimateAll.call(this, "deanimate");
    };

    Drooltip.prototype.animateTooltip = function (data) {
      animateOrDeanimate.call(this, "animate", data);
    };

    Drooltip.prototype.deanimateTooltip = function (data) {
      animateOrDeanimate.call(this, "deanimate", data);
    };

    Drooltip.prototype.hideAllTooltips = function () {
      showOrHideAllTooltips.call(this, "hide");
    };

    Drooltip.prototype.showAllTooltips = function () {
      showOrHideAllTooltips.call(this, "show");
    };

    Drooltip.prototype.hideTooltip = function (tooltip) {
      tooltip.classList.add("hideTooltip");
    };

    Drooltip.prototype.showTooltip = function (tooltip) {
      tooltip.classList.remove("hideTooltip");
    };

    Drooltip.prototype.addStandardEffect = function (elem, effect) {
      addStandardEffect(elem, effect);
    };

    Drooltip.prototype.removeStandardEffect = function (elem, effect) {
      removeStandardEffect(elem, effect);
    };

    Drooltip.prototype.showArrow = function (elem) {
      arrowDisplay(elem, "show");
    };

    Drooltip.prototype.hideArrow = function (elem) {
      arrowDisplay(elem, "hide");
    };

    Drooltip.prototype.loadRequests = function () {
      for (var i in requests) {
        var elem = document.querySelector("[data-identifiers='" + i + "']");
        requestsHandler(requests[i], elem);
      }
    };
    /** Sets tooltips position **/


    Drooltip.prototype.setTooltipsPos = function () {
      var _ = this;

      for (var i in tooltips) {
        for (var j in tooltips[i]) {
          var current = tooltips[i][j];
          var position = current["options"]["position"];
          var source = current["source"];
          var tooltip = current["tooltip"];
          var sourceDimensions = getElemDimensions(source);
          var tooltipDimensions = getElemDimensions(tooltip);
          getPosition(tooltip, source, position);
        }
      }
    };

    Drooltip.prototype.updatePosition = function (data) {
      getPosition(data["tooltip"], data["source"], data["options"]["position"]);
    };

    function attachTriggerEvent(data) {
      var source = data["source"],
          tooltip = data["tooltip"],
          options = data["options"],
          trigger = options["trigger"];
      tooltip.classList.add("loaded");
      listenerAdd.call(this, data, trigger);
    }
  })();

  window.onload = function () {
    Drooltip.prototype.setTooltipsPos();
    window.addEventListener('scroll', function () {
      Drooltip.prototype.setTooltipsPos();
    }, true);

    window.onresize = function () {
      Drooltip.prototype.setTooltipsPos();
    };
  };
  /***/

}]);
/*!
  * Bootstrap v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("@popperjs/core")) : "function" == typeof define && define.amd ? define(["@popperjs/core"], e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e(t.Popper);
}(this, function (t) {
  "use strict";

  function e(t) {
    if (t && t.__esModule) return t;
    var e = Object.create(null);
    return t && Object.keys(t).forEach(function (i) {
      if ("default" !== i) {
        var s = Object.getOwnPropertyDescriptor(t, i);
        Object.defineProperty(e, i, s.get ? s : {
          enumerable: !0,
          get: function () {
            return t[i];
          }
        });
      }
    }), e.default = t, Object.freeze(e);
  }

  var i = e(t);

  const s = t => {
    let e = t.getAttribute("data-bs-target");

    if (!e || "#" === e) {
      let i = t.getAttribute("href");
      if (!i || !i.includes("#") && !i.startsWith(".")) return null;
      i.includes("#") && !i.startsWith("#") && (i = "#" + i.split("#")[1]), e = i && "#" !== i ? i.trim() : null;
    }

    return e;
  },
        n = t => {
    const e = s(t);
    return e && document.querySelector(e) ? e : null;
  },
        o = t => {
    const e = s(t);
    return e ? document.querySelector(e) : null;
  },
        r = t => {
    t.dispatchEvent(new Event("transitionend"));
  },
        a = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
        l = t => a(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null,
        c = (t, e, i) => {
    Object.keys(i).forEach(s => {
      const n = i[s],
            o = e[s],
            r = o && a(o) ? "element" : null == (l = o) ? "" + l : {}.toString.call(l).match(/\s([a-z]+)/i)[1].toLowerCase();
      var l;
      if (!new RegExp(n).test(r)) throw new TypeError(`${t.toUpperCase()}: Option "${s}" provided type "${r}" but expected type "${n}".`);
    });
  },
        h = t => !(!a(t) || 0 === t.getClientRects().length) && "visible" === getComputedStyle(t).getPropertyValue("visibility"),
        d = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
        u = t => {
    if (!document.documentElement.attachShadow) return null;

    if ("function" == typeof t.getRootNode) {
      const e = t.getRootNode();
      return e instanceof ShadowRoot ? e : null;
    }

    return t instanceof ShadowRoot ? t : t.parentNode ? u(t.parentNode) : null;
  },
        g = () => {},
        p = t => {
    t.offsetHeight;
  },
        f = () => {
    const {
      jQuery: t
    } = window;
    return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null;
  },
        _ = [],
        m = () => "rtl" === document.documentElement.dir,
        b = t => {
    var e;
    e = () => {
      const e = f();

      if (e) {
        const i = t.NAME,
              s = e.fn[i];
        e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = s, t.jQueryInterface);
      }
    }, "loading" === document.readyState ? (_.length || document.addEventListener("DOMContentLoaded", () => {
      _.forEach(t => t());
    }), _.push(e)) : e();
  },
        v = t => {
    "function" == typeof t && t();
  },
        y = (t, e, i = !0) => {
    if (!i) return void v(t);

    const s = (t => {
      if (!t) return 0;
      let {
        transitionDuration: e,
        transitionDelay: i
      } = window.getComputedStyle(t);
      const s = Number.parseFloat(e),
            n = Number.parseFloat(i);
      return s || n ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0;
    })(e) + 5;

    let n = !1;

    const o = ({
      target: i
    }) => {
      i === e && (n = !0, e.removeEventListener("transitionend", o), v(t));
    };

    e.addEventListener("transitionend", o), setTimeout(() => {
      n || r(e);
    }, s);
  },
        w = (t, e, i, s) => {
    let n = t.indexOf(e);
    if (-1 === n) return t[!i && s ? t.length - 1 : 0];
    const o = t.length;
    return n += i ? 1 : -1, s && (n = (n + o) % o), t[Math.max(0, Math.min(n, o - 1))];
  },
        E = /[^.]*(?=\..*)\.|.*/,
        A = /\..*/,
        T = /::\d+$/,
        C = {};

  let k = 1;
  const L = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  },
        S = /^(mouseenter|mouseleave)/i,
        O = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

  function N(t, e) {
    return e && `${e}::${k++}` || t.uidEvent || k++;
  }

  function D(t) {
    const e = N(t);
    return t.uidEvent = e, C[e] = C[e] || {}, C[e];
  }

  function I(t, e, i = null) {
    const s = Object.keys(t);

    for (let n = 0, o = s.length; n < o; n++) {
      const o = t[s[n]];
      if (o.originalHandler === e && o.delegationSelector === i) return o;
    }

    return null;
  }

  function x(t, e, i) {
    const s = "string" == typeof e,
          n = s ? i : e;
    let o = j(t);
    return O.has(o) || (o = t), [s, n, o];
  }

  function P(t, e, i, s, n) {
    if ("string" != typeof e || !t) return;

    if (i || (i = s, s = null), S.test(e)) {
      const t = t => function (e) {
        if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e);
      };

      s ? s = t(s) : i = t(i);
    }

    const [o, r, a] = x(e, i, s),
          l = D(t),
          c = l[a] || (l[a] = {}),
          h = I(c, r, o ? i : null);
    if (h) return void (h.oneOff = h.oneOff && n);
    const d = N(r, e.replace(E, "")),
          u = o ? function (t, e, i) {
      return function s(n) {
        const o = t.querySelectorAll(e);

        for (let {
          target: r
        } = n; r && r !== this; r = r.parentNode) for (let a = o.length; a--;) if (o[a] === r) return n.delegateTarget = r, s.oneOff && H.off(t, n.type, e, i), i.apply(r, [n]);

        return null;
      };
    }(t, i, s) : function (t, e) {
      return function i(s) {
        return s.delegateTarget = t, i.oneOff && H.off(t, s.type, e), e.apply(t, [s]);
      };
    }(t, i);
    u.delegationSelector = o ? i : null, u.originalHandler = r, u.oneOff = n, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o);
  }

  function M(t, e, i, s, n) {
    const o = I(e[i], s, n);
    o && (t.removeEventListener(i, o, Boolean(n)), delete e[i][o.uidEvent]);
  }

  function j(t) {
    return t = t.replace(A, ""), L[t] || t;
  }

  const H = {
    on(t, e, i, s) {
      P(t, e, i, s, !1);
    },

    one(t, e, i, s) {
      P(t, e, i, s, !0);
    },

    off(t, e, i, s) {
      if ("string" != typeof e || !t) return;
      const [n, o, r] = x(e, i, s),
            a = r !== e,
            l = D(t),
            c = e.startsWith(".");

      if (void 0 !== o) {
        if (!l || !l[r]) return;
        return void M(t, l, r, o, n ? i : null);
      }

      c && Object.keys(l).forEach(i => {
        !function (t, e, i, s) {
          const n = e[i] || {};
          Object.keys(n).forEach(o => {
            if (o.includes(s)) {
              const s = n[o];
              M(t, e, i, s.originalHandler, s.delegationSelector);
            }
          });
        }(t, l, i, e.slice(1));
      });
      const h = l[r] || {};
      Object.keys(h).forEach(i => {
        const s = i.replace(T, "");

        if (!a || e.includes(s)) {
          const e = h[i];
          M(t, l, r, e.originalHandler, e.delegationSelector);
        }
      });
    },

    trigger(t, e, i) {
      if ("string" != typeof e || !t) return null;
      const s = f(),
            n = j(e),
            o = e !== n,
            r = O.has(n);
      let a,
          l = !0,
          c = !0,
          h = !1,
          d = null;
      return o && s && (a = s.Event(e, i), s(t).trigger(a), l = !a.isPropagationStopped(), c = !a.isImmediatePropagationStopped(), h = a.isDefaultPrevented()), r ? (d = document.createEvent("HTMLEvents"), d.initEvent(n, l, !0)) : d = new CustomEvent(e, {
        bubbles: l,
        cancelable: !0
      }), void 0 !== i && Object.keys(i).forEach(t => {
        Object.defineProperty(d, t, {
          get: () => i[t]
        });
      }), h && d.preventDefault(), c && t.dispatchEvent(d), d.defaultPrevented && void 0 !== a && a.preventDefault(), d;
    }

  },
        B = new Map();
  var z = {
    set(t, e, i) {
      B.has(t) || B.set(t, new Map());
      const s = B.get(t);
      s.has(e) || 0 === s.size ? s.set(e, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`);
    },

    get: (t, e) => B.has(t) && B.get(t).get(e) || null,

    remove(t, e) {
      if (!B.has(t)) return;
      const i = B.get(t);
      i.delete(e), 0 === i.size && B.delete(t);
    }

  };

  class R {
    constructor(t) {
      (t = l(t)) && (this._element = t, z.set(this._element, this.constructor.DATA_KEY, this));
    }

    dispose() {
      z.remove(this._element, this.constructor.DATA_KEY), H.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach(t => {
        this[t] = null;
      });
    }

    _queueCallback(t, e, i = !0) {
      y(t, e, i);
    }

    static getInstance(t) {
      return z.get(l(t), this.DATA_KEY);
    }

    static getOrCreateInstance(t, e = {}) {
      return this.getInstance(t) || new this(t, "object" == typeof e ? e : null);
    }

    static get VERSION() {
      return "5.1.0";
    }

    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }

    static get DATA_KEY() {
      return "bs." + this.NAME;
    }

    static get EVENT_KEY() {
      return "." + this.DATA_KEY;
    }

  }

  const F = (t, e = "hide") => {
    const i = "click.dismiss" + t.EVENT_KEY,
          s = t.NAME;
    H.on(document, i, `[data-bs-dismiss="${s}"]`, function (i) {
      if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), d(this)) return;
      const n = o(this) || this.closest("." + s);
      t.getOrCreateInstance(n)[e]();
    });
  };

  class W extends R {
    static get NAME() {
      return "alert";
    }

    close() {
      if (H.trigger(this._element, "close.bs.alert").defaultPrevented) return;

      this._element.classList.remove("show");

      const t = this._element.classList.contains("fade");

      this._queueCallback(() => this._destroyElement(), this._element, t);
    }

    _destroyElement() {
      this._element.remove(), H.trigger(this._element, "closed.bs.alert"), this.dispose();
    }

    static jQueryInterface(t) {
      return this.each(function () {
        const e = W.getOrCreateInstance(this);

        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }

  }

  F(W, "close"), b(W);

  class $ extends R {
    static get NAME() {
      return "button";
    }

    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
    }

    static jQueryInterface(t) {
      return this.each(function () {
        const e = $.getOrCreateInstance(this);
        "toggle" === t && e[t]();
      });
    }

  }

  function q(t) {
    return "true" === t || "false" !== t && (t === Number(t).toString() ? Number(t) : "" === t || "null" === t ? null : t);
  }

  function U(t) {
    return t.replace(/[A-Z]/g, t => "-" + t.toLowerCase());
  }

  H.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', t => {
    t.preventDefault();
    const e = t.target.closest('[data-bs-toggle="button"]');
    $.getOrCreateInstance(e).toggle();
  }), b($);
  const K = {
    setDataAttribute(t, e, i) {
      t.setAttribute("data-bs-" + U(e), i);
    },

    removeDataAttribute(t, e) {
      t.removeAttribute("data-bs-" + U(e));
    },

    getDataAttributes(t) {
      if (!t) return {};
      const e = {};
      return Object.keys(t.dataset).filter(t => t.startsWith("bs")).forEach(i => {
        let s = i.replace(/^bs/, "");
        s = s.charAt(0).toLowerCase() + s.slice(1, s.length), e[s] = q(t.dataset[i]);
      }), e;
    },

    getDataAttribute: (t, e) => q(t.getAttribute("data-bs-" + U(e))),

    offset(t) {
      const e = t.getBoundingClientRect();
      return {
        top: e.top + window.pageYOffset,
        left: e.left + window.pageXOffset
      };
    },

    position: t => ({
      top: t.offsetTop,
      left: t.offsetLeft
    })
  },
        V = {
    find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
    findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
    children: (t, e) => [].concat(...t.children).filter(t => t.matches(e)),

    parents(t, e) {
      const i = [];
      let s = t.parentNode;

      for (; s && s.nodeType === Node.ELEMENT_NODE && 3 !== s.nodeType;) s.matches(e) && i.push(s), s = s.parentNode;

      return i;
    },

    prev(t, e) {
      let i = t.previousElementSibling;

      for (; i;) {
        if (i.matches(e)) return [i];
        i = i.previousElementSibling;
      }

      return [];
    },

    next(t, e) {
      let i = t.nextElementSibling;

      for (; i;) {
        if (i.matches(e)) return [i];
        i = i.nextElementSibling;
      }

      return [];
    },

    focusableChildren(t) {
      const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(t => t + ':not([tabindex^="-"])').join(", ");
      return this.find(e, t).filter(t => !d(t) && h(t));
    }

  },
        X = {
    interval: 5e3,
    keyboard: !0,
    slide: !1,
    pause: "hover",
    wrap: !0,
    touch: !0
  },
        Y = {
    interval: "(number|boolean)",
    keyboard: "boolean",
    slide: "(boolean|string)",
    pause: "(string|boolean)",
    wrap: "boolean",
    touch: "boolean"
  },
        Q = "next",
        G = "prev",
        Z = "left",
        J = "right",
        tt = {
    ArrowLeft: J,
    ArrowRight: Z
  };

  class et extends R {
    constructor(t, e) {
      super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._indicatorsElement = V.findOne(".carousel-indicators", this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners();
    }

    static get Default() {
      return X;
    }

    static get NAME() {
      return "carousel";
    }

    next() {
      this._slide(Q);
    }

    nextWhenVisible() {
      !document.hidden && h(this._element) && this.next();
    }

    prev() {
      this._slide(G);
    }

    pause(t) {
      t || (this._isPaused = !0), V.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (r(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;
    }

    cycle(t) {
      t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));
    }

    to(t) {
      this._activeElement = V.findOne(".active.carousel-item", this._element);

      const e = this._getItemIndex(this._activeElement);

      if (t > this._items.length - 1 || t < 0) return;
      if (this._isSliding) return void H.one(this._element, "slid.bs.carousel", () => this.to(t));
      if (e === t) return this.pause(), void this.cycle();
      const i = t > e ? Q : G;

      this._slide(i, this._items[t]);
    }

    _getConfig(t) {
      return t = { ...X,
        ...K.getDataAttributes(this._element),
        ...("object" == typeof t ? t : {})
      }, c("carousel", t, Y), t;
    }

    _handleSwipe() {
      const t = Math.abs(this.touchDeltaX);
      if (t <= 40) return;
      const e = t / this.touchDeltaX;
      this.touchDeltaX = 0, e && this._slide(e > 0 ? J : Z);
    }

    _addEventListeners() {
      this._config.keyboard && H.on(this._element, "keydown.bs.carousel", t => this._keydown(t)), "hover" === this._config.pause && (H.on(this._element, "mouseenter.bs.carousel", t => this.pause(t)), H.on(this._element, "mouseleave.bs.carousel", t => this.cycle(t))), this._config.touch && this._touchSupported && this._addTouchEventListeners();
    }

    _addTouchEventListeners() {
      const t = t => {
        !this._pointerEvent || "pen" !== t.pointerType && "touch" !== t.pointerType ? this._pointerEvent || (this.touchStartX = t.touches[0].clientX) : this.touchStartX = t.clientX;
      },
            e = t => {
        this.touchDeltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this.touchStartX;
      },
            i = t => {
        !this._pointerEvent || "pen" !== t.pointerType && "touch" !== t.pointerType || (this.touchDeltaX = t.clientX - this.touchStartX), this._handleSwipe(), "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(t => this.cycle(t), 500 + this._config.interval));
      };

      V.find(".carousel-item img", this._element).forEach(t => {
        H.on(t, "dragstart.bs.carousel", t => t.preventDefault());
      }), this._pointerEvent ? (H.on(this._element, "pointerdown.bs.carousel", e => t(e)), H.on(this._element, "pointerup.bs.carousel", t => i(t)), this._element.classList.add("pointer-event")) : (H.on(this._element, "touchstart.bs.carousel", e => t(e)), H.on(this._element, "touchmove.bs.carousel", t => e(t)), H.on(this._element, "touchend.bs.carousel", t => i(t)));
    }

    _keydown(t) {
      if (/input|textarea/i.test(t.target.tagName)) return;
      const e = tt[t.key];
      e && (t.preventDefault(), this._slide(e));
    }

    _getItemIndex(t) {
      return this._items = t && t.parentNode ? V.find(".carousel-item", t.parentNode) : [], this._items.indexOf(t);
    }

    _getItemByOrder(t, e) {
      const i = t === Q;
      return w(this._items, e, i, this._config.wrap);
    }

    _triggerSlideEvent(t, e) {
      const i = this._getItemIndex(t),
            s = this._getItemIndex(V.findOne(".active.carousel-item", this._element));

      return H.trigger(this._element, "slide.bs.carousel", {
        relatedTarget: t,
        direction: e,
        from: s,
        to: i
      });
    }

    _setActiveIndicatorElement(t) {
      if (this._indicatorsElement) {
        const e = V.findOne(".active", this._indicatorsElement);
        e.classList.remove("active"), e.removeAttribute("aria-current");
        const i = V.find("[data-bs-target]", this._indicatorsElement);

        for (let e = 0; e < i.length; e++) if (Number.parseInt(i[e].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(t)) {
          i[e].classList.add("active"), i[e].setAttribute("aria-current", "true");
          break;
        }
      }
    }

    _updateInterval() {
      const t = this._activeElement || V.findOne(".active.carousel-item", this._element);
      if (!t) return;
      const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
      e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;
    }

    _slide(t, e) {
      const i = this._directionToOrder(t),
            s = V.findOne(".active.carousel-item", this._element),
            n = this._getItemIndex(s),
            o = e || this._getItemByOrder(i, s),
            r = this._getItemIndex(o),
            a = Boolean(this._interval),
            l = i === Q,
            c = l ? "carousel-item-start" : "carousel-item-end",
            h = l ? "carousel-item-next" : "carousel-item-prev",
            d = this._orderToDirection(i);

      if (o && o.classList.contains("active")) return void (this._isSliding = !1);
      if (this._isSliding) return;
      if (this._triggerSlideEvent(o, d).defaultPrevented) return;
      if (!s || !o) return;
      this._isSliding = !0, a && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o;

      const u = () => {
        H.trigger(this._element, "slid.bs.carousel", {
          relatedTarget: o,
          direction: d,
          from: n,
          to: r
        });
      };

      if (this._element.classList.contains("slide")) {
        o.classList.add(h), p(o), s.classList.add(c), o.classList.add(c);

        const t = () => {
          o.classList.remove(c, h), o.classList.add("active"), s.classList.remove("active", h, c), this._isSliding = !1, setTimeout(u, 0);
        };

        this._queueCallback(t, s, !0);
      } else s.classList.remove("active"), o.classList.add("active"), this._isSliding = !1, u();

      a && this.cycle();
    }

    _directionToOrder(t) {
      return [J, Z].includes(t) ? m() ? t === Z ? G : Q : t === Z ? Q : G : t;
    }

    _orderToDirection(t) {
      return [Q, G].includes(t) ? m() ? t === G ? Z : J : t === G ? J : Z : t;
    }

    static carouselInterface(t, e) {
      const i = et.getOrCreateInstance(t, e);
      let {
        _config: s
      } = i;
      "object" == typeof e && (s = { ...s,
        ...e
      });
      const n = "string" == typeof e ? e : s.slide;
      if ("number" == typeof e) i.to(e);else if ("string" == typeof n) {
        if (void 0 === i[n]) throw new TypeError(`No method named "${n}"`);
        i[n]();
      } else s.interval && s.ride && (i.pause(), i.cycle());
    }

    static jQueryInterface(t) {
      return this.each(function () {
        et.carouselInterface(this, t);
      });
    }

    static dataApiClickHandler(t) {
      const e = o(this);
      if (!e || !e.classList.contains("carousel")) return;
      const i = { ...K.getDataAttributes(e),
        ...K.getDataAttributes(this)
      },
            s = this.getAttribute("data-bs-slide-to");
      s && (i.interval = !1), et.carouselInterface(e, i), s && et.getInstance(e).to(s), t.preventDefault();
    }

  }

  H.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", et.dataApiClickHandler), H.on(window, "load.bs.carousel.data-api", () => {
    const t = V.find('[data-bs-ride="carousel"]');

    for (let e = 0, i = t.length; e < i; e++) et.carouselInterface(t[e], et.getInstance(t[e]));
  }), b(et);
  const it = {
    toggle: !0,
    parent: null
  },
        st = {
    toggle: "boolean",
    parent: "(null|element)"
  };

  class nt extends R {
    constructor(t, e) {
      super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._triggerArray = [];
      const i = V.find('[data-bs-toggle="collapse"]');

      for (let t = 0, e = i.length; t < e; t++) {
        const e = i[t],
              s = n(e),
              o = V.find(s).filter(t => t === this._element);
        null !== s && o.length && (this._selector = s, this._triggerArray.push(e));
      }

      this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
    }

    static get Default() {
      return it;
    }

    static get NAME() {
      return "collapse";
    }

    toggle() {
      this._isShown() ? this.hide() : this.show();
    }

    show() {
      if (this._isTransitioning || this._isShown()) return;
      let t,
          e = [];

      if (this._config.parent) {
        const t = V.find(".collapse .collapse", this._config.parent);
        e = V.find(".show, .collapsing", this._config.parent).filter(e => !t.includes(e));
      }

      const i = V.findOne(this._selector);

      if (e.length) {
        const s = e.find(t => i !== t);
        if (t = s ? nt.getInstance(s) : null, t && t._isTransitioning) return;
      }

      if (H.trigger(this._element, "show.bs.collapse").defaultPrevented) return;
      e.forEach(e => {
        i !== e && nt.getOrCreateInstance(e, {
          toggle: !1
        }).hide(), t || z.set(e, "bs.collapse", null);
      });

      const s = this._getDimension();

      this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[s] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
      const n = "scroll" + (s[0].toUpperCase() + s.slice(1));
      this._queueCallback(() => {
        this._isTransitioning = !1, this._element.classList.remove("collapsing"), this._element.classList.add("collapse", "show"), this._element.style[s] = "", H.trigger(this._element, "shown.bs.collapse");
      }, this._element, !0), this._element.style[s] = this._element[n] + "px";
    }

    hide() {
      if (this._isTransitioning || !this._isShown()) return;
      if (H.trigger(this._element, "hide.bs.collapse").defaultPrevented) return;

      const t = this._getDimension();

      this._element.style[t] = this._element.getBoundingClientRect()[t] + "px", p(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show");
      const e = this._triggerArray.length;

      for (let t = 0; t < e; t++) {
        const e = this._triggerArray[t],
              i = o(e);
        i && !this._isShown(i) && this._addAriaAndCollapsedClass([e], !1);
      }

      this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback(() => {
        this._isTransitioning = !1, this._element.classList.remove("collapsing"), this._element.classList.add("collapse"), H.trigger(this._element, "hidden.bs.collapse");
      }, this._element, !0);
    }

    _isShown(t = this._element) {
      return t.classList.contains("show");
    }

    _getConfig(t) {
      return (t = { ...it,
        ...K.getDataAttributes(this._element),
        ...t
      }).toggle = Boolean(t.toggle), t.parent = l(t.parent), c("collapse", t, st), t;
    }

    _getDimension() {
      return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
    }

    _initializeChildren() {
      if (!this._config.parent) return;
      const t = V.find(".collapse .collapse", this._config.parent);
      V.find('[data-bs-toggle="collapse"]', this._config.parent).filter(e => !t.includes(e)).forEach(t => {
        const e = o(t);
        e && this._addAriaAndCollapsedClass([t], this._isShown(e));
      });
    }

    _addAriaAndCollapsedClass(t, e) {
      t.length && t.forEach(t => {
        e ? t.classList.remove("collapsed") : t.classList.add("collapsed"), t.setAttribute("aria-expanded", e);
      });
    }

    static jQueryInterface(t) {
      return this.each(function () {
        const e = {};
        "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1);
        const i = nt.getOrCreateInstance(this, e);

        if ("string" == typeof t) {
          if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
          i[t]();
        }
      });
    }

  }

  H.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', function (t) {
    ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
    const e = n(this);
    V.find(e).forEach(t => {
      nt.getOrCreateInstance(t, {
        toggle: !1
      }).toggle();
    });
  }), b(nt);
  const ot = new RegExp("ArrowUp|ArrowDown|Escape"),
        rt = m() ? "top-end" : "top-start",
        at = m() ? "top-start" : "top-end",
        lt = m() ? "bottom-end" : "bottom-start",
        ct = m() ? "bottom-start" : "bottom-end",
        ht = m() ? "left-start" : "right-start",
        dt = m() ? "right-start" : "left-start",
        ut = {
    offset: [0, 2],
    boundary: "clippingParents",
    reference: "toggle",
    display: "dynamic",
    popperConfig: null,
    autoClose: !0
  },
        gt = {
    offset: "(array|string|function)",
    boundary: "(string|element)",
    reference: "(string|element|object)",
    display: "string",
    popperConfig: "(null|object|function)",
    autoClose: "(boolean|string)"
  };

  class pt extends R {
    constructor(t, e) {
      super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar();
    }

    static get Default() {
      return ut;
    }

    static get DefaultType() {
      return gt;
    }

    static get NAME() {
      return "dropdown";
    }

    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }

    show() {
      if (d(this._element) || this._isShown(this._menu)) return;
      const t = {
        relatedTarget: this._element
      };
      if (H.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) return;
      const e = pt.getParentFromElement(this._element);
      this._inNavbar ? K.setDataAttribute(this._menu, "popper", "none") : this._createPopper(e), "ontouchstart" in document.documentElement && !e.closest(".navbar-nav") && [].concat(...document.body.children).forEach(t => H.on(t, "mouseover", g)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add("show"), this._element.classList.add("show"), H.trigger(this._element, "shown.bs.dropdown", t);
    }

    hide() {
      if (d(this._element) || !this._isShown(this._menu)) return;
      const t = {
        relatedTarget: this._element
      };

      this._completeHide(t);
    }

    dispose() {
      this._popper && this._popper.destroy(), super.dispose();
    }

    update() {
      this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
    }

    _completeHide(t) {
      H.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => H.off(t, "mouseover", g)), this._popper && this._popper.destroy(), this._menu.classList.remove("show"), this._element.classList.remove("show"), this._element.setAttribute("aria-expanded", "false"), K.removeDataAttribute(this._menu, "popper"), H.trigger(this._element, "hidden.bs.dropdown", t));
    }

    _getConfig(t) {
      if (t = { ...this.constructor.Default,
        ...K.getDataAttributes(this._element),
        ...t
      }, c("dropdown", t, this.constructor.DefaultType), "object" == typeof t.reference && !a(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError("dropdown".toUpperCase() + ': Option "reference" provided type "object" without a required "getBoundingClientRect" method.');
      return t;
    }

    _createPopper(t) {
      if (void 0 === i) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
      let e = this._element;
      "parent" === this._config.reference ? e = t : a(this._config.reference) ? e = l(this._config.reference) : "object" == typeof this._config.reference && (e = this._config.reference);

      const s = this._getPopperConfig(),
            n = s.modifiers.find(t => "applyStyles" === t.name && !1 === t.enabled);

      this._popper = i.createPopper(e, this._menu, s), n && K.setDataAttribute(this._menu, "popper", "static");
    }

    _isShown(t = this._element) {
      return t.classList.contains("show");
    }

    _getMenuElement() {
      return V.next(this._element, ".dropdown-menu")[0];
    }

    _getPlacement() {
      const t = this._element.parentNode;
      if (t.classList.contains("dropend")) return ht;
      if (t.classList.contains("dropstart")) return dt;
      const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
      return t.classList.contains("dropup") ? e ? at : rt : e ? ct : lt;
    }

    _detectNavbar() {
      return null !== this._element.closest(".navbar");
    }

    _getOffset() {
      const {
        offset: t
      } = this._config;
      return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t;
    }

    _getPopperConfig() {
      const t = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      return "static" === this._config.display && (t.modifiers = [{
        name: "applyStyles",
        enabled: !1
      }]), { ...t,
        ...("function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig)
      };
    }

    _selectMenuItem({
      key: t,
      target: e
    }) {
      const i = V.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(h);
      i.length && w(i, e, "ArrowDown" === t, !i.includes(e)).focus();
    }

    static jQueryInterface(t) {
      return this.each(function () {
        const e = pt.getOrCreateInstance(this, t);

        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }

    static clearMenus(t) {
      if (t && (2 === t.button || "keyup" === t.type && "Tab" !== t.key)) return;
      const e = V.find('[data-bs-toggle="dropdown"]');

      for (let i = 0, s = e.length; i < s; i++) {
        const s = pt.getInstance(e[i]);
        if (!s || !1 === s._config.autoClose) continue;
        if (!s._isShown()) continue;
        const n = {
          relatedTarget: s._element
        };

        if (t) {
          const e = t.composedPath(),
                i = e.includes(s._menu);
          if (e.includes(s._element) || "inside" === s._config.autoClose && !i || "outside" === s._config.autoClose && i) continue;
          if (s._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;
          "click" === t.type && (n.clickEvent = t);
        }

        s._completeHide(n);
      }
    }

    static getParentFromElement(t) {
      return o(t) || t.parentNode;
    }

    static dataApiKeydownHandler(t) {
      if (/input|textarea/i.test(t.target.tagName) ? "Space" === t.key || "Escape" !== t.key && ("ArrowDown" !== t.key && "ArrowUp" !== t.key || t.target.closest(".dropdown-menu")) : !ot.test(t.key)) return;
      const e = this.classList.contains("show");
      if (!e && "Escape" === t.key) return;
      if (t.preventDefault(), t.stopPropagation(), d(this)) return;
      const i = this.matches('[data-bs-toggle="dropdown"]') ? this : V.prev(this, '[data-bs-toggle="dropdown"]')[0],
            s = pt.getOrCreateInstance(i);
      if ("Escape" !== t.key) return "ArrowUp" === t.key || "ArrowDown" === t.key ? (e || s.show(), void s._selectMenuItem(t)) : void (e && "Space" !== t.key || pt.clearMenus());
      s.hide();
    }

  }

  H.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', pt.dataApiKeydownHandler), H.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", pt.dataApiKeydownHandler), H.on(document, "click.bs.dropdown.data-api", pt.clearMenus), H.on(document, "keyup.bs.dropdown.data-api", pt.clearMenus), H.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', function (t) {
    t.preventDefault(), pt.getOrCreateInstance(this).toggle();
  }), b(pt);

  class ft {
    constructor() {
      this._element = document.body;
    }

    getWidth() {
      const t = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - t);
    }

    hide() {
      const t = this.getWidth();
      this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", e => e + t), this._setElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight", e => e + t), this._setElementAttributes(".sticky-top", "marginRight", e => e - t);
    }

    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
    }

    _setElementAttributes(t, e, i) {
      const s = this.getWidth();

      this._applyManipulationCallback(t, t => {
        if (t !== this._element && window.innerWidth > t.clientWidth + s) return;

        this._saveInitialAttribute(t, e);

        const n = window.getComputedStyle(t)[e];
        t.style[e] = i(Number.parseFloat(n)) + "px";
      });
    }

    reset() {
      this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight"), this._resetElementAttributes(".sticky-top", "marginRight");
    }

    _saveInitialAttribute(t, e) {
      const i = t.style[e];
      i && K.setDataAttribute(t, e, i);
    }

    _resetElementAttributes(t, e) {
      this._applyManipulationCallback(t, t => {
        const i = K.getDataAttribute(t, e);
        void 0 === i ? t.style.removeProperty(e) : (K.removeDataAttribute(t, e), t.style[e] = i);
      });
    }

    _applyManipulationCallback(t, e) {
      a(t) ? e(t) : V.find(t, this._element).forEach(e);
    }

    isOverflowing() {
      return this.getWidth() > 0;
    }

  }

  const _t = {
    className: "modal-backdrop",
    isVisible: !0,
    isAnimated: !1,
    rootElement: "body",
    clickCallback: null
  },
        mt = {
    className: "string",
    isVisible: "boolean",
    isAnimated: "boolean",
    rootElement: "(element|string)",
    clickCallback: "(function|null)"
  };

  class bt {
    constructor(t) {
      this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
    }

    show(t) {
      this._config.isVisible ? (this._append(), this._config.isAnimated && p(this._getElement()), this._getElement().classList.add("show"), this._emulateAnimation(() => {
        v(t);
      })) : v(t);
    }

    hide(t) {
      this._config.isVisible ? (this._getElement().classList.remove("show"), this._emulateAnimation(() => {
        this.dispose(), v(t);
      })) : v(t);
    }

    _getElement() {
      if (!this._element) {
        const t = document.createElement("div");
        t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t;
      }

      return this._element;
    }

    _getConfig(t) {
      return (t = { ..._t,
        ...("object" == typeof t ? t : {})
      }).rootElement = l(t.rootElement), c("backdrop", t, mt), t;
    }

    _append() {
      this._isAppended || (this._config.rootElement.append(this._getElement()), H.on(this._getElement(), "mousedown.bs.backdrop", () => {
        v(this._config.clickCallback);
      }), this._isAppended = !0);
    }

    dispose() {
      this._isAppended && (H.off(this._element, "mousedown.bs.backdrop"), this._element.remove(), this._isAppended = !1);
    }

    _emulateAnimation(t) {
      y(t, this._getElement(), this._config.isAnimated);
    }

  }

  const vt = {
    trapElement: null,
    autofocus: !0
  },
        yt = {
    trapElement: "element",
    autofocus: "boolean"
  };

  class wt {
    constructor(t) {
      this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null;
    }

    activate() {
      const {
        trapElement: t,
        autofocus: e
      } = this._config;
      this._isActive || (e && t.focus(), H.off(document, ".bs.focustrap"), H.on(document, "focusin.bs.focustrap", t => this._handleFocusin(t)), H.on(document, "keydown.tab.bs.focustrap", t => this._handleKeydown(t)), this._isActive = !0);
    }

    deactivate() {
      this._isActive && (this._isActive = !1, H.off(document, ".bs.focustrap"));
    }

    _handleFocusin(t) {
      const {
        target: e
      } = t,
            {
        trapElement: i
      } = this._config;
      if (e === document || e === i || i.contains(e)) return;
      const s = V.focusableChildren(i);
      0 === s.length ? i.focus() : "backward" === this._lastTabNavDirection ? s[s.length - 1].focus() : s[0].focus();
    }

    _handleKeydown(t) {
      "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? "backward" : "forward");
    }

    _getConfig(t) {
      return t = { ...vt,
        ...("object" == typeof t ? t : {})
      }, c("focustrap", t, yt), t;
    }

  }

  const Et = {
    backdrop: !0,
    keyboard: !0,
    focus: !0
  },
        At = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    focus: "boolean"
  };

  class Tt extends R {
    constructor(t, e) {
      super(t), this._config = this._getConfig(e), this._dialog = V.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new ft();
    }

    static get Default() {
      return Et;
    }

    static get NAME() {
      return "modal";
    }

    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }

    show(t) {
      this._isShown || this._isTransitioning || H.trigger(this._element, "show.bs.modal", {
        relatedTarget: t
      }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add("modal-open"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), H.on(this._dialog, "mousedown.dismiss.bs.modal", () => {
        H.one(this._element, "mouseup.dismiss.bs.modal", t => {
          t.target === this._element && (this._ignoreBackdropClick = !0);
        });
      }), this._showBackdrop(() => this._showElement(t)));
    }

    hide() {
      if (!this._isShown || this._isTransitioning) return;
      if (H.trigger(this._element, "hide.bs.modal").defaultPrevented) return;
      this._isShown = !1;

      const t = this._isAnimated();

      t && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.deactivate(), this._element.classList.remove("show"), H.off(this._element, "click.dismiss.bs.modal"), H.off(this._dialog, "mousedown.dismiss.bs.modal"), this._queueCallback(() => this._hideModal(), this._element, t);
    }

    dispose() {
      [window, this._dialog].forEach(t => H.off(t, ".bs.modal")), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }

    handleUpdate() {
      this._adjustDialog();
    }

    _initializeBackDrop() {
      return new bt({
        isVisible: Boolean(this._config.backdrop),
        isAnimated: this._isAnimated()
      });
    }

    _initializeFocusTrap() {
      return new wt({
        trapElement: this._element
      });
    }

    _getConfig(t) {
      return t = { ...Et,
        ...K.getDataAttributes(this._element),
        ...("object" == typeof t ? t : {})
      }, c("modal", t, At), t;
    }

    _showElement(t) {
      const e = this._isAnimated(),
            i = V.findOne(".modal-body", this._dialog);

      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, i && (i.scrollTop = 0), e && p(this._element), this._element.classList.add("show"), this._queueCallback(() => {
        this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, H.trigger(this._element, "shown.bs.modal", {
          relatedTarget: t
        });
      }, this._dialog, e);
    }

    _setEscapeEvent() {
      this._isShown ? H.on(this._element, "keydown.dismiss.bs.modal", t => {
        this._config.keyboard && "Escape" === t.key ? (t.preventDefault(), this.hide()) : this._config.keyboard || "Escape" !== t.key || this._triggerBackdropTransition();
      }) : H.off(this._element, "keydown.dismiss.bs.modal");
    }

    _setResizeEvent() {
      this._isShown ? H.on(window, "resize.bs.modal", () => this._adjustDialog()) : H.off(window, "resize.bs.modal");
    }

    _hideModal() {
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
        document.body.classList.remove("modal-open"), this._resetAdjustments(), this._scrollBar.reset(), H.trigger(this._element, "hidden.bs.modal");
      });
    }

    _showBackdrop(t) {
      H.on(this._element, "click.dismiss.bs.modal", t => {
        this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : t.target === t.currentTarget && (!0 === this._config.backdrop ? this.hide() : "static" === this._config.backdrop && this._triggerBackdropTransition());
      }), this._backdrop.show(t);
    }

    _isAnimated() {
      return this._element.classList.contains("fade");
    }

    _triggerBackdropTransition() {
      if (H.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) return;
      const {
        classList: t,
        scrollHeight: e,
        style: i
      } = this._element,
            s = e > document.documentElement.clientHeight;
      !s && "hidden" === i.overflowY || t.contains("modal-static") || (s || (i.overflowY = "hidden"), t.add("modal-static"), this._queueCallback(() => {
        t.remove("modal-static"), s || this._queueCallback(() => {
          i.overflowY = "";
        }, this._dialog);
      }, this._dialog), this._element.focus());
    }

    _adjustDialog() {
      const t = this._element.scrollHeight > document.documentElement.clientHeight,
            e = this._scrollBar.getWidth(),
            i = e > 0;

      (!i && t && !m() || i && !t && m()) && (this._element.style.paddingLeft = e + "px"), (i && !t && !m() || !i && t && m()) && (this._element.style.paddingRight = e + "px");
    }

    _resetAdjustments() {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
    }

    static jQueryInterface(t, e) {
      return this.each(function () {
        const i = Tt.getOrCreateInstance(this, t);

        if ("string" == typeof t) {
          if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
          i[t](e);
        }
      });
    }

  }

  H.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', function (t) {
    const e = o(this);
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), H.one(e, "show.bs.modal", t => {
      t.defaultPrevented || H.one(e, "hidden.bs.modal", () => {
        h(this) && this.focus();
      });
    }), Tt.getOrCreateInstance(e).toggle(this);
  }), F(Tt), b(Tt);
  const Ct = {
    backdrop: !0,
    keyboard: !0,
    scroll: !1
  },
        kt = {
    backdrop: "boolean",
    keyboard: "boolean",
    scroll: "boolean"
  };

  class Lt extends R {
    constructor(t, e) {
      super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
    }

    static get NAME() {
      return "offcanvas";
    }

    static get Default() {
      return Ct;
    }

    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }

    show(t) {
      this._isShown || H.trigger(this._element, "show.bs.offcanvas", {
        relatedTarget: t
      }).defaultPrevented || (this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new ft().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add("show"), this._queueCallback(() => {
        this._config.scroll || this._focustrap.activate(), H.trigger(this._element, "shown.bs.offcanvas", {
          relatedTarget: t
        });
      }, this._element, !0));
    }

    hide() {
      this._isShown && (H.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.remove("show"), this._backdrop.hide(), this._queueCallback(() => {
        this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new ft().reset(), H.trigger(this._element, "hidden.bs.offcanvas");
      }, this._element, !0)));
    }

    dispose() {
      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }

    _getConfig(t) {
      return t = { ...Ct,
        ...K.getDataAttributes(this._element),
        ...("object" == typeof t ? t : {})
      }, c("offcanvas", t, kt), t;
    }

    _initializeBackDrop() {
      return new bt({
        className: "offcanvas-backdrop",
        isVisible: this._config.backdrop,
        isAnimated: !0,
        rootElement: this._element.parentNode,
        clickCallback: () => this.hide()
      });
    }

    _initializeFocusTrap() {
      return new wt({
        trapElement: this._element
      });
    }

    _addEventListeners() {
      H.on(this._element, "keydown.dismiss.bs.offcanvas", t => {
        this._config.keyboard && "Escape" === t.key && this.hide();
      });
    }

    static jQueryInterface(t) {
      return this.each(function () {
        const e = Lt.getOrCreateInstance(this, t);

        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }

  }

  H.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', function (t) {
    const e = o(this);
    if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), d(this)) return;
    H.one(e, "hidden.bs.offcanvas", () => {
      h(this) && this.focus();
    });
    const i = V.findOne(".offcanvas.show");
    i && i !== e && Lt.getInstance(i).hide(), Lt.getOrCreateInstance(e).toggle(this);
  }), H.on(window, "load.bs.offcanvas.data-api", () => V.find(".offcanvas.show").forEach(t => Lt.getOrCreateInstance(t).show())), F(Lt), b(Lt);

  const St = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
        Ot = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i,
        Nt = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
        Dt = (t, e) => {
    const i = t.nodeName.toLowerCase();
    if (e.includes(i)) return !St.has(i) || Boolean(Ot.test(t.nodeValue) || Nt.test(t.nodeValue));
    const s = e.filter(t => t instanceof RegExp);

    for (let t = 0, e = s.length; t < e; t++) if (s[t].test(i)) return !0;

    return !1;
  };

  function It(t, e, i) {
    if (!t.length) return t;
    if (i && "function" == typeof i) return i(t);
    const s = new window.DOMParser().parseFromString(t, "text/html"),
          n = Object.keys(e),
          o = [].concat(...s.body.querySelectorAll("*"));

    for (let t = 0, i = o.length; t < i; t++) {
      const i = o[t],
            s = i.nodeName.toLowerCase();

      if (!n.includes(s)) {
        i.remove();
        continue;
      }

      const r = [].concat(...i.attributes),
            a = [].concat(e["*"] || [], e[s] || []);
      r.forEach(t => {
        Dt(t, a) || i.removeAttribute(t.nodeName);
      });
    }

    return s.body.innerHTML;
  }

  const xt = new Set(["sanitize", "allowList", "sanitizeFn"]),
        Pt = {
    animation: "boolean",
    template: "string",
    title: "(string|element|function)",
    trigger: "string",
    delay: "(number|object)",
    html: "boolean",
    selector: "(string|boolean)",
    placement: "(string|function)",
    offset: "(array|string|function)",
    container: "(string|element|boolean)",
    fallbackPlacements: "array",
    boundary: "(string|element)",
    customClass: "(string|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    allowList: "object",
    popperConfig: "(null|object|function)"
  },
        Mt = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: m() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: m() ? "right" : "left"
  },
        jt = {
    animation: !0,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: "hover focus",
    title: "",
    delay: 0,
    html: !1,
    selector: !1,
    placement: "top",
    offset: [0, 0],
    container: !1,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    boundary: "clippingParents",
    customClass: "",
    sanitize: !0,
    sanitizeFn: null,
    allowList: {
      "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
      a: ["target", "href", "title", "rel"],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      div: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ["src", "srcset", "alt", "title", "width", "height"],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: []
    },
    popperConfig: null
  },
        Ht = {
    HIDE: "hide.bs.tooltip",
    HIDDEN: "hidden.bs.tooltip",
    SHOW: "show.bs.tooltip",
    SHOWN: "shown.bs.tooltip",
    INSERTED: "inserted.bs.tooltip",
    CLICK: "click.bs.tooltip",
    FOCUSIN: "focusin.bs.tooltip",
    FOCUSOUT: "focusout.bs.tooltip",
    MOUSEENTER: "mouseenter.bs.tooltip",
    MOUSELEAVE: "mouseleave.bs.tooltip"
  };

  class Bt extends R {
    constructor(t, e) {
      if (void 0 === i) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();
    }

    static get Default() {
      return jt;
    }

    static get NAME() {
      return "tooltip";
    }

    static get Event() {
      return Ht;
    }

    static get DefaultType() {
      return Pt;
    }

    enable() {
      this._isEnabled = !0;
    }

    disable() {
      this._isEnabled = !1;
    }

    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }

    toggle(t) {
      if (this._isEnabled) if (t) {
        const e = this._initializeOnDelegatedTarget(t);

        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);
      } else {
        if (this.getTipElement().classList.contains("show")) return void this._leave(null, this);

        this._enter(null, this);
      }
    }

    dispose() {
      clearTimeout(this._timeout), H.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.remove(), this._popper && this._popper.destroy(), super.dispose();
    }

    show() {
      if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
      if (!this.isWithContent() || !this._isEnabled) return;
      const t = H.trigger(this._element, this.constructor.Event.SHOW),
            e = u(this._element),
            s = null === e ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);
      if (t.defaultPrevented || !s) return;

      const n = this.getTipElement(),
            o = (t => {
        do {
          t += Math.floor(1e6 * Math.random());
        } while (document.getElementById(t));

        return t;
      })(this.constructor.NAME);

      n.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this._config.animation && n.classList.add("fade");

      const r = "function" == typeof this._config.placement ? this._config.placement.call(this, n, this._element) : this._config.placement,
            a = this._getAttachment(r);

      this._addAttachmentClass(a);

      const {
        container: l
      } = this._config;
      z.set(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), H.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = i.createPopper(this._element, n, this._getPopperConfig(a)), n.classList.add("show");

      const c = this._resolvePossibleFunction(this._config.customClass);

      c && n.classList.add(...c.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => {
        H.on(t, "mouseover", g);
      });
      const h = this.tip.classList.contains("fade");

      this._queueCallback(() => {
        const t = this._hoverState;
        this._hoverState = null, H.trigger(this._element, this.constructor.Event.SHOWN), "out" === t && this._leave(null, this);
      }, this.tip, h);
    }

    hide() {
      if (!this._popper) return;
      const t = this.getTipElement();
      if (H.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return;
      t.classList.remove("show"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => H.off(t, "mouseover", g)), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1;
      const e = this.tip.classList.contains("fade");
      this._queueCallback(() => {
        this._isWithActiveTrigger() || ("show" !== this._hoverState && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), H.trigger(this._element, this.constructor.Event.HIDDEN), this._popper && (this._popper.destroy(), this._popper = null));
      }, this.tip, e), this._hoverState = "";
    }

    update() {
      null !== this._popper && this._popper.update();
    }

    isWithContent() {
      return Boolean(this.getTitle());
    }

    getTipElement() {
      if (this.tip) return this.tip;
      const t = document.createElement("div");
      t.innerHTML = this._config.template;
      const e = t.children[0];
      return this.setContent(e), e.classList.remove("fade", "show"), this.tip = e, this.tip;
    }

    setContent(t) {
      this._sanitizeAndSetContent(t, this.getTitle(), ".tooltip-inner");
    }

    _sanitizeAndSetContent(t, e, i) {
      const s = V.findOne(i, t);
      e || !s ? this.setElementContent(s, e) : s.remove();
    }

    setElementContent(t, e) {
      if (null !== t) return a(e) ? (e = l(e), void (this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent)) : void (this._config.html ? (this._config.sanitize && (e = It(e, this._config.allowList, this._config.sanitizeFn)), t.innerHTML = e) : t.textContent = e);
    }

    getTitle() {
      const t = this._element.getAttribute("data-bs-original-title") || this._config.title;

      return this._resolvePossibleFunction(t);
    }

    updateAttachment(t) {
      return "right" === t ? "end" : "left" === t ? "start" : t;
    }

    _initializeOnDelegatedTarget(t, e) {
      return e || this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());
    }

    _getOffset() {
      const {
        offset: t
      } = this._config;
      return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t;
    }

    _resolvePossibleFunction(t) {
      return "function" == typeof t ? t.call(this._element) : t;
    }

    _getPopperConfig(t) {
      const e = {
        placement: t,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "onChange",
          enabled: !0,
          phase: "afterWrite",
          fn: t => this._handlePopperPlacementChange(t)
        }],
        onFirstUpdate: t => {
          t.options.placement !== t.placement && this._handlePopperPlacementChange(t);
        }
      };
      return { ...e,
        ...("function" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig)
      };
    }

    _addAttachmentClass(t) {
      this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`);
    }

    _getAttachment(t) {
      return Mt[t.toUpperCase()];
    }

    _setListeners() {
      this._config.trigger.split(" ").forEach(t => {
        if ("click" === t) H.on(this._element, this.constructor.Event.CLICK, this._config.selector, t => this.toggle(t));else if ("manual" !== t) {
          const e = "hover" === t ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN,
                i = "hover" === t ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
          H.on(this._element, e, this._config.selector, t => this._enter(t)), H.on(this._element, i, this._config.selector, t => this._leave(t));
        }
      }), this._hideModalHandler = () => {
        this._element && this.hide();
      }, H.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this._config.selector ? this._config = { ...this._config,
        trigger: "manual",
        selector: ""
      } : this._fixTitle();
    }

    _fixTitle() {
      const t = this._element.getAttribute("title"),
            e = typeof this._element.getAttribute("data-bs-original-title");

      (t || "string" !== e) && (this._element.setAttribute("data-bs-original-title", t || ""), !t || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""));
    }

    _enter(t, e) {
      e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger["focusin" === t.type ? "focus" : "hover"] = !0), e.getTipElement().classList.contains("show") || "show" === e._hoverState ? e._hoverState = "show" : (clearTimeout(e._timeout), e._hoverState = "show", e._config.delay && e._config.delay.show ? e._timeout = setTimeout(() => {
        "show" === e._hoverState && e.show();
      }, e._config.delay.show) : e.show());
    }

    _leave(t, e) {
      e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger["focusout" === t.type ? "focus" : "hover"] = e._element.contains(t.relatedTarget)), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = "out", e._config.delay && e._config.delay.hide ? e._timeout = setTimeout(() => {
        "out" === e._hoverState && e.hide();
      }, e._config.delay.hide) : e.hide());
    }

    _isWithActiveTrigger() {
      for (const t in this._activeTrigger) if (this._activeTrigger[t]) return !0;

      return !1;
    }

    _getConfig(t) {
      const e = K.getDataAttributes(this._element);
      return Object.keys(e).forEach(t => {
        xt.has(t) && delete e[t];
      }), (t = { ...this.constructor.Default,
        ...e,
        ...("object" == typeof t && t ? t : {})
      }).container = !1 === t.container ? document.body : l(t.container), "number" == typeof t.delay && (t.delay = {
        show: t.delay,
        hide: t.delay
      }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), c("tooltip", t, this.constructor.DefaultType), t.sanitize && (t.template = It(t.template, t.allowList, t.sanitizeFn)), t;
    }

    _getDelegateConfig() {
      const t = {};

      for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);

      return t;
    }

    _cleanTipClass() {
      const t = this.getTipElement(),
            e = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"),
            i = t.getAttribute("class").match(e);
      null !== i && i.length > 0 && i.map(t => t.trim()).forEach(e => t.classList.remove(e));
    }

    _getBasicClassPrefix() {
      return "bs-tooltip";
    }

    _handlePopperPlacementChange(t) {
      const {
        state: e
      } = t;
      e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));
    }

    static jQueryInterface(t) {
      return this.each(function () {
        const e = Bt.getOrCreateInstance(this, t);

        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }

  }

  b(Bt);
  const zt = { ...Bt.Default,
    placement: "right",
    offset: [0, 8],
    trigger: "click",
    content: "",
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
  },
        Rt = { ...Bt.DefaultType,
    content: "(string|element|function)"
  },
        Ft = {
    HIDE: "hide.bs.popover",
    HIDDEN: "hidden.bs.popover",
    SHOW: "show.bs.popover",
    SHOWN: "shown.bs.popover",
    INSERTED: "inserted.bs.popover",
    CLICK: "click.bs.popover",
    FOCUSIN: "focusin.bs.popover",
    FOCUSOUT: "focusout.bs.popover",
    MOUSEENTER: "mouseenter.bs.popover",
    MOUSELEAVE: "mouseleave.bs.popover"
  };

  class Wt extends Bt {
    static get Default() {
      return zt;
    }

    static get NAME() {
      return "popover";
    }

    static get Event() {
      return Ft;
    }

    static get DefaultType() {
      return Rt;
    }

    isWithContent() {
      return this.getTitle() || this._getContent();
    }

    setContent(t) {
      this._sanitizeAndSetContent(t, this.getTitle(), ".popover-header"), this._sanitizeAndSetContent(t, this._getContent(), ".popover-body");
    }

    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }

    _getBasicClassPrefix() {
      return "bs-popover";
    }

    static jQueryInterface(t) {
      return this.each(function () {
        const e = Wt.getOrCreateInstance(this, t);

        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }

  }

  b(Wt);
  const $t = {
    offset: 10,
    method: "auto",
    target: ""
  },
        qt = {
    offset: "number",
    method: "string",
    target: "(string|element)"
  },
        Ut = ".nav-link, .list-group-item, .dropdown-item";

  class Kt extends R {
    constructor(t, e) {
      super(t), this._scrollElement = "BODY" === this._element.tagName ? window : this._element, this._config = this._getConfig(e), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, H.on(this._scrollElement, "scroll.bs.scrollspy", () => this._process()), this.refresh(), this._process();
    }

    static get Default() {
      return $t;
    }

    static get NAME() {
      return "scrollspy";
    }

    refresh() {
      const t = this._scrollElement === this._scrollElement.window ? "offset" : "position",
            e = "auto" === this._config.method ? t : this._config.method,
            i = "position" === e ? this._getScrollTop() : 0;
      this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), V.find(Ut, this._config.target).map(t => {
        const s = n(t),
              o = s ? V.findOne(s) : null;

        if (o) {
          const t = o.getBoundingClientRect();
          if (t.width || t.height) return [K[e](o).top + i, s];
        }

        return null;
      }).filter(t => t).sort((t, e) => t[0] - e[0]).forEach(t => {
        this._offsets.push(t[0]), this._targets.push(t[1]);
      });
    }

    dispose() {
      H.off(this._scrollElement, ".bs.scrollspy"), super.dispose();
    }

    _getConfig(t) {
      return (t = { ...$t,
        ...K.getDataAttributes(this._element),
        ...("object" == typeof t && t ? t : {})
      }).target = l(t.target) || document.documentElement, c("scrollspy", t, qt), t;
    }

    _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    }

    _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }

    _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    }

    _process() {
      const t = this._getScrollTop() + this._config.offset,
            e = this._getScrollHeight(),
            i = this._config.offset + e - this._getOffsetHeight();

      if (this._scrollHeight !== e && this.refresh(), t >= i) {
        const t = this._targets[this._targets.length - 1];
        this._activeTarget !== t && this._activate(t);
      } else {
        if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();

        for (let e = this._offsets.length; e--;) this._activeTarget !== this._targets[e] && t >= this._offsets[e] && (void 0 === this._offsets[e + 1] || t < this._offsets[e + 1]) && this._activate(this._targets[e]);
      }
    }

    _activate(t) {
      this._activeTarget = t, this._clear();
      const e = Ut.split(",").map(e => `${e}[data-bs-target="${t}"],${e}[href="${t}"]`),
            i = V.findOne(e.join(","), this._config.target);
      i.classList.add("active"), i.classList.contains("dropdown-item") ? V.findOne(".dropdown-toggle", i.closest(".dropdown")).classList.add("active") : V.parents(i, ".nav, .list-group").forEach(t => {
        V.prev(t, ".nav-link, .list-group-item").forEach(t => t.classList.add("active")), V.prev(t, ".nav-item").forEach(t => {
          V.children(t, ".nav-link").forEach(t => t.classList.add("active"));
        });
      }), H.trigger(this._scrollElement, "activate.bs.scrollspy", {
        relatedTarget: t
      });
    }

    _clear() {
      V.find(Ut, this._config.target).filter(t => t.classList.contains("active")).forEach(t => t.classList.remove("active"));
    }

    static jQueryInterface(t) {
      return this.each(function () {
        const e = Kt.getOrCreateInstance(this, t);

        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }

  }

  H.on(window, "load.bs.scrollspy.data-api", () => {
    V.find('[data-bs-spy="scroll"]').forEach(t => new Kt(t));
  }), b(Kt);

  class Vt extends R {
    static get NAME() {
      return "tab";
    }

    show() {
      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active")) return;
      let t;

      const e = o(this._element),
            i = this._element.closest(".nav, .list-group");

      if (i) {
        const e = "UL" === i.nodeName || "OL" === i.nodeName ? ":scope > li > .active" : ".active";
        t = V.find(e, i), t = t[t.length - 1];
      }

      const s = t ? H.trigger(t, "hide.bs.tab", {
        relatedTarget: this._element
      }) : null;
      if (H.trigger(this._element, "show.bs.tab", {
        relatedTarget: t
      }).defaultPrevented || null !== s && s.defaultPrevented) return;

      this._activate(this._element, i);

      const n = () => {
        H.trigger(t, "hidden.bs.tab", {
          relatedTarget: this._element
        }), H.trigger(this._element, "shown.bs.tab", {
          relatedTarget: t
        });
      };

      e ? this._activate(e, e.parentNode, n) : n();
    }

    _activate(t, e, i) {
      const s = (!e || "UL" !== e.nodeName && "OL" !== e.nodeName ? V.children(e, ".active") : V.find(":scope > li > .active", e))[0],
            n = i && s && s.classList.contains("fade"),
            o = () => this._transitionComplete(t, s, i);

      s && n ? (s.classList.remove("show"), this._queueCallback(o, t, !0)) : o();
    }

    _transitionComplete(t, e, i) {
      if (e) {
        e.classList.remove("active");
        const t = V.findOne(":scope > .dropdown-menu .active", e.parentNode);
        t && t.classList.remove("active"), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1);
      }

      t.classList.add("active"), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), p(t), t.classList.contains("fade") && t.classList.add("show");
      let s = t.parentNode;

      if (s && "LI" === s.nodeName && (s = s.parentNode), s && s.classList.contains("dropdown-menu")) {
        const e = t.closest(".dropdown");
        e && V.find(".dropdown-toggle", e).forEach(t => t.classList.add("active")), t.setAttribute("aria-expanded", !0);
      }

      i && i();
    }

    static jQueryInterface(t) {
      return this.each(function () {
        const e = Vt.getOrCreateInstance(this);

        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }

  }

  H.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', function (t) {
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), d(this) || Vt.getOrCreateInstance(this).show();
  }), b(Vt);
  const Xt = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  },
        Yt = {
    animation: !0,
    autohide: !0,
    delay: 5e3
  };

  class Qt extends R {
    constructor(t, e) {
      super(t), this._config = this._getConfig(e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
    }

    static get DefaultType() {
      return Xt;
    }

    static get Default() {
      return Yt;
    }

    static get NAME() {
      return "toast";
    }

    show() {
      H.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove("hide"), p(this._element), this._element.classList.add("show"), this._element.classList.add("showing"), this._queueCallback(() => {
        this._element.classList.remove("showing"), H.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide();
      }, this._element, this._config.animation));
    }

    hide() {
      this._element.classList.contains("show") && (H.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.add("showing"), this._queueCallback(() => {
        this._element.classList.add("hide"), this._element.classList.remove("showing"), this._element.classList.remove("show"), H.trigger(this._element, "hidden.bs.toast");
      }, this._element, this._config.animation)));
    }

    dispose() {
      this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), super.dispose();
    }

    _getConfig(t) {
      return t = { ...Yt,
        ...K.getDataAttributes(this._element),
        ...("object" == typeof t && t ? t : {})
      }, c("toast", t, this.constructor.DefaultType), t;
    }

    _maybeScheduleHide() {
      this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay)));
    }

    _onInteraction(t, e) {
      switch (t.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = e;
          break;

        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = e;
      }

      if (e) return void this._clearTimeout();
      const i = t.relatedTarget;
      this._element === i || this._element.contains(i) || this._maybeScheduleHide();
    }

    _setListeners() {
      H.on(this._element, "mouseover.bs.toast", t => this._onInteraction(t, !0)), H.on(this._element, "mouseout.bs.toast", t => this._onInteraction(t, !1)), H.on(this._element, "focusin.bs.toast", t => this._onInteraction(t, !0)), H.on(this._element, "focusout.bs.toast", t => this._onInteraction(t, !1));
    }

    _clearTimeout() {
      clearTimeout(this._timeout), this._timeout = null;
    }

    static jQueryInterface(t) {
      return this.each(function () {
        const e = Qt.getOrCreateInstance(this, t);

        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }

  }

  return F(Qt), b(Qt), {
    Alert: W,
    Button: $,
    Carousel: et,
    Collapse: nt,
    Dropdown: pt,
    Modal: Tt,
    Offcanvas: Lt,
    Popover: Wt,
    ScrollSpy: Kt,
    Tab: Vt,
    Toast: Qt,
    Tooltip: Bt
  };
});
!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t() : "function" == typeof define && define.amd ? define(t) : t();
}(0, function () {
  "use strict";

  function e(e) {
    var t = !0,
        n = !1,
        o = null,
        d = {
      text: !0,
      search: !0,
      url: !0,
      tel: !0,
      email: !0,
      password: !0,
      number: !0,
      date: !0,
      month: !0,
      week: !0,
      time: !0,
      datetime: !0,
      "datetime-local": !0
    };

    function i(e) {
      return !!(e && e !== document && "HTML" !== e.nodeName && "BODY" !== e.nodeName && "classList" in e && "contains" in e.classList);
    }

    function s(e) {
      e.classList.contains("focus-visible") || (e.classList.add("focus-visible"), e.setAttribute("data-focus-visible-added", ""));
    }

    function u(e) {
      t = !1;
    }

    function a() {
      document.addEventListener("mousemove", c), document.addEventListener("mousedown", c), document.addEventListener("mouseup", c), document.addEventListener("pointermove", c), document.addEventListener("pointerdown", c), document.addEventListener("pointerup", c), document.addEventListener("touchmove", c), document.addEventListener("touchstart", c), document.addEventListener("touchend", c);
    }

    function c(e) {
      e.target.nodeName && "html" === e.target.nodeName.toLowerCase() || (t = !1, document.removeEventListener("mousemove", c), document.removeEventListener("mousedown", c), document.removeEventListener("mouseup", c), document.removeEventListener("pointermove", c), document.removeEventListener("pointerdown", c), document.removeEventListener("pointerup", c), document.removeEventListener("touchmove", c), document.removeEventListener("touchstart", c), document.removeEventListener("touchend", c));
    }

    document.addEventListener("keydown", function (n) {
      n.metaKey || n.altKey || n.ctrlKey || (i(e.activeElement) && s(e.activeElement), t = !0);
    }, !0), document.addEventListener("mousedown", u, !0), document.addEventListener("pointerdown", u, !0), document.addEventListener("touchstart", u, !0), document.addEventListener("visibilitychange", function (e) {
      "hidden" === document.visibilityState && (n && (t = !0), a());
    }, !0), a(), e.addEventListener("focus", function (e) {
      var n, o, u;
      i(e.target) && (t || (n = e.target, o = n.type, "INPUT" === (u = n.tagName) && d[o] && !n.readOnly || "TEXTAREA" === u && !n.readOnly || n.isContentEditable)) && s(e.target);
    }, !0), e.addEventListener("blur", function (e) {
      var t;
      i(e.target) && (e.target.classList.contains("focus-visible") || e.target.hasAttribute("data-focus-visible-added")) && (n = !0, window.clearTimeout(o), o = window.setTimeout(function () {
        n = !1;
      }, 100), (t = e.target).hasAttribute("data-focus-visible-added") && (t.classList.remove("focus-visible"), t.removeAttribute("data-focus-visible-added")));
    }, !0), e.nodeType === Node.DOCUMENT_FRAGMENT_NODE && e.host ? e.host.setAttribute("data-js-focus-visible", "") : e.nodeType === Node.DOCUMENT_NODE && (document.documentElement.classList.add("js-focus-visible"), document.documentElement.setAttribute("data-js-focus-visible", ""));
  }

  if ("undefined" != typeof window && "undefined" != typeof document) {
    var t;
    window.applyFocusVisiblePolyfill = e;

    try {
      t = new CustomEvent("focus-visible-polyfill-ready");
    } catch (e) {
      (t = document.createEvent("CustomEvent")).initCustomEvent("focus-visible-polyfill-ready", !1, !1, {});
    }

    window.dispatchEvent(t);
  }

  "undefined" != typeof document && e(document);
});
/*!
  hey, [be]Lazy.js - v1.8.2 - 2016.10.25
  A fast, small and dependency free lazy load script (https://github.com/dinbror/blazy)
  (c) Bjoern Klinggaard - @bklinggaard - http://dinbror.dk/blazy
*/
(function (q, m) {
  "function" === typeof define && define.amd ? define(m) : "object" === typeof exports ? module.exports = m() : q.Blazy = m();
})(this, function () {
  function q(b) {
    var c = b._util;
    c.elements = E(b.options);
    c.count = c.elements.length;
    c.destroyed && (c.destroyed = !1, b.options.container && l(b.options.container, function (a) {
      n(a, "scroll", c.validateT);
    }), n(window, "resize", c.saveViewportOffsetT), n(window, "resize", c.validateT), n(window, "scroll", c.validateT));
    m(b);
  }

  function m(b) {
    for (var c = b._util, a = 0; a < c.count; a++) {
      var d = c.elements[a],
          e;

      a: {
        var g = d;
        e = b.options;
        var p = g.getBoundingClientRect();

        if (e.container && y && (g = g.closest(e.containerClass))) {
          g = g.getBoundingClientRect();
          e = r(g, f) ? r(p, {
            top: g.top - e.offset,
            right: g.right + e.offset,
            bottom: g.bottom + e.offset,
            left: g.left - e.offset
          }) : !1;
          break a;
        }

        e = r(p, f);
      }

      if (e || t(d, b.options.successClass)) b.load(d), c.elements.splice(a, 1), c.count--, a--;
    }

    0 === c.count && b.destroy();
  }

  function r(b, c) {
    return b.right >= c.left && b.bottom >= c.top && b.left <= c.right && b.top <= c.bottom;
  }

  function z(b, c, a) {
    if (!t(b, a.successClass) && (c || a.loadInvisible || 0 < b.offsetWidth && 0 < b.offsetHeight)) if (c = b.getAttribute(u) || b.getAttribute(a.src)) {
      c = c.split(a.separator);
      var d = c[A && 1 < c.length ? 1 : 0],
          e = b.getAttribute(a.srcset),
          g = "img" === b.nodeName.toLowerCase(),
          p = (c = b.parentNode) && "picture" === c.nodeName.toLowerCase();

      if (g || void 0 === b.src) {
        var h = new Image(),
            w = function () {
          a.error && a.error(b, "invalid");
          v(b, a.errorClass);
          k(h, "error", w);
          k(h, "load", f);
        },
            f = function () {
          g ? p || B(b, d, e) : b.style.backgroundImage = 'url("' + d + '")';
          x(b, a);
          k(h, "load", f);
          k(h, "error", w);
        };

        p && (h = b, l(c.getElementsByTagName("source"), function (b) {
          var c = a.srcset,
              e = b.getAttribute(c);
          e && (b.setAttribute("srcset", e), b.removeAttribute(c));
        }));
        n(h, "error", w);
        n(h, "load", f);
        B(h, d, e);
      } else b.src = d, x(b, a);
    } else "video" === b.nodeName.toLowerCase() ? (l(b.getElementsByTagName("source"), function (b) {
      var c = a.src,
          e = b.getAttribute(c);
      e && (b.setAttribute("src", e), b.removeAttribute(c));
    }), b.load(), x(b, a)) : (a.error && a.error(b, "missing"), v(b, a.errorClass));
  }

  function x(b, c) {
    v(b, c.successClass);
    c.success && c.success(b);
    b.removeAttribute(c.src);
    b.removeAttribute(c.srcset);
    l(c.breakpoints, function (a) {
      b.removeAttribute(a.src);
    });
  }

  function B(b, c, a) {
    a && b.setAttribute("srcset", a);
    b.src = c;
  }

  function t(b, c) {
    return -1 !== (" " + b.className + " ").indexOf(" " + c + " ");
  }

  function v(b, c) {
    t(b, c) || (b.className += " " + c);
  }

  function E(b) {
    var c = [];
    b = b.root.querySelectorAll(b.selector);

    for (var a = b.length; a--; c.unshift(b[a]));

    return c;
  }

  function C(b) {
    f.bottom = (window.innerHeight || document.documentElement.clientHeight) + b;
    f.right = (window.innerWidth || document.documentElement.clientWidth) + b;
  }

  function n(b, c, a) {
    b.attachEvent ? b.attachEvent && b.attachEvent("on" + c, a) : b.addEventListener(c, a, {
      capture: !1,
      passive: !0
    });
  }

  function k(b, c, a) {
    b.detachEvent ? b.detachEvent && b.detachEvent("on" + c, a) : b.removeEventListener(c, a, {
      capture: !1,
      passive: !0
    });
  }

  function l(b, c) {
    if (b && c) for (var a = b.length, d = 0; d < a && !1 !== c(b[d], d); d++);
  }

  function D(b, c, a) {
    var d = 0;
    return function () {
      var e = +new Date();
      e - d < c || (d = e, b.apply(a, arguments));
    };
  }

  var u, f, A, y;
  return function (b) {
    if (!document.querySelectorAll) {
      var c = document.createStyleSheet();

      document.querySelectorAll = function (a, b, d, h, f) {
        f = document.all;
        b = [];
        a = a.replace(/\[for\b/gi, "[htmlFor").split(",");

        for (d = a.length; d--;) {
          c.addRule(a[d], "k:v");

          for (h = f.length; h--;) f[h].currentStyle.k && b.push(f[h]);

          c.removeRule(0);
        }

        return b;
      };
    }

    var a = this,
        d = a._util = {};
    d.elements = [];
    d.destroyed = !0;
    a.options = b || {};
    a.options.error = a.options.error || !1;
    a.options.offset = a.options.offset || 100;
    a.options.root = a.options.root || document;
    a.options.success = a.options.success || !1;
    a.options.selector = a.options.selector || ".b-lazy";
    a.options.separator = a.options.separator || "|";
    a.options.containerClass = a.options.container;
    a.options.container = a.options.containerClass ? document.querySelectorAll(a.options.containerClass) : !1;
    a.options.errorClass = a.options.errorClass || "b-error";
    a.options.breakpoints = a.options.breakpoints || !1;
    a.options.loadInvisible = a.options.loadInvisible || !1;
    a.options.successClass = a.options.successClass || "b-loaded";
    a.options.validateDelay = a.options.validateDelay || 25;
    a.options.saveViewportOffsetDelay = a.options.saveViewportOffsetDelay || 50;
    a.options.srcset = a.options.srcset || "data-srcset";
    a.options.src = u = a.options.src || "data-src";
    y = Element.prototype.closest;
    A = 1 < window.devicePixelRatio;
    f = {};
    f.top = 0 - a.options.offset;
    f.left = 0 - a.options.offset;

    a.revalidate = function () {
      q(a);
    };

    a.load = function (a, b) {
      var c = this.options;
      void 0 === a.length ? z(a, b, c) : l(a, function (a) {
        z(a, b, c);
      });
    };

    a.destroy = function () {
      var a = this._util;
      this.options.container && l(this.options.container, function (b) {
        k(b, "scroll", a.validateT);
      });
      k(window, "scroll", a.validateT);
      k(window, "resize", a.validateT);
      k(window, "resize", a.saveViewportOffsetT);
      a.count = 0;
      a.elements.length = 0;
      a.destroyed = !0;
    };

    d.validateT = D(function () {
      m(a);
    }, a.options.validateDelay, a);
    d.saveViewportOffsetT = D(function () {
      C(a.options.offset);
    }, a.options.saveViewportOffsetDelay, a);
    C(a.options.offset);
    l(a.options.breakpoints, function (a) {
      if (a.width >= window.screen.width) return u = a.src, !1;
    });
    setTimeout(function () {
      q(a);
    });
  };
});
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).IMask = {});
}(this, function (t) {
  "use strict";

  var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
      n = function (t) {
    return t && t.Math == Math && t;
  },
      u = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof e && e) || function () {
    return this;
  }() || Function("return this")(),
      r = {},
      i = function (t) {
    try {
      return !!t();
    } catch (t) {
      return !0;
    }
  },
      a = !i(function () {
    return 7 != Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      }
    })[1];
  }),
      s = {},
      o = {}.propertyIsEnumerable,
      l = Object.getOwnPropertyDescriptor,
      h = l && !o.call({
    1: 2
  }, 1);

  s.f = h ? function (t) {
    var e = l(this, t);
    return !!e && e.enumerable;
  } : o;

  var c = function (t, e) {
    return {
      enumerable: !(1 & t),
      configurable: !(2 & t),
      writable: !(4 & t),
      value: e
    };
  },
      f = {}.toString,
      p = function (t) {
    return f.call(t).slice(8, -1);
  },
      d = "".split,
      v = i(function () {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function (t) {
    return "String" == p(t) ? d.call(t, "") : Object(t);
  } : Object,
      k = function (t) {
    if (null == t) throw TypeError("Can't call method on " + t);
    return t;
  },
      g = v,
      y = k,
      m = function (t) {
    return g(y(t));
  },
      _ = function (t) {
    return "object" == typeof t ? null !== t : "function" == typeof t;
  },
      A = _,
      b = function (t, e) {
    if (!A(t)) return t;
    var n, u;
    if (e && "function" == typeof (n = t.toString) && !A(u = n.call(t))) return u;
    if ("function" == typeof (n = t.valueOf) && !A(u = n.call(t))) return u;
    if (!e && "function" == typeof (n = t.toString) && !A(u = n.call(t))) return u;
    throw TypeError("Can't convert object to primitive value");
  },
      C = k,
      E = function (t) {
    return Object(C(t));
  },
      F = E,
      S = {}.hasOwnProperty,
      D = Object.hasOwn || function (t, e) {
    return S.call(F(t), e);
  },
      B = _,
      w = u.document,
      M = B(w) && B(w.createElement),
      x = function (t) {
    return M ? w.createElement(t) : {};
  },
      P = !a && !i(function () {
    return 7 != Object.defineProperty(x("div"), "a", {
      get: function () {
        return 7;
      }
    }).a;
  }),
      O = a,
      T = s,
      I = c,
      j = m,
      V = b,
      R = D,
      L = P,
      N = Object.getOwnPropertyDescriptor;

  r.f = O ? N : function (t, e) {
    if (t = j(t), e = V(e, !0), L) try {
      return N(t, e);
    } catch (t) {}
    if (R(t, e)) return I(!T.f.call(t, e), t[e]);
  };

  var U = {},
      z = _,
      H = function (t) {
    if (!z(t)) throw TypeError(String(t) + " is not an object");
    return t;
  },
      Y = a,
      Z = P,
      K = H,
      G = b,
      W = Object.defineProperty;

  U.f = Y ? W : function (t, e, n) {
    if (K(t), e = G(e, !0), K(n), Z) try {
      return W(t, e, n);
    } catch (t) {}
    if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
    return "value" in n && (t[e] = n.value), t;
  };

  var $ = U,
      q = c,
      X = a ? function (t, e, n) {
    return $.f(t, e, q(1, n));
  } : function (t, e, n) {
    return t[e] = n, t;
  },
      J = {
    exports: {}
  },
      Q = u,
      tt = X,
      et = function (t, e) {
    try {
      tt(Q, t, e);
    } catch (n) {
      Q[t] = e;
    }

    return e;
  },
      nt = et,
      ut = "__core-js_shared__",
      rt = u[ut] || nt(ut, {}),
      it = rt,
      at = Function.toString;

  "function" != typeof it.inspectSource && (it.inspectSource = function (t) {
    return at.call(t);
  });
  var st = it.inspectSource,
      ot = st,
      lt = u.WeakMap,
      ht = "function" == typeof lt && /native code/.test(ot(lt)),
      ct = {
    exports: {}
  },
      ft = rt;
  (ct.exports = function (t, e) {
    return ft[t] || (ft[t] = void 0 !== e ? e : {});
  })("versions", []).push({
    version: "3.15.2",
    mode: "global",
    copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
  });

  var pt,
      dt,
      vt,
      kt = 0,
      gt = Math.random(),
      yt = ct.exports,
      mt = function (t) {
    return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++kt + gt).toString(36);
  },
      _t = yt("keys"),
      At = {},
      bt = ht,
      Ct = _,
      Et = X,
      Ft = D,
      St = rt,
      Dt = function (t) {
    return _t[t] || (_t[t] = mt(t));
  },
      Bt = At,
      wt = "Object already initialized",
      Mt = u.WeakMap;

  if (bt || St.state) {
    var xt = St.state || (St.state = new Mt()),
        Pt = xt.get,
        Ot = xt.has,
        Tt = xt.set;
    pt = function (t, e) {
      if (Ot.call(xt, t)) throw new TypeError(wt);
      return e.facade = t, Tt.call(xt, t, e), e;
    }, dt = function (t) {
      return Pt.call(xt, t) || {};
    }, vt = function (t) {
      return Ot.call(xt, t);
    };
  } else {
    var It = Dt("state");
    Bt[It] = !0, pt = function (t, e) {
      if (Ft(t, It)) throw new TypeError(wt);
      return e.facade = t, Et(t, It, e), e;
    }, dt = function (t) {
      return Ft(t, It) ? t[It] : {};
    }, vt = function (t) {
      return Ft(t, It);
    };
  }

  var jt = {
    set: pt,
    get: dt,
    has: vt,
    enforce: function (t) {
      return vt(t) ? dt(t) : pt(t, {});
    },
    getterFor: function (t) {
      return function (e) {
        var n;
        if (!Ct(e) || (n = dt(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
        return n;
      };
    }
  },
      Vt = u,
      Rt = X,
      Lt = D,
      Nt = et,
      Ut = st,
      zt = jt.get,
      Ht = jt.enforce,
      Yt = String(String).split("String");
  (J.exports = function (t, e, n, u) {
    var r,
        i = !!u && !!u.unsafe,
        a = !!u && !!u.enumerable,
        s = !!u && !!u.noTargetGet;
    "function" == typeof n && ("string" != typeof e || Lt(n, "name") || Rt(n, "name", e), (r = Ht(n)).source || (r.source = Yt.join("string" == typeof e ? e : ""))), t !== Vt ? (i ? !s && t[e] && (a = !0) : delete t[e], a ? t[e] = n : Rt(t, e, n)) : a ? t[e] = n : Nt(e, n);
  })(Function.prototype, "toString", function () {
    return "function" == typeof this && zt(this).source || Ut(this);
  });

  var Zt = u,
      Kt = u,
      Gt = function (t) {
    return "function" == typeof t ? t : void 0;
  },
      Wt = function (t, e) {
    return arguments.length < 2 ? Gt(Zt[t]) || Gt(Kt[t]) : Zt[t] && Zt[t][e] || Kt[t] && Kt[t][e];
  },
      $t = {},
      qt = Math.ceil,
      Xt = Math.floor,
      Jt = function (t) {
    return isNaN(t = +t) ? 0 : (t > 0 ? Xt : qt)(t);
  },
      Qt = Jt,
      te = Math.min,
      ee = function (t) {
    return t > 0 ? te(Qt(t), 9007199254740991) : 0;
  },
      ne = Jt,
      ue = Math.max,
      re = Math.min,
      ie = m,
      ae = ee,
      se = function (t, e) {
    var n = ne(t);
    return n < 0 ? ue(n + e, 0) : re(n, e);
  },
      oe = function (t) {
    return function (e, n, u) {
      var r,
          i = ie(e),
          a = ae(i.length),
          s = se(u, a);

      if (t && n != n) {
        for (; a > s;) if ((r = i[s++]) != r) return !0;
      } else for (; a > s; s++) if ((t || s in i) && i[s] === n) return t || s || 0;

      return !t && -1;
    };
  },
      le = {
    includes: oe(!0),
    indexOf: oe(!1)
  },
      he = D,
      ce = m,
      fe = le.indexOf,
      pe = At,
      de = function (t, e) {
    var n,
        u = ce(t),
        r = 0,
        i = [];

    for (n in u) !he(pe, n) && he(u, n) && i.push(n);

    for (; e.length > r;) he(u, n = e[r++]) && (~fe(i, n) || i.push(n));

    return i;
  },
      ve = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
      ke = de,
      ge = ve.concat("length", "prototype");

  $t.f = Object.getOwnPropertyNames || function (t) {
    return ke(t, ge);
  };

  var ye = {};
  ye.f = Object.getOwnPropertySymbols;

  var me = $t,
      _e = ye,
      Ae = H,
      be = Wt("Reflect", "ownKeys") || function (t) {
    var e = me.f(Ae(t)),
        n = _e.f;
    return n ? e.concat(n(t)) : e;
  },
      Ce = D,
      Ee = be,
      Fe = r,
      Se = U,
      De = i,
      Be = /#|\.prototype\./,
      we = function (t, e) {
    var n = xe[Me(t)];
    return n == Oe || n != Pe && ("function" == typeof e ? De(e) : !!e);
  },
      Me = we.normalize = function (t) {
    return String(t).replace(Be, ".").toLowerCase();
  },
      xe = we.data = {},
      Pe = we.NATIVE = "N",
      Oe = we.POLYFILL = "P",
      Te = we,
      Ie = u,
      je = r.f,
      Ve = X,
      Re = J.exports,
      Le = et,
      Ne = function (t, e) {
    for (var n = Ee(e), u = Se.f, r = Fe.f, i = 0; i < n.length; i++) {
      var a = n[i];
      Ce(t, a) || u(t, a, r(e, a));
    }
  },
      Ue = Te,
      ze = function (t, e) {
    var n,
        u,
        r,
        i,
        a,
        s = t.target,
        o = t.global,
        l = t.stat;
    if (n = o ? Ie : l ? Ie[s] || Le(s, {}) : (Ie[s] || {}).prototype) for (u in e) {
      if (i = e[u], r = t.noTargetGet ? (a = je(n, u)) && a.value : n[u], !Ue(o ? u : s + (l ? "." : "#") + u, t.forced) && void 0 !== r) {
        if (typeof i == typeof r) continue;
        Ne(i, r);
      }

      (t.sham || r && r.sham) && Ve(i, "sham", !0), Re(n, u, i, t);
    }
  },
      He = de,
      Ye = ve,
      Ze = Object.keys || function (t) {
    return He(t, Ye);
  },
      Ke = a,
      Ge = i,
      We = Ze,
      $e = ye,
      qe = s,
      Xe = E,
      Je = v,
      Qe = Object.assign,
      tn = Object.defineProperty,
      en = !Qe || Ge(function () {
    if (Ke && 1 !== Qe({
      b: 1
    }, Qe(tn({}, "a", {
      enumerable: !0,
      get: function () {
        tn(this, "b", {
          value: 3,
          enumerable: !1
        });
      }
    }), {
      b: 2
    })).b) return !0;
    var t = {},
        e = {},
        n = Symbol(),
        u = "abcdefghijklmnopqrst";
    return t[n] = 7, u.split("").forEach(function (t) {
      e[t] = t;
    }), 7 != Qe({}, t)[n] || We(Qe({}, e)).join("") != u;
  }) ? function (t, e) {
    for (var n = Xe(t), u = arguments.length, r = 1, i = $e.f, a = qe.f; u > r;) for (var s, o = Je(arguments[r++]), l = i ? We(o).concat(i(o)) : We(o), h = l.length, c = 0; h > c;) s = l[c++], Ke && !a.call(o, s) || (n[s] = o[s]);

    return n;
  } : Qe;

  ze({
    target: "Object",
    stat: !0,
    forced: Object.assign !== en
  }, {
    assign: en
  });

  var nn = Jt,
      un = k,
      rn = function (t) {
    var e = String(un(this)),
        n = "",
        u = nn(t);
    if (u < 0 || u == 1 / 0) throw RangeError("Wrong number of repetitions");

    for (; u > 0; (u >>>= 1) && (e += e)) 1 & u && (n += e);

    return n;
  };

  ze({
    target: "String",
    proto: !0
  }, {
    repeat: rn
  });

  var an = ee,
      sn = rn,
      on = k,
      ln = Math.ceil,
      hn = function (t) {
    return function (e, n, u) {
      var r,
          i,
          a = String(on(e)),
          s = a.length,
          o = void 0 === u ? " " : String(u),
          l = an(n);
      return l <= s || "" == o ? a : (r = l - s, (i = sn.call(o, ln(r / o.length))).length > r && (i = i.slice(0, r)), t ? a + i : i + a);
    };
  },
      cn = {
    start: hn(!1),
    end: hn(!0)
  },
      fn = Wt("navigator", "userAgent") || "",
      pn = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(fn),
      dn = cn.start;

  ze({
    target: "String",
    proto: !0,
    forced: pn
  }, {
    padStart: function (t) {
      return dn(this, t, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  var vn = cn.end;

  function kn(t) {
    return (kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t;
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    })(t);
  }

  function gn(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }

  function yn(t, e) {
    for (var n = 0; n < e.length; n++) {
      var u = e[n];
      u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(t, u.key, u);
    }
  }

  function mn(t, e, n) {
    return e && yn(t.prototype, e), n && yn(t, n), t;
  }

  function _n(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), e && bn(t, e);
  }

  function An(t) {
    return (An = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    })(t);
  }

  function bn(t, e) {
    return (bn = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t;
    })(t, e);
  }

  function Cn(t, e) {
    if (null == t) return {};

    var n,
        u,
        r = function (t, e) {
      if (null == t) return {};
      var n,
          u,
          r = {},
          i = Object.keys(t);

      for (u = 0; u < i.length; u++) n = i[u], e.indexOf(n) >= 0 || (r[n] = t[n]);

      return r;
    }(t, e);

    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(t);

      for (u = 0; u < i.length; u++) n = i[u], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (r[n] = t[n]);
    }

    return r;
  }

  function En(t, e) {
    return !e || "object" != typeof e && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t;
    }(t) : e;
  }

  function Fn(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;

      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
      } catch (t) {
        return !1;
      }
    }();

    return function () {
      var n,
          u = An(t);

      if (e) {
        var r = An(this).constructor;
        n = Reflect.construct(u, arguments, r);
      } else n = u.apply(this, arguments);

      return En(this, n);
    };
  }

  function Sn(t, e) {
    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = An(t)););

    return t;
  }

  function Dn(t, e, n) {
    return (Dn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var u = Sn(t, e);

      if (u) {
        var r = Object.getOwnPropertyDescriptor(u, e);
        return r.get ? r.get.call(n) : r.value;
      }
    })(t, e, n || t);
  }

  function Bn(t, e, n, u) {
    return (Bn = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function (t, e, n, u) {
      var r,
          i = Sn(t, e);

      if (i) {
        if ((r = Object.getOwnPropertyDescriptor(i, e)).set) return r.set.call(u, n), !0;
        if (!r.writable) return !1;
      }

      if (r = Object.getOwnPropertyDescriptor(u, e)) {
        if (!r.writable) return !1;
        r.value = n, Object.defineProperty(u, e, r);
      } else !function (t, e, n) {
        e in t ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : t[e] = n;
      }(u, e, n);

      return !0;
    })(t, e, n, u);
  }

  function wn(t, e, n, u, r) {
    if (!Bn(t, e, n, u || t) && r) throw new Error("failed to set property");
    return n;
  }

  function Mn(t, e) {
    return function (t) {
      if (Array.isArray(t)) return t;
    }(t) || function (t, e) {
      var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
      if (null == n) return;
      var u,
          r,
          i = [],
          a = !0,
          s = !1;

      try {
        for (n = n.call(t); !(a = (u = n.next()).done) && (i.push(u.value), !e || i.length !== e); a = !0);
      } catch (t) {
        s = !0, r = t;
      } finally {
        try {
          a || null == n.return || n.return();
        } finally {
          if (s) throw r;
        }
      }

      return i;
    }(t, e) || function (t, e) {
      if (!t) return;
      if ("string" == typeof t) return xn(t, e);
      var n = Object.prototype.toString.call(t).slice(8, -1);
      "Object" === n && t.constructor && (n = t.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(t);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return xn(t, e);
    }(t, e) || function () {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }

  function xn(t, e) {
    (null == e || e > t.length) && (e = t.length);

    for (var n = 0, u = new Array(e); n < e; n++) u[n] = t[n];

    return u;
  }

  function Pn(t) {
    return "string" == typeof t || t instanceof String;
  }

  ze({
    target: "String",
    proto: !0,
    forced: pn
  }, {
    padEnd: function (t) {
      return vn(this, t, arguments.length > 1 ? arguments[1] : void 0);
    }
  }), ze({
    global: !0
  }, {
    globalThis: u
  });
  var On = "NONE",
      Tn = "LEFT",
      In = "FORCE_LEFT",
      jn = "RIGHT",
      Vn = "FORCE_RIGHT";

  function Rn(t) {
    switch (t) {
      case Tn:
        return In;

      case jn:
        return Vn;

      default:
        return t;
    }
  }

  function Ln(t) {
    return t.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  }

  function Nn(t, e) {
    if (e === t) return !0;
    var n,
        u = Array.isArray(e),
        r = Array.isArray(t);

    if (u && r) {
      if (e.length != t.length) return !1;

      for (n = 0; n < e.length; n++) if (!Nn(e[n], t[n])) return !1;

      return !0;
    }

    if (u != r) return !1;

    if (e && t && "object" === kn(e) && "object" === kn(t)) {
      var i = e instanceof Date,
          a = t instanceof Date;
      if (i && a) return e.getTime() == t.getTime();
      if (i != a) return !1;
      var s = e instanceof RegExp,
          o = t instanceof RegExp;
      if (s && o) return e.toString() == t.toString();
      if (s != o) return !1;
      var l = Object.keys(e);

      for (n = 0; n < l.length; n++) if (!Object.prototype.hasOwnProperty.call(t, l[n])) return !1;

      for (n = 0; n < l.length; n++) if (!Nn(t[l[n]], e[l[n]])) return !1;

      return !0;
    }

    return !(!e || !t || "function" != typeof e || "function" != typeof t) && e.toString() === t.toString();
  }

  var Un = function () {
    function t(e, n, u, r) {
      for (gn(this, t), this.value = e, this.cursorPos = n, this.oldValue = u, this.oldSelection = r; this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos);) --this.oldSelection.start;
    }

    return mn(t, [{
      key: "startChangePos",
      get: function () {
        return Math.min(this.cursorPos, this.oldSelection.start);
      }
    }, {
      key: "insertedCount",
      get: function () {
        return this.cursorPos - this.startChangePos;
      }
    }, {
      key: "inserted",
      get: function () {
        return this.value.substr(this.startChangePos, this.insertedCount);
      }
    }, {
      key: "removedCount",
      get: function () {
        return Math.max(this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length, 0);
      }
    }, {
      key: "removed",
      get: function () {
        return this.oldValue.substr(this.startChangePos, this.removedCount);
      }
    }, {
      key: "head",
      get: function () {
        return this.value.substring(0, this.startChangePos);
      }
    }, {
      key: "tail",
      get: function () {
        return this.value.substring(this.startChangePos + this.insertedCount);
      }
    }, {
      key: "removeDirection",
      get: function () {
        return !this.removedCount || this.insertedCount ? On : this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos ? jn : Tn;
      }
    }]), t;
  }(),
      zn = function () {
    function t(e) {
      gn(this, t), Object.assign(this, {
        inserted: "",
        rawInserted: "",
        skip: !1,
        tailShift: 0
      }, e);
    }

    return mn(t, [{
      key: "aggregate",
      value: function (t) {
        return this.rawInserted += t.rawInserted, this.skip = this.skip || t.skip, this.inserted += t.inserted, this.tailShift += t.tailShift, this;
      }
    }, {
      key: "offset",
      get: function () {
        return this.tailShift + this.inserted.length;
      }
    }]), t;
  }(),
      Hn = function () {
    function t() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
          n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
          u = arguments.length > 2 ? arguments[2] : void 0;
      gn(this, t), this.value = e, this.from = n, this.stop = u;
    }

    return mn(t, [{
      key: "toString",
      value: function () {
        return this.value;
      }
    }, {
      key: "extend",
      value: function (t) {
        this.value += String(t);
      }
    }, {
      key: "appendTo",
      value: function (t) {
        return t.append(this.toString(), {
          tail: !0
        }).aggregate(t._appendPlaceholder());
      }
    }, {
      key: "state",
      get: function () {
        return {
          value: this.value,
          from: this.from,
          stop: this.stop
        };
      },
      set: function (t) {
        Object.assign(this, t);
      }
    }, {
      key: "shiftBefore",
      value: function (t) {
        if (this.from >= t || !this.value.length) return "";
        var e = this.value[0];
        return this.value = this.value.slice(1), e;
      }
    }]), t;
  }();

  function Yn(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return new Yn.InputMask(t, e);
  }

  var Zn = function () {
    function t(e) {
      gn(this, t), this._value = "", this._update(Object.assign({}, t.DEFAULTS, e)), this.isInitialized = !0;
    }

    return mn(t, [{
      key: "updateOptions",
      value: function (t) {
        Object.keys(t).length && this.withValueRefresh(this._update.bind(this, t));
      }
    }, {
      key: "_update",
      value: function (t) {
        Object.assign(this, t);
      }
    }, {
      key: "state",
      get: function () {
        return {
          _value: this.value
        };
      },
      set: function (t) {
        this._value = t._value;
      }
    }, {
      key: "reset",
      value: function () {
        this._value = "";
      }
    }, {
      key: "value",
      get: function () {
        return this._value;
      },
      set: function (t) {
        this.resolve(t);
      }
    }, {
      key: "resolve",
      value: function (t) {
        return this.reset(), this.append(t, {
          input: !0
        }, ""), this.doCommit(), this.value;
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this.value;
      },
      set: function (t) {
        this.reset(), this.append(t, {}, ""), this.doCommit();
      }
    }, {
      key: "typedValue",
      get: function () {
        return this.doParse(this.value);
      },
      set: function (t) {
        this.value = this.doFormat(t);
      }
    }, {
      key: "rawInputValue",
      get: function () {
        return this.extractInput(0, this.value.length, {
          raw: !0
        });
      },
      set: function (t) {
        this.reset(), this.append(t, {
          raw: !0
        }, ""), this.doCommit();
      }
    }, {
      key: "isComplete",
      get: function () {
        return !0;
      }
    }, {
      key: "nearestInputPos",
      value: function (t, e) {
        return t;
      }
    }, {
      key: "extractInput",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
        return this.value.slice(t, e);
      }
    }, {
      key: "extractTail",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
        return new Hn(this.extractInput(t, e), t);
      }
    }, {
      key: "appendTail",
      value: function (t) {
        return Pn(t) && (t = new Hn(String(t))), t.appendTo(this);
      }
    }, {
      key: "_appendCharRaw",
      value: function (t) {
        return t ? (this._value += t, new zn({
          inserted: t,
          rawInserted: t
        })) : new zn();
      }
    }, {
      key: "_appendChar",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = arguments.length > 2 ? arguments[2] : void 0,
            u = this.state,
            r = this._appendCharRaw(this.doPrepare(t, e), e);

        if (r.inserted) {
          var i,
              a = !1 !== this.doValidate(e);

          if (a && null != n) {
            var s = this.state;
            this.overwrite && (i = n.state, n.shiftBefore(this.value.length));
            var o = this.appendTail(n);
            (a = o.rawInserted === n.toString()) && o.inserted && (this.state = s);
          }

          a || (r = new zn(), this.state = u, n && i && (n.state = i));
        }

        return r;
      }
    }, {
      key: "_appendPlaceholder",
      value: function () {
        return new zn();
      }
    }, {
      key: "append",
      value: function (t, e, n) {
        if (!Pn(t)) throw new Error("value should be string");
        var u = new zn(),
            r = Pn(n) ? new Hn(String(n)) : n;
        e && e.tail && (e._beforeTailState = this.state);

        for (var i = 0; i < t.length; ++i) u.aggregate(this._appendChar(t[i], e, r));

        return null != r && (u.tailShift += this.appendTail(r).tailShift), u;
      }
    }, {
      key: "remove",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
        return this._value = this.value.slice(0, t) + this.value.slice(e), new zn();
      }
    }, {
      key: "withValueRefresh",
      value: function (t) {
        if (this._refreshing || !this.isInitialized) return t();
        this._refreshing = !0;
        var e = this.rawInputValue,
            n = this.value,
            u = t();
        return this.rawInputValue = e, this.value && this.value !== n && 0 === n.indexOf(this.value) && this.append(n.slice(this.value.length), {}, ""), delete this._refreshing, u;
      }
    }, {
      key: "runIsolated",
      value: function (t) {
        if (this._isolated || !this.isInitialized) return t(this);
        this._isolated = !0;
        var e = this.state,
            n = t(this);
        return this.state = e, delete this._isolated, n;
      }
    }, {
      key: "doPrepare",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return this.prepare ? this.prepare(t, this, e) : t;
      }
    }, {
      key: "doValidate",
      value: function (t) {
        return (!this.validate || this.validate(this.value, this, t)) && (!this.parent || this.parent.doValidate(t));
      }
    }, {
      key: "doCommit",
      value: function () {
        this.commit && this.commit(this.value, this);
      }
    }, {
      key: "doFormat",
      value: function (t) {
        return this.format ? this.format(t, this) : t;
      }
    }, {
      key: "doParse",
      value: function (t) {
        return this.parse ? this.parse(t, this) : t;
      }
    }, {
      key: "splice",
      value: function (t, e, n, u) {
        var r = t + e,
            i = this.extractTail(r),
            a = this.nearestInputPos(t, u);
        return new zn({
          tailShift: a - t
        }).aggregate(this.remove(a)).aggregate(this.append(n, {
          input: !0
        }, i));
      }
    }]), t;
  }();

  function Kn(t) {
    if (null == t) throw new Error("mask property should be defined");
    return t instanceof RegExp ? Yn.MaskedRegExp : Pn(t) ? Yn.MaskedPattern : t instanceof Date || t === Date ? Yn.MaskedDate : t instanceof Number || "number" == typeof t || t === Number ? Yn.MaskedNumber : Array.isArray(t) || t === Array ? Yn.MaskedDynamic : Yn.Masked && t.prototype instanceof Yn.Masked ? t : t instanceof Function ? Yn.MaskedFunction : t instanceof Yn.Masked ? t.constructor : (console.warn("Mask not found for mask", t), Yn.Masked);
  }

  function Gn(t) {
    if (Yn.Masked && t instanceof Yn.Masked) return t;
    var e = (t = Object.assign({}, t)).mask;
    if (Yn.Masked && e instanceof Yn.Masked) return e;
    var n = Kn(e);
    if (!n) throw new Error("Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask.");
    return new n(t);
  }

  Zn.DEFAULTS = {
    format: function (t) {
      return t;
    },
    parse: function (t) {
      return t;
    }
  }, Yn.Masked = Zn, Yn.createMask = Gn;

  var Wn = ["mask"],
      $n = {
    0: /\d/,
    a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    "*": /./
  },
      qn = function () {
    function t(e) {
      gn(this, t);
      var n = e.mask,
          u = Cn(e, Wn);
      this.masked = Gn({
        mask: n
      }), Object.assign(this, u);
    }

    return mn(t, [{
      key: "reset",
      value: function () {
        this._isFilled = !1, this.masked.reset();
      }
    }, {
      key: "remove",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
        return 0 === t && e >= 1 ? (this._isFilled = !1, this.masked.remove(t, e)) : new zn();
      }
    }, {
      key: "value",
      get: function () {
        return this.masked.value || (this._isFilled && !this.isOptional ? this.placeholderChar : "");
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this.masked.unmaskedValue;
      }
    }, {
      key: "isComplete",
      get: function () {
        return Boolean(this.masked.value) || this.isOptional;
      }
    }, {
      key: "_appendChar",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (this._isFilled) return new zn();

        var n = this.masked.state,
            u = this.masked._appendChar(t, e);

        return u.inserted && !1 === this.doValidate(e) && (u.inserted = u.rawInserted = "", this.masked.state = n), u.inserted || this.isOptional || this.lazy || e.input || (u.inserted = this.placeholderChar), u.skip = !u.inserted && !this.isOptional, this._isFilled = Boolean(u.inserted), u;
      }
    }, {
      key: "append",
      value: function () {
        var t;
        return (t = this.masked).append.apply(t, arguments);
      }
    }, {
      key: "_appendPlaceholder",
      value: function () {
        var t = new zn();
        return this._isFilled || this.isOptional || (this._isFilled = !0, t.inserted = this.placeholderChar), t;
      }
    }, {
      key: "extractTail",
      value: function () {
        var t;
        return (t = this.masked).extractTail.apply(t, arguments);
      }
    }, {
      key: "appendTail",
      value: function () {
        var t;
        return (t = this.masked).appendTail.apply(t, arguments);
      }
    }, {
      key: "extractInput",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            n = arguments.length > 2 ? arguments[2] : void 0;
        return this.masked.extractInput(t, e, n);
      }
    }, {
      key: "nearestInputPos",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : On,
            n = 0,
            u = this.value.length,
            r = Math.min(Math.max(t, n), u);

        switch (e) {
          case Tn:
          case In:
            return this.isComplete ? r : n;

          case jn:
          case Vn:
            return this.isComplete ? r : u;

          case On:
          default:
            return r;
        }
      }
    }, {
      key: "doValidate",
      value: function () {
        var t, e;
        return (t = this.masked).doValidate.apply(t, arguments) && (!this.parent || (e = this.parent).doValidate.apply(e, arguments));
      }
    }, {
      key: "doCommit",
      value: function () {
        this.masked.doCommit();
      }
    }, {
      key: "state",
      get: function () {
        return {
          masked: this.masked.state,
          _isFilled: this._isFilled
        };
      },
      set: function (t) {
        this.masked.state = t.masked, this._isFilled = t._isFilled;
      }
    }]), t;
  }(),
      Xn = function () {
    function t(e) {
      gn(this, t), Object.assign(this, e), this._value = "";
    }

    return mn(t, [{
      key: "value",
      get: function () {
        return this._value;
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this.isUnmasking ? this.value : "";
      }
    }, {
      key: "reset",
      value: function () {
        this._isRawInput = !1, this._value = "";
      }
    }, {
      key: "remove",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._value.length;
        return this._value = this._value.slice(0, t) + this._value.slice(e), this._value || (this._isRawInput = !1), new zn();
      }
    }, {
      key: "nearestInputPos",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : On,
            n = 0,
            u = this._value.length;

        switch (e) {
          case Tn:
          case In:
            return n;

          case On:
          case jn:
          case Vn:
          default:
            return u;
        }
      }
    }, {
      key: "extractInput",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._value.length,
            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return n.raw && this._isRawInput && this._value.slice(t, e) || "";
      }
    }, {
      key: "isComplete",
      get: function () {
        return !0;
      }
    }, {
      key: "_appendChar",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = new zn();
        if (this._value) return n;
        var u = this.char === t[0],
            r = u && (this.isUnmasking || e.input || e.raw) && !e.tail;
        return r && (n.rawInserted = this.char), this._value = n.inserted = this.char, this._isRawInput = r && (e.raw || e.input), n;
      }
    }, {
      key: "_appendPlaceholder",
      value: function () {
        var t = new zn();
        return this._value || (this._value = t.inserted = this.char), t;
      }
    }, {
      key: "extractTail",
      value: function () {
        return arguments.length > 1 && void 0 !== arguments[1] || this.value.length, new Hn("");
      }
    }, {
      key: "appendTail",
      value: function (t) {
        return Pn(t) && (t = new Hn(String(t))), t.appendTo(this);
      }
    }, {
      key: "append",
      value: function (t, e, n) {
        var u = this._appendChar(t, e);

        return null != n && (u.tailShift += this.appendTail(n).tailShift), u;
      }
    }, {
      key: "doCommit",
      value: function () {}
    }, {
      key: "state",
      get: function () {
        return {
          _value: this._value,
          _isRawInput: this._isRawInput
        };
      },
      set: function (t) {
        Object.assign(this, t);
      }
    }]), t;
  }(),
      Jn = ["chunks"],
      Qn = function () {
    function t() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
          n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      gn(this, t), this.chunks = e, this.from = n;
    }

    return mn(t, [{
      key: "toString",
      value: function () {
        return this.chunks.map(String).join("");
      }
    }, {
      key: "extend",
      value: function (e) {
        if (String(e)) {
          Pn(e) && (e = new Hn(String(e)));
          var n = this.chunks[this.chunks.length - 1],
              u = n && (n.stop === e.stop || null == e.stop) && e.from === n.from + n.toString().length;
          if (e instanceof Hn) u ? n.extend(e.toString()) : this.chunks.push(e);else if (e instanceof t) {
            if (null == e.stop) for (var r; e.chunks.length && null == e.chunks[0].stop;) (r = e.chunks.shift()).from += e.from, this.extend(r);
            e.toString() && (e.stop = e.blockIndex, this.chunks.push(e));
          }
        }
      }
    }, {
      key: "appendTo",
      value: function (e) {
        if (!(e instanceof Yn.MaskedPattern)) return new Hn(this.toString()).appendTo(e);

        for (var n = new zn(), u = 0; u < this.chunks.length && !n.skip; ++u) {
          var r = this.chunks[u],
              i = e._mapPosToBlock(e.value.length),
              a = r.stop,
              s = void 0;

          if (null != a && (!i || i.index <= a) && ((r instanceof t || e._stops.indexOf(a) >= 0) && n.aggregate(e._appendPlaceholder(a)), s = r instanceof t && e._blocks[a]), s) {
            var o = s.appendTail(r);
            o.skip = !1, n.aggregate(o), e._value += o.inserted;
            var l = r.toString().slice(o.rawInserted.length);
            l && n.aggregate(e.append(l, {
              tail: !0
            }));
          } else n.aggregate(e.append(r.toString(), {
            tail: !0
          }));
        }

        return n;
      }
    }, {
      key: "state",
      get: function () {
        return {
          chunks: this.chunks.map(function (t) {
            return t.state;
          }),
          from: this.from,
          stop: this.stop,
          blockIndex: this.blockIndex
        };
      },
      set: function (e) {
        var n = e.chunks,
            u = Cn(e, Jn);
        Object.assign(this, u), this.chunks = n.map(function (e) {
          var n = "chunks" in e ? new t() : new Hn();
          return n.state = e, n;
        });
      }
    }, {
      key: "shiftBefore",
      value: function (t) {
        if (this.from >= t || !this.chunks.length) return "";

        for (var e = t - this.from, n = 0; n < this.chunks.length;) {
          var u = this.chunks[n],
              r = u.shiftBefore(e);

          if (u.toString()) {
            if (!r) break;
            ++n;
          } else this.chunks.splice(n, 1);

          if (r) return r;
        }

        return "";
      }
    }]), t;
  }(),
      tu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      return gn(this, n), e.apply(this, arguments);
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        t.mask && (t.validate = function (e) {
          return e.search(t.mask) >= 0;
        }), Dn(An(n.prototype), "_update", this).call(this, t);
      }
    }]), n;
  }(Zn);

  Yn.MaskedRegExp = tu;

  var eu = ["_blocks"],
      nu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return gn(this, n), t.definitions = Object.assign({}, $n, t.definitions), e.call(this, Object.assign({}, n.DEFAULTS, t));
    }

    return mn(n, [{
      key: "_update",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        t.definitions = Object.assign({}, this.definitions, t.definitions), Dn(An(n.prototype), "_update", this).call(this, t), this._rebuildMask();
      }
    }, {
      key: "_rebuildMask",
      value: function () {
        var t = this,
            e = this.definitions;
        this._blocks = [], this._stops = [], this._maskedBlocks = {};
        var u = this.mask;
        if (u && e) for (var r = !1, i = !1, a = 0; a < u.length; ++a) {
          if (this.blocks) if ("continue" === function () {
            var e = u.slice(a),
                n = Object.keys(t.blocks).filter(function (t) {
              return 0 === e.indexOf(t);
            });
            n.sort(function (t, e) {
              return e.length - t.length;
            });
            var r = n[0];

            if (r) {
              var i = Gn(Object.assign({
                parent: t,
                lazy: t.lazy,
                placeholderChar: t.placeholderChar,
                overwrite: t.overwrite
              }, t.blocks[r]));
              return i && (t._blocks.push(i), t._maskedBlocks[r] || (t._maskedBlocks[r] = []), t._maskedBlocks[r].push(t._blocks.length - 1)), a += r.length - 1, "continue";
            }
          }()) continue;
          var s = u[a],
              o = (s in e);
          if (s !== n.STOP_CHAR) {
            if ("{" !== s && "}" !== s) {
              if ("[" !== s && "]" !== s) {
                if (s === n.ESCAPE_CHAR) {
                  if (++a, !(s = u[a])) break;
                  o = !1;
                }

                var l = o ? new qn({
                  parent: this,
                  lazy: this.lazy,
                  placeholderChar: this.placeholderChar,
                  mask: e[s],
                  isOptional: i
                }) : new Xn({
                  char: s,
                  isUnmasking: r
                });

                this._blocks.push(l);
              } else i = !i;
            } else r = !r;
          } else this._stops.push(this._blocks.length);
        }
      }
    }, {
      key: "state",
      get: function () {
        return Object.assign({}, Dn(An(n.prototype), "state", this), {
          _blocks: this._blocks.map(function (t) {
            return t.state;
          })
        });
      },
      set: function (t) {
        var e = t._blocks,
            u = Cn(t, eu);
        this._blocks.forEach(function (t, n) {
          return t.state = e[n];
        }), wn(An(n.prototype), "state", u, this, !0);
      }
    }, {
      key: "reset",
      value: function () {
        Dn(An(n.prototype), "reset", this).call(this), this._blocks.forEach(function (t) {
          return t.reset();
        });
      }
    }, {
      key: "isComplete",
      get: function () {
        return this._blocks.every(function (t) {
          return t.isComplete;
        });
      }
    }, {
      key: "doCommit",
      value: function () {
        this._blocks.forEach(function (t) {
          return t.doCommit();
        }), Dn(An(n.prototype), "doCommit", this).call(this);
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this._blocks.reduce(function (t, e) {
          return t + e.unmaskedValue;
        }, "");
      },
      set: function (t) {
        wn(An(n.prototype), "unmaskedValue", t, this, !0);
      }
    }, {
      key: "value",
      get: function () {
        return this._blocks.reduce(function (t, e) {
          return t + e.value;
        }, "");
      },
      set: function (t) {
        wn(An(n.prototype), "value", t, this, !0);
      }
    }, {
      key: "appendTail",
      value: function (t) {
        return Dn(An(n.prototype), "appendTail", this).call(this, t).aggregate(this._appendPlaceholder());
      }
    }, {
      key: "_appendCharRaw",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = this._mapPosToBlock(this.value.length),
            u = new zn();

        if (!n) return u;

        for (var r = n.index;; ++r) {
          var i = this._blocks[r];
          if (!i) break;

          var a = i._appendChar(t, e),
              s = a.skip;

          if (u.aggregate(a), s || a.rawInserted) break;
        }

        return u;
      }
    }, {
      key: "extractTail",
      value: function () {
        var t = this,
            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            u = new Qn();
        return e === n || this._forEachBlocksInRange(e, n, function (e, n, r, i) {
          var a = e.extractTail(r, i);
          a.stop = t._findStopBefore(n), a.from = t._blockStartPos(n), a instanceof Qn && (a.blockIndex = n), u.extend(a);
        }), u;
      }
    }, {
      key: "extractInput",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (t === e) return "";
        var u = "";
        return this._forEachBlocksInRange(t, e, function (t, e, r, i) {
          u += t.extractInput(r, i, n);
        }), u;
      }
    }, {
      key: "_findStopBefore",
      value: function (t) {
        for (var e, n = 0; n < this._stops.length; ++n) {
          var u = this._stops[n];
          if (!(u <= t)) break;
          e = u;
        }

        return e;
      }
    }, {
      key: "_appendPlaceholder",
      value: function (t) {
        var e = this,
            n = new zn();
        if (this.lazy && null == t) return n;

        var u = this._mapPosToBlock(this.value.length);

        if (!u) return n;
        var r = u.index,
            i = null != t ? t : this._blocks.length;
        return this._blocks.slice(r, i).forEach(function (u) {
          if (!u.lazy || null != t) {
            var r = null != u._blocks ? [u._blocks.length] : [],
                i = u._appendPlaceholder.apply(u, r);

            e._value += i.inserted, n.aggregate(i);
          }
        }), n;
      }
    }, {
      key: "_mapPosToBlock",
      value: function (t) {
        for (var e = "", n = 0; n < this._blocks.length; ++n) {
          var u = this._blocks[n],
              r = e.length;
          if (t <= (e += u.value).length) return {
            index: n,
            offset: t - r
          };
        }
      }
    }, {
      key: "_blockStartPos",
      value: function (t) {
        return this._blocks.slice(0, t).reduce(function (t, e) {
          return t + e.value.length;
        }, 0);
      }
    }, {
      key: "_forEachBlocksInRange",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            n = arguments.length > 2 ? arguments[2] : void 0,
            u = this._mapPosToBlock(t);

        if (u) {
          var r = this._mapPosToBlock(e),
              i = r && u.index === r.index,
              a = u.offset,
              s = r && i ? r.offset : this._blocks[u.index].value.length;

          if (n(this._blocks[u.index], u.index, a, s), r && !i) {
            for (var o = u.index + 1; o < r.index; ++o) n(this._blocks[o], o, 0, this._blocks[o].value.length);

            n(this._blocks[r.index], r.index, 0, r.offset);
          }
        }
      }
    }, {
      key: "remove",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            u = Dn(An(n.prototype), "remove", this).call(this, t, e);
        return this._forEachBlocksInRange(t, e, function (t, e, n, r) {
          u.aggregate(t.remove(n, r));
        }), u;
      }
    }, {
      key: "nearestInputPos",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : On,
            n = this._mapPosToBlock(t) || {
          index: 0,
          offset: 0
        },
            u = n.offset,
            r = n.index,
            i = this._blocks[r];
        if (!i) return t;
        var a = u;
        0 !== a && a < i.value.length && (a = i.nearestInputPos(u, Rn(e)));
        var s = a === i.value.length,
            o = 0 === a;
        if (!o && !s) return this._blockStartPos(r) + a;
        var l = s ? r + 1 : r;

        if (e === On) {
          if (l > 0) {
            var h = l - 1,
                c = this._blocks[h],
                f = c.nearestInputPos(0, On);
            if (!c.value.length || f !== c.value.length) return this._blockStartPos(l);
          }

          for (var p = l, d = p; d < this._blocks.length; ++d) {
            var v = this._blocks[d],
                k = v.nearestInputPos(0, On);
            if (!v.value.length || k !== v.value.length) return this._blockStartPos(d) + k;
          }

          for (var g = l - 1; g >= 0; --g) {
            var y = this._blocks[g],
                m = y.nearestInputPos(0, On);
            if (!y.value.length || m !== y.value.length) return this._blockStartPos(g) + y.value.length;
          }

          return t;
        }

        if (e === Tn || e === In) {
          for (var _, A = l; A < this._blocks.length; ++A) if (this._blocks[A].value) {
            _ = A;
            break;
          }

          if (null != _) {
            var b = this._blocks[_],
                C = b.nearestInputPos(0, jn);
            if (0 === C && b.unmaskedValue.length) return this._blockStartPos(_) + C;
          }

          for (var E, F = -1, S = l - 1; S >= 0; --S) {
            var D = this._blocks[S],
                B = D.nearestInputPos(D.value.length, In);

            if (D.value && 0 === B || (E = S), 0 !== B) {
              if (B !== D.value.length) return this._blockStartPos(S) + B;
              F = S;
              break;
            }
          }

          if (e === Tn) for (var w = F + 1; w <= Math.min(l, this._blocks.length - 1); ++w) {
            var M = this._blocks[w],
                x = M.nearestInputPos(0, On),
                P = this._blockStartPos(w) + x;
            if (P > t) break;
            if (x !== M.value.length) return P;
          }
          if (F >= 0) return this._blockStartPos(F) + this._blocks[F].value.length;
          if (e === In || this.lazy && !this.extractInput() && !uu(this._blocks[l])) return 0;
          if (null != E) return this._blockStartPos(E);

          for (var O = l; O < this._blocks.length; ++O) {
            var T = this._blocks[O],
                I = T.nearestInputPos(0, On);
            if (!T.value.length || I !== T.value.length) return this._blockStartPos(O) + I;
          }

          return 0;
        }

        if (e === jn || e === Vn) {
          for (var j, V, R = l; R < this._blocks.length; ++R) {
            var L = this._blocks[R],
                N = L.nearestInputPos(0, On);

            if (N !== L.value.length) {
              V = this._blockStartPos(R) + N, j = R;
              break;
            }
          }

          if (null != j && null != V) {
            for (var U = j; U < this._blocks.length; ++U) {
              var z = this._blocks[U],
                  H = z.nearestInputPos(0, Vn);
              if (H !== z.value.length) return this._blockStartPos(U) + H;
            }

            return e === Vn ? this.value.length : V;
          }

          for (var Y = Math.min(l, this._blocks.length - 1); Y >= 0; --Y) {
            var Z = this._blocks[Y],
                K = Z.nearestInputPos(Z.value.length, Tn);

            if (0 !== K) {
              var G = this._blockStartPos(Y) + K;
              if (G >= t) return G;
              break;
            }
          }
        }

        return t;
      }
    }, {
      key: "maskedBlock",
      value: function (t) {
        return this.maskedBlocks(t)[0];
      }
    }, {
      key: "maskedBlocks",
      value: function (t) {
        var e = this,
            n = this._maskedBlocks[t];
        return n ? n.map(function (t) {
          return e._blocks[t];
        }) : [];
      }
    }]), n;
  }(Zn);

  function uu(t) {
    if (!t) return !1;
    var e = t.value;
    return !e || t.nearestInputPos(0, On) !== e.length;
  }

  nu.DEFAULTS = {
    lazy: !0,
    placeholderChar: "_"
  }, nu.STOP_CHAR = "`", nu.ESCAPE_CHAR = "\\", nu.InputDefinition = qn, nu.FixedDefinition = Xn, Yn.MaskedPattern = nu;

  var ru = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      return gn(this, n), e.apply(this, arguments);
    }

    return mn(n, [{
      key: "_matchFrom",
      get: function () {
        return this.maxLength - String(this.from).length;
      }
    }, {
      key: "_update",
      value: function (t) {
        t = Object.assign({
          to: this.to || 0,
          from: this.from || 0
        }, t);
        var e = String(t.to).length;
        null != t.maxLength && (e = Math.max(e, t.maxLength)), t.maxLength = e;

        for (var u = String(t.from).padStart(e, "0"), r = String(t.to).padStart(e, "0"), i = 0; i < r.length && r[i] === u[i];) ++i;

        t.mask = r.slice(0, i).replace(/0/g, "\\0") + "0".repeat(e - i), Dn(An(n.prototype), "_update", this).call(this, t);
      }
    }, {
      key: "isComplete",
      get: function () {
        return Dn(An(n.prototype), "isComplete", this) && Boolean(this.value);
      }
    }, {
      key: "boundaries",
      value: function (t) {
        var e = "",
            n = "",
            u = Mn(t.match(/^(\D*)(\d*)(\D*)/) || [], 3),
            r = u[1],
            i = u[2];
        return i && (e = "0".repeat(r.length) + i, n = "9".repeat(r.length) + i), [e = e.padEnd(this.maxLength, "0"), n = n.padEnd(this.maxLength, "9")];
      }
    }, {
      key: "doPrepare",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (t = Dn(An(n.prototype), "doPrepare", this).call(this, t, e).replace(/\D/g, ""), !this.autofix) return t;

        for (var u = String(this.from).padStart(this.maxLength, "0"), r = String(this.to).padStart(this.maxLength, "0"), i = this.value, a = "", s = 0; s < t.length; ++s) {
          var o = i + a + t[s],
              l = this.boundaries(o),
              h = Mn(l, 2),
              c = h[0],
              f = h[1];
          Number(f) < this.from ? a += u[o.length - 1] : Number(c) > this.to ? a += r[o.length - 1] : a += t[s];
        }

        return a;
      }
    }, {
      key: "doValidate",
      value: function () {
        var t,
            e = this.value,
            u = e.search(/[^0]/);
        if (-1 === u && e.length <= this._matchFrom) return !0;

        for (var r = this.boundaries(e), i = Mn(r, 2), a = i[0], s = i[1], o = arguments.length, l = new Array(o), h = 0; h < o; h++) l[h] = arguments[h];

        return this.from <= Number(s) && Number(a) <= this.to && (t = Dn(An(n.prototype), "doValidate", this)).call.apply(t, [this].concat(l));
      }
    }]), n;
  }(nu);

  Yn.MaskedRange = ru;

  var iu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n(t) {
      return gn(this, n), e.call(this, Object.assign({}, n.DEFAULTS, t));
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        t.mask === Date && delete t.mask, t.pattern && (t.mask = t.pattern);
        var e = t.blocks;
        t.blocks = Object.assign({}, n.GET_DEFAULT_BLOCKS()), t.min && (t.blocks.Y.from = t.min.getFullYear()), t.max && (t.blocks.Y.to = t.max.getFullYear()), t.min && t.max && t.blocks.Y.from === t.blocks.Y.to && (t.blocks.m.from = t.min.getMonth() + 1, t.blocks.m.to = t.max.getMonth() + 1, t.blocks.m.from === t.blocks.m.to && (t.blocks.d.from = t.min.getDate(), t.blocks.d.to = t.max.getDate())), Object.assign(t.blocks, e), Object.keys(t.blocks).forEach(function (e) {
          var n = t.blocks[e];
          "autofix" in n || (n.autofix = t.autofix);
        }), Dn(An(n.prototype), "_update", this).call(this, t);
      }
    }, {
      key: "doValidate",
      value: function () {
        for (var t, e = this.date, u = arguments.length, r = new Array(u), i = 0; i < u; i++) r[i] = arguments[i];

        return (t = Dn(An(n.prototype), "doValidate", this)).call.apply(t, [this].concat(r)) && (!this.isComplete || this.isDateExist(this.value) && null != e && (null == this.min || this.min <= e) && (null == this.max || e <= this.max));
      }
    }, {
      key: "isDateExist",
      value: function (t) {
        return this.format(this.parse(t, this), this).indexOf(t) >= 0;
      }
    }, {
      key: "date",
      get: function () {
        return this.typedValue;
      },
      set: function (t) {
        this.typedValue = t;
      }
    }, {
      key: "typedValue",
      get: function () {
        return this.isComplete ? Dn(An(n.prototype), "typedValue", this) : null;
      },
      set: function (t) {
        wn(An(n.prototype), "typedValue", t, this, !0);
      }
    }]), n;
  }(nu);

  iu.DEFAULTS = {
    pattern: "d{.}`m{.}`Y",
    format: function (t) {
      return [String(t.getDate()).padStart(2, "0"), String(t.getMonth() + 1).padStart(2, "0"), t.getFullYear()].join(".");
    },
    parse: function (t) {
      var e = Mn(t.split("."), 3),
          n = e[0],
          u = e[1],
          r = e[2];
      return new Date(r, u - 1, n);
    }
  }, iu.GET_DEFAULT_BLOCKS = function () {
    return {
      d: {
        mask: ru,
        from: 1,
        to: 31,
        maxLength: 2
      },
      m: {
        mask: ru,
        from: 1,
        to: 12,
        maxLength: 2
      },
      Y: {
        mask: ru,
        from: 1900,
        to: 9999
      }
    };
  }, Yn.MaskedDate = iu;

  var au = function () {
    function t() {
      gn(this, t);
    }

    return mn(t, [{
      key: "selectionStart",
      get: function () {
        var t;

        try {
          t = this._unsafeSelectionStart;
        } catch (t) {}

        return null != t ? t : this.value.length;
      }
    }, {
      key: "selectionEnd",
      get: function () {
        var t;

        try {
          t = this._unsafeSelectionEnd;
        } catch (t) {}

        return null != t ? t : this.value.length;
      }
    }, {
      key: "select",
      value: function (t, e) {
        if (null != t && null != e && (t !== this.selectionStart || e !== this.selectionEnd)) try {
          this._unsafeSelect(t, e);
        } catch (t) {}
      }
    }, {
      key: "_unsafeSelect",
      value: function (t, e) {}
    }, {
      key: "isActive",
      get: function () {
        return !1;
      }
    }, {
      key: "bindEvents",
      value: function (t) {}
    }, {
      key: "unbindEvents",
      value: function () {}
    }]), t;
  }();

  Yn.MaskElement = au;

  var su = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n(t) {
      var u;
      return gn(this, n), (u = e.call(this)).input = t, u._handlers = {}, u;
    }

    return mn(n, [{
      key: "rootElement",
      get: function () {
        return this.input.getRootNode ? this.input.getRootNode() : document;
      }
    }, {
      key: "isActive",
      get: function () {
        return this.input === this.rootElement.activeElement;
      }
    }, {
      key: "_unsafeSelectionStart",
      get: function () {
        return this.input.selectionStart;
      }
    }, {
      key: "_unsafeSelectionEnd",
      get: function () {
        return this.input.selectionEnd;
      }
    }, {
      key: "_unsafeSelect",
      value: function (t, e) {
        this.input.setSelectionRange(t, e);
      }
    }, {
      key: "value",
      get: function () {
        return this.input.value;
      },
      set: function (t) {
        this.input.value = t;
      }
    }, {
      key: "bindEvents",
      value: function (t) {
        var e = this;
        Object.keys(t).forEach(function (u) {
          return e._toggleEventHandler(n.EVENTS_MAP[u], t[u]);
        });
      }
    }, {
      key: "unbindEvents",
      value: function () {
        var t = this;
        Object.keys(this._handlers).forEach(function (e) {
          return t._toggleEventHandler(e);
        });
      }
    }, {
      key: "_toggleEventHandler",
      value: function (t, e) {
        this._handlers[t] && (this.input.removeEventListener(t, this._handlers[t]), delete this._handlers[t]), e && (this.input.addEventListener(t, e), this._handlers[t] = e);
      }
    }]), n;
  }(au);

  su.EVENTS_MAP = {
    selectionChange: "keydown",
    input: "input",
    drop: "drop",
    click: "click",
    focus: "focus",
    commit: "blur"
  }, Yn.HTMLMaskElement = su;

  var ou = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      return gn(this, n), e.apply(this, arguments);
    }

    return mn(n, [{
      key: "_unsafeSelectionStart",
      get: function () {
        var t = this.rootElement,
            e = t.getSelection && t.getSelection();
        return e && e.anchorOffset;
      }
    }, {
      key: "_unsafeSelectionEnd",
      get: function () {
        var t = this.rootElement,
            e = t.getSelection && t.getSelection();
        return e && this._unsafeSelectionStart + String(e).length;
      }
    }, {
      key: "_unsafeSelect",
      value: function (t, e) {
        if (this.rootElement.createRange) {
          var n = this.rootElement.createRange();
          n.setStart(this.input.firstChild || this.input, t), n.setEnd(this.input.lastChild || this.input, e);
          var u = this.rootElement,
              r = u.getSelection && u.getSelection();
          r && (r.removeAllRanges(), r.addRange(n));
        }
      }
    }, {
      key: "value",
      get: function () {
        return this.input.textContent;
      },
      set: function (t) {
        this.input.textContent = t;
      }
    }]), n;
  }(su);

  Yn.HTMLContenteditableMaskElement = ou;

  var lu = ["mask"],
      hu = function () {
    function t(e, n) {
      gn(this, t), this.el = e instanceof au ? e : e.isContentEditable && "INPUT" !== e.tagName && "TEXTAREA" !== e.tagName ? new ou(e) : new su(e), this.masked = Gn(n), this._listeners = {}, this._value = "", this._unmaskedValue = "", this._saveSelection = this._saveSelection.bind(this), this._onInput = this._onInput.bind(this), this._onChange = this._onChange.bind(this), this._onDrop = this._onDrop.bind(this), this._onFocus = this._onFocus.bind(this), this._onClick = this._onClick.bind(this), this.alignCursor = this.alignCursor.bind(this), this.alignCursorFriendly = this.alignCursorFriendly.bind(this), this._bindEvents(), this.updateValue(), this._onChange();
    }

    return mn(t, [{
      key: "mask",
      get: function () {
        return this.masked.mask;
      },
      set: function (t) {
        if (!this.maskEquals(t)) if (t instanceof Yn.Masked || this.masked.constructor !== Kn(t)) {
          var e = Gn({
            mask: t
          });
          e.unmaskedValue = this.masked.unmaskedValue, this.masked = e;
        } else this.masked.updateOptions({
          mask: t
        });
      }
    }, {
      key: "maskEquals",
      value: function (t) {
        return null == t || t === this.masked.mask || t === Date && this.masked instanceof iu;
      }
    }, {
      key: "value",
      get: function () {
        return this._value;
      },
      set: function (t) {
        this.masked.value = t, this.updateControl(), this.alignCursor();
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this._unmaskedValue;
      },
      set: function (t) {
        this.masked.unmaskedValue = t, this.updateControl(), this.alignCursor();
      }
    }, {
      key: "typedValue",
      get: function () {
        return this.masked.typedValue;
      },
      set: function (t) {
        this.masked.typedValue = t, this.updateControl(), this.alignCursor();
      }
    }, {
      key: "_bindEvents",
      value: function () {
        this.el.bindEvents({
          selectionChange: this._saveSelection,
          input: this._onInput,
          drop: this._onDrop,
          click: this._onClick,
          focus: this._onFocus,
          commit: this._onChange
        });
      }
    }, {
      key: "_unbindEvents",
      value: function () {
        this.el && this.el.unbindEvents();
      }
    }, {
      key: "_fireEvent",
      value: function (t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), u = 1; u < e; u++) n[u - 1] = arguments[u];

        var r = this._listeners[t];
        r && r.forEach(function (t) {
          return t.apply(void 0, n);
        });
      }
    }, {
      key: "selectionStart",
      get: function () {
        return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
      }
    }, {
      key: "cursorPos",
      get: function () {
        return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
      },
      set: function (t) {
        this.el && this.el.isActive && (this.el.select(t, t), this._saveSelection());
      }
    }, {
      key: "_saveSelection",
      value: function () {
        this.value !== this.el.value && console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."), this._selection = {
          start: this.selectionStart,
          end: this.cursorPos
        };
      }
    }, {
      key: "updateValue",
      value: function () {
        this.masked.value = this.el.value, this._value = this.masked.value;
      }
    }, {
      key: "updateControl",
      value: function () {
        var t = this.masked.unmaskedValue,
            e = this.masked.value,
            n = this.unmaskedValue !== t || this.value !== e;
        this._unmaskedValue = t, this._value = e, this.el.value !== e && (this.el.value = e), n && this._fireChangeEvents();
      }
    }, {
      key: "updateOptions",
      value: function (t) {
        var e = t.mask,
            n = Cn(t, lu),
            u = !this.maskEquals(e),
            r = !Nn(this.masked, n);
        u && (this.mask = e), r && this.masked.updateOptions(n), (u || r) && this.updateControl();
      }
    }, {
      key: "updateCursor",
      value: function (t) {
        null != t && (this.cursorPos = t, this._delayUpdateCursor(t));
      }
    }, {
      key: "_delayUpdateCursor",
      value: function (t) {
        var e = this;
        this._abortUpdateCursor(), this._changingCursorPos = t, this._cursorChanging = setTimeout(function () {
          e.el && (e.cursorPos = e._changingCursorPos, e._abortUpdateCursor());
        }, 10);
      }
    }, {
      key: "_fireChangeEvents",
      value: function () {
        this._fireEvent("accept", this._inputEvent), this.masked.isComplete && this._fireEvent("complete", this._inputEvent);
      }
    }, {
      key: "_abortUpdateCursor",
      value: function () {
        this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging);
      }
    }, {
      key: "alignCursor",
      value: function () {
        this.cursorPos = this.masked.nearestInputPos(this.cursorPos, Tn);
      }
    }, {
      key: "alignCursorFriendly",
      value: function () {
        this.selectionStart === this.cursorPos && this.alignCursor();
      }
    }, {
      key: "on",
      value: function (t, e) {
        return this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push(e), this;
      }
    }, {
      key: "off",
      value: function (t, e) {
        if (!this._listeners[t]) return this;
        if (!e) return delete this._listeners[t], this;

        var n = this._listeners[t].indexOf(e);

        return n >= 0 && this._listeners[t].splice(n, 1), this;
      }
    }, {
      key: "_onInput",
      value: function (t) {
        if (this._inputEvent = t, this._abortUpdateCursor(), !this._selection) return this.updateValue();
        var e = new Un(this.el.value, this.cursorPos, this.value, this._selection),
            n = this.masked.rawInputValue,
            u = this.masked.splice(e.startChangePos, e.removed.length, e.inserted, e.removeDirection).offset,
            r = n === this.masked.rawInputValue ? e.removeDirection : On,
            i = this.masked.nearestInputPos(e.startChangePos + u, r);
        this.updateControl(), this.updateCursor(i), delete this._inputEvent;
      }
    }, {
      key: "_onChange",
      value: function () {
        this.value !== this.el.value && this.updateValue(), this.masked.doCommit(), this.updateControl(), this._saveSelection();
      }
    }, {
      key: "_onDrop",
      value: function (t) {
        t.preventDefault(), t.stopPropagation();
      }
    }, {
      key: "_onFocus",
      value: function (t) {
        this.alignCursorFriendly();
      }
    }, {
      key: "_onClick",
      value: function (t) {
        this.alignCursorFriendly();
      }
    }, {
      key: "destroy",
      value: function () {
        this._unbindEvents(), this._listeners.length = 0, delete this.el;
      }
    }]), t;
  }();

  Yn.InputMask = hu;

  var cu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      return gn(this, n), e.apply(this, arguments);
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        t.enum && (t.mask = "*".repeat(t.enum[0].length)), Dn(An(n.prototype), "_update", this).call(this, t);
      }
    }, {
      key: "doValidate",
      value: function () {
        for (var t, e = this, u = arguments.length, r = new Array(u), i = 0; i < u; i++) r[i] = arguments[i];

        return this.enum.some(function (t) {
          return t.indexOf(e.unmaskedValue) >= 0;
        }) && (t = Dn(An(n.prototype), "doValidate", this)).call.apply(t, [this].concat(r));
      }
    }]), n;
  }(nu);

  Yn.MaskedEnum = cu;

  var fu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n(t) {
      return gn(this, n), e.call(this, Object.assign({}, n.DEFAULTS, t));
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        Dn(An(n.prototype), "_update", this).call(this, t), this._updateRegExps();
      }
    }, {
      key: "_updateRegExps",
      value: function () {
        var t = "^" + (this.allowNegative ? "[+|\\-]?" : ""),
            e = (this.scale ? "(" + Ln(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$";
        this._numberRegExpInput = new RegExp(t + "(0|([1-9]+\\d*))?" + e), this._numberRegExp = new RegExp(t + "\\d*" + e), this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(Ln).join("") + "]", "g"), this._thousandsSeparatorRegExp = new RegExp(Ln(this.thousandsSeparator), "g");
      }
    }, {
      key: "_removeThousandsSeparators",
      value: function (t) {
        return t.replace(this._thousandsSeparatorRegExp, "");
      }
    }, {
      key: "_insertThousandsSeparators",
      value: function (t) {
        var e = t.split(this.radix);
        return e[0] = e[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator), e.join(this.radix);
      }
    }, {
      key: "doPrepare",
      value: function (t) {
        for (var e, u = arguments.length, r = new Array(u > 1 ? u - 1 : 0), i = 1; i < u; i++) r[i - 1] = arguments[i];

        return (e = Dn(An(n.prototype), "doPrepare", this)).call.apply(e, [this, this._removeThousandsSeparators(t.replace(this._mapToRadixRegExp, this.radix))].concat(r));
      }
    }, {
      key: "_separatorsCount",
      value: function (t) {
        for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = 0, u = 0; u < t; ++u) this._value.indexOf(this.thousandsSeparator, u) === u && (++n, e && (t += this.thousandsSeparator.length));

        return n;
      }
    }, {
      key: "_separatorsCountFromSlice",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._value;
        return this._separatorsCount(this._removeThousandsSeparators(t).length, !0);
      }
    }, {
      key: "extractInput",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            u = arguments.length > 2 ? arguments[2] : void 0,
            r = this._adjustRangeWithSeparators(t, e),
            i = Mn(r, 2);

        return t = i[0], e = i[1], this._removeThousandsSeparators(Dn(An(n.prototype), "extractInput", this).call(this, t, e, u));
      }
    }, {
      key: "_appendCharRaw",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!this.thousandsSeparator) return Dn(An(n.prototype), "_appendCharRaw", this).call(this, t, e);

        var u = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value,
            r = this._separatorsCountFromSlice(u);

        this._value = this._removeThousandsSeparators(this.value);
        var i = Dn(An(n.prototype), "_appendCharRaw", this).call(this, t, e);
        this._value = this._insertThousandsSeparators(this._value);

        var a = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value,
            s = this._separatorsCountFromSlice(a);

        return i.tailShift += (s - r) * this.thousandsSeparator.length, i.skip = !i.rawInserted && t === this.thousandsSeparator, i;
      }
    }, {
      key: "_findSeparatorAround",
      value: function (t) {
        if (this.thousandsSeparator) {
          var e = t - this.thousandsSeparator.length + 1,
              n = this.value.indexOf(this.thousandsSeparator, e);
          if (n <= t) return n;
        }

        return -1;
      }
    }, {
      key: "_adjustRangeWithSeparators",
      value: function (t, e) {
        var n = this._findSeparatorAround(t);

        n >= 0 && (t = n);

        var u = this._findSeparatorAround(e);

        return u >= 0 && (e = u + this.thousandsSeparator.length), [t, e];
      }
    }, {
      key: "remove",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            n = this._adjustRangeWithSeparators(t, e),
            u = Mn(n, 2);

        t = u[0], e = u[1];

        var r = this.value.slice(0, t),
            i = this.value.slice(e),
            a = this._separatorsCount(r.length);

        this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(r + i));

        var s = this._separatorsCountFromSlice(r);

        return new zn({
          tailShift: (s - a) * this.thousandsSeparator.length
        });
      }
    }, {
      key: "nearestInputPos",
      value: function (t, e) {
        if (!this.thousandsSeparator) return t;

        switch (e) {
          case On:
          case Tn:
          case In:
            var n = this._findSeparatorAround(t - 1);

            if (n >= 0) {
              var u = n + this.thousandsSeparator.length;
              if (t < u || this.value.length <= u || e === In) return n;
            }

            break;

          case jn:
          case Vn:
            var r = this._findSeparatorAround(t);

            if (r >= 0) return r + this.thousandsSeparator.length;
        }

        return t;
      }
    }, {
      key: "doValidate",
      value: function (t) {
        var e = (t.input ? this._numberRegExpInput : this._numberRegExp).test(this._removeThousandsSeparators(this.value));

        if (e) {
          var u = this.number;
          e = e && !isNaN(u) && (null == this.min || this.min >= 0 || this.min <= this.number) && (null == this.max || this.max <= 0 || this.number <= this.max);
        }

        return e && Dn(An(n.prototype), "doValidate", this).call(this, t);
      }
    }, {
      key: "doCommit",
      value: function () {
        if (this.value) {
          var t = this.number,
              e = t;
          null != this.min && (e = Math.max(e, this.min)), null != this.max && (e = Math.min(e, this.max)), e !== t && (this.unmaskedValue = String(e));
          var u = this.value;
          this.normalizeZeros && (u = this._normalizeZeros(u)), this.padFractionalZeros && (u = this._padFractionalZeros(u)), this._value = u;
        }

        Dn(An(n.prototype), "doCommit", this).call(this);
      }
    }, {
      key: "_normalizeZeros",
      value: function (t) {
        var e = this._removeThousandsSeparators(t).split(this.radix);

        return e[0] = e[0].replace(/^(\D*)(0*)(\d*)/, function (t, e, n, u) {
          return e + u;
        }), t.length && !/\d$/.test(e[0]) && (e[0] = e[0] + "0"), e.length > 1 && (e[1] = e[1].replace(/0*$/, ""), e[1].length || (e.length = 1)), this._insertThousandsSeparators(e.join(this.radix));
      }
    }, {
      key: "_padFractionalZeros",
      value: function (t) {
        if (!t) return t;
        var e = t.split(this.radix);
        return e.length < 2 && e.push(""), e[1] = e[1].padEnd(this.scale, "0"), e.join(this.radix);
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, ".");
      },
      set: function (t) {
        wn(An(n.prototype), "unmaskedValue", t.replace(".", this.radix), this, !0);
      }
    }, {
      key: "typedValue",
      get: function () {
        return Number(this.unmaskedValue);
      },
      set: function (t) {
        wn(An(n.prototype), "unmaskedValue", String(t), this, !0);
      }
    }, {
      key: "number",
      get: function () {
        return this.typedValue;
      },
      set: function (t) {
        this.typedValue = t;
      }
    }, {
      key: "allowNegative",
      get: function () {
        return this.signed || null != this.min && this.min < 0 || null != this.max && this.max < 0;
      }
    }]), n;
  }(Zn);

  fu.DEFAULTS = {
    radix: ",",
    thousandsSeparator: "",
    mapToRadix: ["."],
    scale: 2,
    signed: !1,
    normalizeZeros: !0,
    padFractionalZeros: !1
  }, Yn.MaskedNumber = fu;

  var pu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      return gn(this, n), e.apply(this, arguments);
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        t.mask && (t.validate = t.mask), Dn(An(n.prototype), "_update", this).call(this, t);
      }
    }]), n;
  }(Zn);

  Yn.MaskedFunction = pu;

  var du = ["compiledMasks", "currentMaskRef", "currentMask"],
      vu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n(t) {
      var u;
      return gn(this, n), (u = e.call(this, Object.assign({}, n.DEFAULTS, t))).currentMask = null, u;
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        Dn(An(n.prototype), "_update", this).call(this, t), "mask" in t && (this.compiledMasks = Array.isArray(t.mask) ? t.mask.map(function (t) {
          return Gn(t);
        }) : []);
      }
    }, {
      key: "_appendCharRaw",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = this._applyDispatch(t, e);

        return this.currentMask && n.aggregate(this.currentMask._appendChar(t, e)), n;
      }
    }, {
      key: "_applyDispatch",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = e.tail && null != e._beforeTailState ? e._beforeTailState._value : this.value,
            u = this.rawInputValue,
            r = e.tail && null != e._beforeTailState ? e._beforeTailState._rawInputValue : u,
            i = u.slice(r.length),
            a = this.currentMask,
            s = new zn(),
            o = a && a.state;
        if (this.currentMask = this.doDispatch(t, Object.assign({}, e)), this.currentMask) if (this.currentMask !== a) {
          if (this.currentMask.reset(), r) {
            var l = this.currentMask.append(r, {
              raw: !0
            });
            s.tailShift = l.inserted.length - n.length;
          }

          i && (s.tailShift += this.currentMask.append(i, {
            raw: !0,
            tail: !0
          }).tailShift);
        } else this.currentMask.state = o;
        return s;
      }
    }, {
      key: "_appendPlaceholder",
      value: function () {
        var t = this._applyDispatch.apply(this, arguments);

        return this.currentMask && t.aggregate(this.currentMask._appendPlaceholder()), t;
      }
    }, {
      key: "doDispatch",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return this.dispatch(t, this, e);
      }
    }, {
      key: "doValidate",
      value: function () {
        for (var t, e, u = arguments.length, r = new Array(u), i = 0; i < u; i++) r[i] = arguments[i];

        return (t = Dn(An(n.prototype), "doValidate", this)).call.apply(t, [this].concat(r)) && (!this.currentMask || (e = this.currentMask).doValidate.apply(e, r));
      }
    }, {
      key: "reset",
      value: function () {
        this.currentMask && this.currentMask.reset(), this.compiledMasks.forEach(function (t) {
          return t.reset();
        });
      }
    }, {
      key: "value",
      get: function () {
        return this.currentMask ? this.currentMask.value : "";
      },
      set: function (t) {
        wn(An(n.prototype), "value", t, this, !0);
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this.currentMask ? this.currentMask.unmaskedValue : "";
      },
      set: function (t) {
        wn(An(n.prototype), "unmaskedValue", t, this, !0);
      }
    }, {
      key: "typedValue",
      get: function () {
        return this.currentMask ? this.currentMask.typedValue : "";
      },
      set: function (t) {
        var e = String(t);
        this.currentMask && (this.currentMask.typedValue = t, e = this.currentMask.unmaskedValue), this.unmaskedValue = e;
      }
    }, {
      key: "isComplete",
      get: function () {
        return !!this.currentMask && this.currentMask.isComplete;
      }
    }, {
      key: "remove",
      value: function () {
        var t,
            e = new zn();
        this.currentMask && e.aggregate((t = this.currentMask).remove.apply(t, arguments)).aggregate(this._applyDispatch());
        return e;
      }
    }, {
      key: "state",
      get: function () {
        return Object.assign({}, Dn(An(n.prototype), "state", this), {
          _rawInputValue: this.rawInputValue,
          compiledMasks: this.compiledMasks.map(function (t) {
            return t.state;
          }),
          currentMaskRef: this.currentMask,
          currentMask: this.currentMask && this.currentMask.state
        });
      },
      set: function (t) {
        var e = t.compiledMasks,
            u = t.currentMaskRef,
            r = t.currentMask,
            i = Cn(t, du);
        this.compiledMasks.forEach(function (t, n) {
          return t.state = e[n];
        }), null != u && (this.currentMask = u, this.currentMask.state = r), wn(An(n.prototype), "state", i, this, !0);
      }
    }, {
      key: "extractInput",
      value: function () {
        var t;
        return this.currentMask ? (t = this.currentMask).extractInput.apply(t, arguments) : "";
      }
    }, {
      key: "extractTail",
      value: function () {
        for (var t, e, u = arguments.length, r = new Array(u), i = 0; i < u; i++) r[i] = arguments[i];

        return this.currentMask ? (t = this.currentMask).extractTail.apply(t, r) : (e = Dn(An(n.prototype), "extractTail", this)).call.apply(e, [this].concat(r));
      }
    }, {
      key: "doCommit",
      value: function () {
        this.currentMask && this.currentMask.doCommit(), Dn(An(n.prototype), "doCommit", this).call(this);
      }
    }, {
      key: "nearestInputPos",
      value: function () {
        for (var t, e, u = arguments.length, r = new Array(u), i = 0; i < u; i++) r[i] = arguments[i];

        return this.currentMask ? (t = this.currentMask).nearestInputPos.apply(t, r) : (e = Dn(An(n.prototype), "nearestInputPos", this)).call.apply(e, [this].concat(r));
      }
    }, {
      key: "overwrite",
      get: function () {
        return this.currentMask ? this.currentMask.overwrite : Dn(An(n.prototype), "overwrite", this);
      },
      set: function (t) {
        console.warn('"overwrite" option is not available in dynamic mask, use this option in siblings');
      }
    }]), n;
  }(Zn);

  vu.DEFAULTS = {
    dispatch: function (t, e, n) {
      if (e.compiledMasks.length) {
        var u = e.rawInputValue,
            r = e.compiledMasks.map(function (e, r) {
          return e.reset(), e.append(u, {
            raw: !0
          }), e.append(t, n), {
            weight: e.rawInputValue.length,
            index: r
          };
        });
        return r.sort(function (t, e) {
          return e.weight - t.weight;
        }), e.compiledMasks[r[0].index];
      }
    }
  }, Yn.MaskedDynamic = vu;
  var ku = {
    MASKED: "value",
    UNMASKED: "unmaskedValue",
    TYPED: "typedValue"
  };

  function gu(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ku.MASKED,
        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ku.MASKED,
        u = Gn(t);
    return function (t) {
      return u.runIsolated(function (u) {
        return u[e] = t, u[n];
      });
    };
  }

  function yu(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), u = 1; u < e; u++) n[u - 1] = arguments[u];

    return gu.apply(void 0, n)(t);
  }

  Yn.PIPE_TYPE = ku, Yn.createPipe = gu, Yn.pipe = yu;

  try {
    globalThis.IMask = Yn;
  } catch (t) {}

  t.HTMLContenteditableMaskElement = ou, t.HTMLMaskElement = su, t.InputMask = hu, t.MaskElement = au, t.Masked = Zn, t.MaskedDate = iu, t.MaskedDynamic = vu, t.MaskedEnum = cu, t.MaskedFunction = pu, t.MaskedNumber = fu, t.MaskedPattern = nu, t.MaskedRange = ru, t.MaskedRegExp = tu, t.PIPE_TYPE = ku, t.createMask = Gn, t.createPipe = gu, t.default = Yn, t.pipe = yu, Object.defineProperty(t, "__esModule", {
    value: !0
  });
});
/*!
 * Flickity PACKAGED v2.2.2
 * Touch, responsive, flickable carousels
 *
 * Licensed GPLv3 for open source use
 * or Flickity Commercial License for commercial use
 *
 * https://flickity.metafizzy.co
 * Copyright 2015-2021 Metafizzy
 */
(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("jquery-bridget/jquery-bridget", ["jquery"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("jquery"));
  } else {
    e.jQueryBridget = i(e, e.jQuery);
  }
})(window, function t(e, r) {
  "use strict";

  var o = Array.prototype.slice;
  var i = e.console;
  var u = typeof i == "undefined" ? function () {} : function (t) {
    i.error(t);
  };

  function n(h, s, c) {
    c = c || r || e.jQuery;

    if (!c) {
      return;
    }

    if (!s.prototype.option) {
      s.prototype.option = function (t) {
        if (!c.isPlainObject(t)) {
          return;
        }

        this.options = c.extend(true, this.options, t);
      };
    }

    c.fn[h] = function (t) {
      if (typeof t == "string") {
        var e = o.call(arguments, 1);
        return i(this, t, e);
      }

      n(this, t);
      return this;
    };

    function i(t, r, o) {
      var a;
      var l = "$()." + h + '("' + r + '")';
      t.each(function (t, e) {
        var i = c.data(e, h);

        if (!i) {
          u(h + " not initialized. Cannot call methods, i.e. " + l);
          return;
        }

        var n = i[r];

        if (!n || r.charAt(0) == "_") {
          u(l + " is not a valid method");
          return;
        }

        var s = n.apply(i, o);
        a = a === undefined ? s : a;
      });
      return a !== undefined ? a : t;
    }

    function n(t, n) {
      t.each(function (t, e) {
        var i = c.data(e, h);

        if (i) {
          i.option(n);

          i._init();
        } else {
          i = new s(e, n);
          c.data(e, h, i);
        }
      });
    }

    a(c);
  }

  function a(t) {
    if (!t || t && t.bridget) {
      return;
    }

    t.bridget = n;
  }

  a(r || e.jQuery);
  return n;
});

(function (t, e) {
  if (typeof define == "function" && define.amd) {
    define("ev-emitter/ev-emitter", e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e();
  } else {
    t.EvEmitter = e();
  }
})(typeof window != "undefined" ? window : this, function () {
  function t() {}

  var e = t.prototype;

  e.on = function (t, e) {
    if (!t || !e) {
      return;
    }

    var i = this._events = this._events || {};
    var n = i[t] = i[t] || [];

    if (n.indexOf(e) == -1) {
      n.push(e);
    }

    return this;
  };

  e.once = function (t, e) {
    if (!t || !e) {
      return;
    }

    this.on(t, e);
    var i = this._onceEvents = this._onceEvents || {};
    var n = i[t] = i[t] || {};
    n[e] = true;
    return this;
  };

  e.off = function (t, e) {
    var i = this._events && this._events[t];

    if (!i || !i.length) {
      return;
    }

    var n = i.indexOf(e);

    if (n != -1) {
      i.splice(n, 1);
    }

    return this;
  };

  e.emitEvent = function (t, e) {
    var i = this._events && this._events[t];

    if (!i || !i.length) {
      return;
    }

    i = i.slice(0);
    e = e || [];
    var n = this._onceEvents && this._onceEvents[t];

    for (var s = 0; s < i.length; s++) {
      var r = i[s];
      var o = n && n[r];

      if (o) {
        this.off(t, r);
        delete n[r];
      }

      r.apply(this, e);
    }

    return this;
  };

  e.allOff = function () {
    delete this._events;
    delete this._onceEvents;
  };

  return t;
});
/*!
 * getSize v2.0.3
 * measure size of elements
 * MIT license
 */


(function (t, e) {
  if (typeof define == "function" && define.amd) {
    define("get-size/get-size", e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e();
  } else {
    t.getSize = e();
  }
})(window, function t() {
  "use strict";

  function m(t) {
    var e = parseFloat(t);
    var i = t.indexOf("%") == -1 && !isNaN(e);
    return i && e;
  }

  function e() {}

  var i = typeof console == "undefined" ? e : function (t) {
    console.error(t);
  };
  var y = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"];
  var b = y.length;

  function E() {
    var t = {
      width: 0,
      height: 0,
      innerWidth: 0,
      innerHeight: 0,
      outerWidth: 0,
      outerHeight: 0
    };

    for (var e = 0; e < b; e++) {
      var i = y[e];
      t[i] = 0;
    }

    return t;
  }

  function S(t) {
    var e = getComputedStyle(t);

    if (!e) {
      i("Style returned " + e + ". Are you running this code in a hidden iframe on Firefox? " + "See https://bit.ly/getsizebug1");
    }

    return e;
  }

  var n = false;
  var C;

  function x() {
    if (n) {
      return;
    }

    n = true;
    var t = document.createElement("div");
    t.style.width = "200px";
    t.style.padding = "1px 2px 3px 4px";
    t.style.borderStyle = "solid";
    t.style.borderWidth = "1px 2px 3px 4px";
    t.style.boxSizing = "border-box";
    var e = document.body || document.documentElement;
    e.appendChild(t);
    var i = S(t);
    C = Math.round(m(i.width)) == 200;
    s.isBoxSizeOuter = C;
    e.removeChild(t);
  }

  function s(t) {
    x();

    if (typeof t == "string") {
      t = document.querySelector(t);
    }

    if (!t || typeof t != "object" || !t.nodeType) {
      return;
    }

    var e = S(t);

    if (e.display == "none") {
      return E();
    }

    var i = {};
    i.width = t.offsetWidth;
    i.height = t.offsetHeight;
    var n = i.isBorderBox = e.boxSizing == "border-box";

    for (var s = 0; s < b; s++) {
      var r = y[s];
      var o = e[r];
      var a = parseFloat(o);
      i[r] = !isNaN(a) ? a : 0;
    }

    var l = i.paddingLeft + i.paddingRight;
    var h = i.paddingTop + i.paddingBottom;
    var c = i.marginLeft + i.marginRight;
    var u = i.marginTop + i.marginBottom;
    var d = i.borderLeftWidth + i.borderRightWidth;
    var f = i.borderTopWidth + i.borderBottomWidth;
    var p = n && C;
    var v = m(e.width);

    if (v !== false) {
      i.width = v + (p ? 0 : l + d);
    }

    var g = m(e.height);

    if (g !== false) {
      i.height = g + (p ? 0 : h + f);
    }

    i.innerWidth = i.width - (l + d);
    i.innerHeight = i.height - (h + f);
    i.outerWidth = i.width + c;
    i.outerHeight = i.height + u;
    return i;
  }

  return s;
});

(function (t, e) {
  "use strict";

  if (typeof define == "function" && define.amd) {
    define("desandro-matches-selector/matches-selector", e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e();
  } else {
    t.matchesSelector = e();
  }
})(window, function t() {
  "use strict";

  var n = function () {
    var t = window.Element.prototype;

    if (t.matches) {
      return "matches";
    }

    if (t.matchesSelector) {
      return "matchesSelector";
    }

    var e = ["webkit", "moz", "ms", "o"];

    for (var i = 0; i < e.length; i++) {
      var n = e[i];
      var s = n + "MatchesSelector";

      if (t[s]) {
        return s;
      }
    }
  }();

  return function t(e, i) {
    return e[n](i);
  };
});

(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("desandro-matches-selector"));
  } else {
    e.fizzyUIUtils = i(e, e.matchesSelector);
  }
})(window, function t(h, r) {
  var c = {};

  c.extend = function (t, e) {
    for (var i in e) {
      t[i] = e[i];
    }

    return t;
  };

  c.modulo = function (t, e) {
    return (t % e + e) % e;
  };

  var i = Array.prototype.slice;

  c.makeArray = function (t) {
    if (Array.isArray(t)) {
      return t;
    }

    if (t === null || t === undefined) {
      return [];
    }

    var e = typeof t == "object" && typeof t.length == "number";

    if (e) {
      return i.call(t);
    }

    return [t];
  };

  c.removeFrom = function (t, e) {
    var i = t.indexOf(e);

    if (i != -1) {
      t.splice(i, 1);
    }
  };

  c.getParent = function (t, e) {
    while (t.parentNode && t != document.body) {
      t = t.parentNode;

      if (r(t, e)) {
        return t;
      }
    }
  };

  c.getQueryElement = function (t) {
    if (typeof t == "string") {
      return document.querySelector(t);
    }

    return t;
  };

  c.handleEvent = function (t) {
    var e = "on" + t.type;

    if (this[e]) {
      this[e](t);
    }
  };

  c.filterFindElements = function (t, n) {
    t = c.makeArray(t);
    var s = [];
    t.forEach(function (t) {
      if (!(t instanceof HTMLElement)) {
        return;
      }

      if (!n) {
        s.push(t);
        return;
      }

      if (r(t, n)) {
        s.push(t);
      }

      var e = t.querySelectorAll(n);

      for (var i = 0; i < e.length; i++) {
        s.push(e[i]);
      }
    });
    return s;
  };

  c.debounceMethod = function (t, e, n) {
    n = n || 100;
    var s = t.prototype[e];
    var r = e + "Timeout";

    t.prototype[e] = function () {
      var t = this[r];
      clearTimeout(t);
      var e = arguments;
      var i = this;
      this[r] = setTimeout(function () {
        s.apply(i, e);
        delete i[r];
      }, n);
    };
  };

  c.docReady = function (t) {
    var e = document.readyState;

    if (e == "complete" || e == "interactive") {
      setTimeout(t);
    } else {
      document.addEventListener("DOMContentLoaded", t);
    }
  };

  c.toDashed = function (t) {
    return t.replace(/(.)([A-Z])/g, function (t, e, i) {
      return e + "-" + i;
    }).toLowerCase();
  };

  var u = h.console;

  c.htmlInit = function (a, l) {
    c.docReady(function () {
      var t = c.toDashed(l);
      var s = "data-" + t;
      var e = document.querySelectorAll("[" + s + "]");
      var i = document.querySelectorAll(".js-" + t);
      var n = c.makeArray(e).concat(c.makeArray(i));
      var r = s + "-options";
      var o = h.jQuery;
      n.forEach(function (e) {
        var t = e.getAttribute(s) || e.getAttribute(r);
        var i;

        try {
          i = t && JSON.parse(t);
        } catch (t) {
          if (u) {
            u.error("Error parsing " + s + " on " + e.className + ": " + t);
          }

          return;
        }

        var n = new a(e, i);

        if (o) {
          o.data(e, l, n);
        }
      });
    });
  };

  return c;
});

(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/cell", ["get-size/get-size"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("get-size"));
  } else {
    e.Flickity = e.Flickity || {};
    e.Flickity.Cell = i(e, e.getSize);
  }
})(window, function t(e, i) {
  function n(t, e) {
    this.element = t;
    this.parent = e;
    this.create();
  }

  var s = n.prototype;

  s.create = function () {
    this.element.style.position = "absolute";
    this.element.setAttribute("aria-hidden", "true");
    this.x = 0;
    this.shift = 0;
  };

  s.destroy = function () {
    this.unselect();
    this.element.style.position = "";
    var t = this.parent.originSide;
    this.element.style[t] = "";
    this.element.removeAttribute("aria-hidden");
  };

  s.getSize = function () {
    this.size = i(this.element);
  };

  s.setPosition = function (t) {
    this.x = t;
    this.updateTarget();
    this.renderPosition(t);
  };

  s.updateTarget = s.setDefaultTarget = function () {
    var t = this.parent.originSide == "left" ? "marginLeft" : "marginRight";
    this.target = this.x + this.size[t] + this.size.width * this.parent.cellAlign;
  };

  s.renderPosition = function (t) {
    var e = this.parent.originSide;
    this.element.style[e] = this.parent.getPositionValue(t);
  };

  s.select = function () {
    this.element.classList.add("is-selected");
    this.element.removeAttribute("aria-hidden");
  };

  s.unselect = function () {
    this.element.classList.remove("is-selected");
    this.element.setAttribute("aria-hidden", "true");
  };

  s.wrapShift = function (t) {
    this.shift = t;
    this.renderPosition(this.x + this.parent.slideableWidth * t);
  };

  s.remove = function () {
    this.element.parentNode.removeChild(this.element);
  };

  return n;
});

(function (t, e) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/slide", e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e();
  } else {
    t.Flickity = t.Flickity || {};
    t.Flickity.Slide = e();
  }
})(window, function t() {
  "use strict";

  function e(t) {
    this.parent = t;
    this.isOriginLeft = t.originSide == "left";
    this.cells = [];
    this.outerWidth = 0;
    this.height = 0;
  }

  var i = e.prototype;

  i.addCell = function (t) {
    this.cells.push(t);
    this.outerWidth += t.size.outerWidth;
    this.height = Math.max(t.size.outerHeight, this.height);

    if (this.cells.length == 1) {
      this.x = t.x;
      var e = this.isOriginLeft ? "marginLeft" : "marginRight";
      this.firstMargin = t.size[e];
    }
  };

  i.updateTarget = function () {
    var t = this.isOriginLeft ? "marginRight" : "marginLeft";
    var e = this.getLastCell();
    var i = e ? e.size[t] : 0;
    var n = this.outerWidth - (this.firstMargin + i);
    this.target = this.x + this.firstMargin + n * this.parent.cellAlign;
  };

  i.getLastCell = function () {
    return this.cells[this.cells.length - 1];
  };

  i.select = function () {
    this.cells.forEach(function (t) {
      t.select();
    });
  };

  i.unselect = function () {
    this.cells.forEach(function (t) {
      t.unselect();
    });
  };

  i.getCellElements = function () {
    return this.cells.map(function (t) {
      return t.element;
    });
  };

  return e;
});

(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/animate", ["fizzy-ui-utils/utils"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("fizzy-ui-utils"));
  } else {
    e.Flickity = e.Flickity || {};
    e.Flickity.animatePrototype = i(e, e.fizzyUIUtils);
  }
})(window, function t(e, i) {
  var n = {};

  n.startAnimation = function () {
    if (this.isAnimating) {
      return;
    }

    this.isAnimating = true;
    this.restingFrames = 0;
    this.animate();
  };

  n.animate = function () {
    this.applyDragForce();
    this.applySelectedAttraction();
    var t = this.x;
    this.integratePhysics();
    this.positionSlider();
    this.settle(t);

    if (this.isAnimating) {
      var e = this;
      requestAnimationFrame(function t() {
        e.animate();
      });
    }
  };

  n.positionSlider = function () {
    var t = this.x;

    if (this.options.wrapAround && this.cells.length > 1) {
      t = i.modulo(t, this.slideableWidth);
      t -= this.slideableWidth;
      this.shiftWrapCells(t);
    }

    this.setTranslateX(t, this.isAnimating);
    this.dispatchScrollEvent();
  };

  n.setTranslateX = function (t, e) {
    t += this.cursorPosition;
    t = this.options.rightToLeft ? -t : t;
    var i = this.getPositionValue(t);
    this.slider.style.transform = e ? "translate3d(" + i + ",0,0)" : "translateX(" + i + ")";
  };

  n.dispatchScrollEvent = function () {
    var t = this.slides[0];

    if (!t) {
      return;
    }

    var e = -this.x - t.target;
    var i = e / this.slidesWidth;
    this.dispatchEvent("scroll", null, [i, e]);
  };

  n.positionSliderAtSelected = function () {
    if (!this.cells.length) {
      return;
    }

    this.x = -this.selectedSlide.target;
    this.velocity = 0;
    this.positionSlider();
  };

  n.getPositionValue = function (t) {
    if (this.options.percentPosition) {
      return Math.round(t / this.size.innerWidth * 1e4) * .01 + "%";
    } else {
      return Math.round(t) + "px";
    }
  };

  n.settle = function (t) {
    var e = !this.isPointerDown && Math.round(this.x * 100) == Math.round(t * 100);

    if (e) {
      this.restingFrames++;
    }

    if (this.restingFrames > 2) {
      this.isAnimating = false;
      delete this.isFreeScrolling;
      this.positionSlider();
      this.dispatchEvent("settle", null, [this.selectedIndex]);
    }
  };

  n.shiftWrapCells = function (t) {
    var e = this.cursorPosition + t;

    this._shiftCells(this.beforeShiftCells, e, -1);

    var i = this.size.innerWidth - (t + this.slideableWidth + this.cursorPosition);

    this._shiftCells(this.afterShiftCells, i, 1);
  };

  n._shiftCells = function (t, e, i) {
    for (var n = 0; n < t.length; n++) {
      var s = t[n];
      var r = e > 0 ? i : 0;
      s.wrapShift(r);
      e -= s.size.outerWidth;
    }
  };

  n._unshiftCells = function (t) {
    if (!t || !t.length) {
      return;
    }

    for (var e = 0; e < t.length; e++) {
      t[e].wrapShift(0);
    }
  };

  n.integratePhysics = function () {
    this.x += this.velocity;
    this.velocity *= this.getFrictionFactor();
  };

  n.applyForce = function (t) {
    this.velocity += t;
  };

  n.getFrictionFactor = function () {
    return 1 - this.options[this.isFreeScrolling ? "freeScrollFriction" : "friction"];
  };

  n.getRestingPosition = function () {
    return this.x + this.velocity / (1 - this.getFrictionFactor());
  };

  n.applyDragForce = function () {
    if (!this.isDraggable || !this.isPointerDown) {
      return;
    }

    var t = this.dragX - this.x;
    var e = t - this.velocity;
    this.applyForce(e);
  };

  n.applySelectedAttraction = function () {
    var t = this.isDraggable && this.isPointerDown;

    if (t || this.isFreeScrolling || !this.slides.length) {
      return;
    }

    var e = this.selectedSlide.target * -1 - this.x;
    var i = e * this.options.selectedAttraction;
    this.applyForce(i);
  };

  return n;
});

(function (o, a) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/flickity", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./cell", "./slide", "./animate"], function (t, e, i, n, s, r) {
      return a(o, t, e, i, n, s, r);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = a(o, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./cell"), require("./slide"), require("./animate"));
  } else {
    var t = o.Flickity;
    o.Flickity = a(o, o.EvEmitter, o.getSize, o.fizzyUIUtils, t.Cell, t.Slide, t.animatePrototype);
  }
})(window, function t(n, e, i, a, s, o, r) {
  var l = n.jQuery;
  var h = n.getComputedStyle;
  var c = n.console;

  function u(t, e) {
    t = a.makeArray(t);

    while (t.length) {
      e.appendChild(t.shift());
    }
  }

  var d = 0;
  var f = {};

  function p(t, e) {
    var i = a.getQueryElement(t);

    if (!i) {
      if (c) {
        c.error("Bad element for Flickity: " + (i || t));
      }

      return;
    }

    this.element = i;

    if (this.element.flickityGUID) {
      var n = f[this.element.flickityGUID];
      if (n) n.option(e);
      return n;
    }

    if (l) {
      this.$element = l(this.element);
    }

    this.options = a.extend({}, this.constructor.defaults);
    this.option(e);

    this._create();
  }

  p.defaults = {
    accessibility: true,
    cellAlign: "center",
    freeScrollFriction: .075,
    friction: .28,
    namespaceJQueryEvents: true,
    percentPosition: true,
    resize: true,
    selectedAttraction: .025,
    setGallerySize: true
  };
  p.createMethods = [];
  var v = p.prototype;
  a.extend(v, e.prototype);

  v._create = function () {
    var t = this.guid = ++d;
    this.element.flickityGUID = t;
    f[t] = this;
    this.selectedIndex = 0;
    this.restingFrames = 0;
    this.x = 0;
    this.velocity = 0;
    this.originSide = this.options.rightToLeft ? "right" : "left";
    this.viewport = document.createElement("div");
    this.viewport.className = "flickity-viewport";

    this._createSlider();

    if (this.options.resize || this.options.watchCSS) {
      n.addEventListener("resize", this);
    }

    for (var e in this.options.on) {
      var i = this.options.on[e];
      this.on(e, i);
    }

    p.createMethods.forEach(function (t) {
      this[t]();
    }, this);

    if (this.options.watchCSS) {
      this.watchCSS();
    } else {
      this.activate();
    }
  };

  v.option = function (t) {
    a.extend(this.options, t);
  };

  v.activate = function () {
    if (this.isActive) {
      return;
    }

    this.isActive = true;
    this.element.classList.add("flickity-enabled");

    if (this.options.rightToLeft) {
      this.element.classList.add("flickity-rtl");
    }

    this.getSize();

    var t = this._filterFindCellElements(this.element.children);

    u(t, this.slider);
    this.viewport.appendChild(this.slider);
    this.element.appendChild(this.viewport);
    this.reloadCells();

    if (this.options.accessibility) {
      this.element.tabIndex = 0;
      this.element.addEventListener("keydown", this);
    }

    this.emitEvent("activate");
    this.selectInitialIndex();
    this.isInitActivated = true;
    this.dispatchEvent("ready");
  };

  v._createSlider = function () {
    var t = document.createElement("div");
    t.className = "flickity-slider";
    t.style[this.originSide] = 0;
    this.slider = t;
  };

  v._filterFindCellElements = function (t) {
    return a.filterFindElements(t, this.options.cellSelector);
  };

  v.reloadCells = function () {
    this.cells = this._makeCells(this.slider.children);
    this.positionCells();

    this._getWrapShiftCells();

    this.setGallerySize();
  };

  v._makeCells = function (t) {
    var e = this._filterFindCellElements(t);

    var i = e.map(function (t) {
      return new s(t, this);
    }, this);
    return i;
  };

  v.getLastCell = function () {
    return this.cells[this.cells.length - 1];
  };

  v.getLastSlide = function () {
    return this.slides[this.slides.length - 1];
  };

  v.positionCells = function () {
    this._sizeCells(this.cells);

    this._positionCells(0);
  };

  v._positionCells = function (t) {
    t = t || 0;
    this.maxCellHeight = t ? this.maxCellHeight || 0 : 0;
    var e = 0;

    if (t > 0) {
      var i = this.cells[t - 1];
      e = i.x + i.size.outerWidth;
    }

    var n = this.cells.length;

    for (var s = t; s < n; s++) {
      var r = this.cells[s];
      r.setPosition(e);
      e += r.size.outerWidth;
      this.maxCellHeight = Math.max(r.size.outerHeight, this.maxCellHeight);
    }

    this.slideableWidth = e;
    this.updateSlides();

    this._containSlides();

    this.slidesWidth = n ? this.getLastSlide().target - this.slides[0].target : 0;
  };

  v._sizeCells = function (t) {
    t.forEach(function (t) {
      t.getSize();
    });
  };

  v.updateSlides = function () {
    this.slides = [];

    if (!this.cells.length) {
      return;
    }

    var n = new o(this);
    this.slides.push(n);
    var t = this.originSide == "left";
    var s = t ? "marginRight" : "marginLeft";

    var r = this._getCanCellFit();

    this.cells.forEach(function (t, e) {
      if (!n.cells.length) {
        n.addCell(t);
        return;
      }

      var i = n.outerWidth - n.firstMargin + (t.size.outerWidth - t.size[s]);

      if (r.call(this, e, i)) {
        n.addCell(t);
      } else {
        n.updateTarget();
        n = new o(this);
        this.slides.push(n);
        n.addCell(t);
      }
    }, this);
    n.updateTarget();
    this.updateSelectedSlide();
  };

  v._getCanCellFit = function () {
    var t = this.options.groupCells;

    if (!t) {
      return function () {
        return false;
      };
    } else if (typeof t == "number") {
      var e = parseInt(t, 10);
      return function (t) {
        return t % e !== 0;
      };
    }

    var i = typeof t == "string" && t.match(/^(\d+)%$/);
    var n = i ? parseInt(i[1], 10) / 100 : 1;
    return function (t, e) {
      return e <= (this.size.innerWidth + 1) * n;
    };
  };

  v._init = v.reposition = function () {
    this.positionCells();
    this.positionSliderAtSelected();
  };

  v.getSize = function () {
    this.size = i(this.element);
    this.setCellAlign();
    this.cursorPosition = this.size.innerWidth * this.cellAlign;
  };

  var g = {
    center: {
      left: .5,
      right: .5
    },
    left: {
      left: 0,
      right: 1
    },
    right: {
      right: 0,
      left: 1
    }
  };

  v.setCellAlign = function () {
    var t = g[this.options.cellAlign];
    this.cellAlign = t ? t[this.originSide] : this.options.cellAlign;
  };

  v.setGallerySize = function () {
    if (this.options.setGallerySize) {
      var t = this.options.adaptiveHeight && this.selectedSlide ? this.selectedSlide.height : this.maxCellHeight;
      this.viewport.style.height = t + "px";
    }
  };

  v._getWrapShiftCells = function () {
    if (!this.options.wrapAround) {
      return;
    }

    this._unshiftCells(this.beforeShiftCells);

    this._unshiftCells(this.afterShiftCells);

    var t = this.cursorPosition;
    var e = this.cells.length - 1;
    this.beforeShiftCells = this._getGapCells(t, e, -1);
    t = this.size.innerWidth - this.cursorPosition;
    this.afterShiftCells = this._getGapCells(t, 0, 1);
  };

  v._getGapCells = function (t, e, i) {
    var n = [];

    while (t > 0) {
      var s = this.cells[e];

      if (!s) {
        break;
      }

      n.push(s);
      e += i;
      t -= s.size.outerWidth;
    }

    return n;
  };

  v._containSlides = function () {
    if (!this.options.contain || this.options.wrapAround || !this.cells.length) {
      return;
    }

    var t = this.options.rightToLeft;
    var e = t ? "marginRight" : "marginLeft";
    var i = t ? "marginLeft" : "marginRight";
    var n = this.slideableWidth - this.getLastCell().size[i];
    var s = n < this.size.innerWidth;
    var r = this.cursorPosition + this.cells[0].size[e];
    var o = n - this.size.innerWidth * (1 - this.cellAlign);
    this.slides.forEach(function (t) {
      if (s) {
        t.target = n * this.cellAlign;
      } else {
        t.target = Math.max(t.target, r);
        t.target = Math.min(t.target, o);
      }
    }, this);
  };

  v.dispatchEvent = function (t, e, i) {
    var n = e ? [e].concat(i) : i;
    this.emitEvent(t, n);

    if (l && this.$element) {
      t += this.options.namespaceJQueryEvents ? ".flickity" : "";
      var s = t;

      if (e) {
        var r = new l.Event(e);
        r.type = t;
        s = r;
      }

      this.$element.trigger(s, i);
    }
  };

  v.select = function (t, e, i) {
    if (!this.isActive) {
      return;
    }

    t = parseInt(t, 10);

    this._wrapSelect(t);

    if (this.options.wrapAround || e) {
      t = a.modulo(t, this.slides.length);
    }

    if (!this.slides[t]) {
      return;
    }

    var n = this.selectedIndex;
    this.selectedIndex = t;
    this.updateSelectedSlide();

    if (i) {
      this.positionSliderAtSelected();
    } else {
      this.startAnimation();
    }

    if (this.options.adaptiveHeight) {
      this.setGallerySize();
    }

    this.dispatchEvent("select", null, [t]);

    if (t != n) {
      this.dispatchEvent("change", null, [t]);
    }

    this.dispatchEvent("cellSelect");
  };

  v._wrapSelect = function (t) {
    var e = this.slides.length;
    var i = this.options.wrapAround && e > 1;

    if (!i) {
      return t;
    }

    var n = a.modulo(t, e);
    var s = Math.abs(n - this.selectedIndex);
    var r = Math.abs(n + e - this.selectedIndex);
    var o = Math.abs(n - e - this.selectedIndex);

    if (!this.isDragSelect && r < s) {
      t += e;
    } else if (!this.isDragSelect && o < s) {
      t -= e;
    }

    if (t < 0) {
      this.x -= this.slideableWidth;
    } else if (t >= e) {
      this.x += this.slideableWidth;
    }
  };

  v.previous = function (t, e) {
    this.select(this.selectedIndex - 1, t, e);
  };

  v.next = function (t, e) {
    this.select(this.selectedIndex + 1, t, e);
  };

  v.updateSelectedSlide = function () {
    var t = this.slides[this.selectedIndex];

    if (!t) {
      return;
    }

    this.unselectSelectedSlide();
    this.selectedSlide = t;
    t.select();
    this.selectedCells = t.cells;
    this.selectedElements = t.getCellElements();
    this.selectedCell = t.cells[0];
    this.selectedElement = this.selectedElements[0];
  };

  v.unselectSelectedSlide = function () {
    if (this.selectedSlide) {
      this.selectedSlide.unselect();
    }
  };

  v.selectInitialIndex = function () {
    var t = this.options.initialIndex;

    if (this.isInitActivated) {
      this.select(this.selectedIndex, false, true);
      return;
    }

    if (t && typeof t == "string") {
      var e = this.queryCell(t);

      if (e) {
        this.selectCell(t, false, true);
        return;
      }
    }

    var i = 0;

    if (t && this.slides[t]) {
      i = t;
    }

    this.select(i, false, true);
  };

  v.selectCell = function (t, e, i) {
    var n = this.queryCell(t);

    if (!n) {
      return;
    }

    var s = this.getCellSlideIndex(n);
    this.select(s, e, i);
  };

  v.getCellSlideIndex = function (t) {
    for (var e = 0; e < this.slides.length; e++) {
      var i = this.slides[e];
      var n = i.cells.indexOf(t);

      if (n != -1) {
        return e;
      }
    }
  };

  v.getCell = function (t) {
    for (var e = 0; e < this.cells.length; e++) {
      var i = this.cells[e];

      if (i.element == t) {
        return i;
      }
    }
  };

  v.getCells = function (t) {
    t = a.makeArray(t);
    var i = [];
    t.forEach(function (t) {
      var e = this.getCell(t);

      if (e) {
        i.push(e);
      }
    }, this);
    return i;
  };

  v.getCellElements = function () {
    return this.cells.map(function (t) {
      return t.element;
    });
  };

  v.getParentCell = function (t) {
    var e = this.getCell(t);

    if (e) {
      return e;
    }

    t = a.getParent(t, ".flickity-slider > *");
    return this.getCell(t);
  };

  v.getAdjacentCellElements = function (t, e) {
    if (!t) {
      return this.selectedSlide.getCellElements();
    }

    e = e === undefined ? this.selectedIndex : e;
    var i = this.slides.length;

    if (1 + t * 2 >= i) {
      return this.getCellElements();
    }

    var n = [];

    for (var s = e - t; s <= e + t; s++) {
      var r = this.options.wrapAround ? a.modulo(s, i) : s;
      var o = this.slides[r];

      if (o) {
        n = n.concat(o.getCellElements());
      }
    }

    return n;
  };

  v.queryCell = function (t) {
    if (typeof t == "number") {
      return this.cells[t];
    }

    if (typeof t == "string") {
      if (t.match(/^[#.]?[\d/]/)) {
        return;
      }

      t = this.element.querySelector(t);
    }

    return this.getCell(t);
  };

  v.uiChange = function () {
    this.emitEvent("uiChange");
  };

  v.childUIPointerDown = function (t) {
    if (t.type != "touchstart") {
      t.preventDefault();
    }

    this.focus();
  };

  v.onresize = function () {
    this.watchCSS();
    this.resize();
  };

  a.debounceMethod(p, "onresize", 150);

  v.resize = function () {
    if (!this.isActive) {
      return;
    }

    this.getSize();

    if (this.options.wrapAround) {
      this.x = a.modulo(this.x, this.slideableWidth);
    }

    this.positionCells();

    this._getWrapShiftCells();

    this.setGallerySize();
    this.emitEvent("resize");
    var t = this.selectedElements && this.selectedElements[0];
    this.selectCell(t, false, true);
  };

  v.watchCSS = function () {
    var t = this.options.watchCSS;

    if (!t) {
      return;
    }

    var e = h(this.element, ":after").content;

    if (e.indexOf("flickity") != -1) {
      this.activate();
    } else {
      this.deactivate();
    }
  };

  v.onkeydown = function (t) {
    var e = document.activeElement && document.activeElement != this.element;

    if (!this.options.accessibility || e) {
      return;
    }

    var i = p.keyboardHandlers[t.keyCode];

    if (i) {
      i.call(this);
    }
  };

  p.keyboardHandlers = {
    37: function () {
      var t = this.options.rightToLeft ? "next" : "previous";
      this.uiChange();
      this[t]();
    },
    39: function () {
      var t = this.options.rightToLeft ? "previous" : "next";
      this.uiChange();
      this[t]();
    }
  };

  v.focus = function () {
    var t = n.pageYOffset;
    this.element.focus({
      preventScroll: true
    });

    if (n.pageYOffset != t) {
      n.scrollTo(n.pageXOffset, t);
    }
  };

  v.deactivate = function () {
    if (!this.isActive) {
      return;
    }

    this.element.classList.remove("flickity-enabled");
    this.element.classList.remove("flickity-rtl");
    this.unselectSelectedSlide();
    this.cells.forEach(function (t) {
      t.destroy();
    });
    this.element.removeChild(this.viewport);
    u(this.slider.children, this.element);

    if (this.options.accessibility) {
      this.element.removeAttribute("tabIndex");
      this.element.removeEventListener("keydown", this);
    }

    this.isActive = false;
    this.emitEvent("deactivate");
  };

  v.destroy = function () {
    this.deactivate();
    n.removeEventListener("resize", this);
    this.allOff();
    this.emitEvent("destroy");

    if (l && this.$element) {
      l.removeData(this.element, "flickity");
    }

    delete this.element.flickityGUID;
    delete f[this.guid];
  };

  a.extend(v, r);

  p.data = function (t) {
    t = a.getQueryElement(t);
    var e = t && t.flickityGUID;
    return e && f[e];
  };

  a.htmlInit(p, "flickity");

  if (l && l.bridget) {
    l.bridget("flickity", p);
  }

  p.setJQuery = function (t) {
    l = t;
  };

  p.Cell = s;
  p.Slide = o;
  return p;
});
/*!
 * Unipointer v2.3.0
 * base class for doing one thing with pointer event
 * MIT license
 */


(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("unipointer/unipointer", ["ev-emitter/ev-emitter"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("ev-emitter"));
  } else {
    e.Unipointer = i(e, e.EvEmitter);
  }
})(window, function t(s, e) {
  function i() {}

  function n() {}

  var r = n.prototype = Object.create(e.prototype);

  r.bindStartEvent = function (t) {
    this._bindStartEvent(t, true);
  };

  r.unbindStartEvent = function (t) {
    this._bindStartEvent(t, false);
  };

  r._bindStartEvent = function (t, e) {
    e = e === undefined ? true : e;
    var i = e ? "addEventListener" : "removeEventListener";
    var n = "mousedown";

    if (s.PointerEvent) {
      n = "pointerdown";
    } else if ("ontouchstart" in s) {
      n = "touchstart";
    }

    t[i](n, this);
  };

  r.handleEvent = function (t) {
    var e = "on" + t.type;

    if (this[e]) {
      this[e](t);
    }
  };

  r.getTouch = function (t) {
    for (var e = 0; e < t.length; e++) {
      var i = t[e];

      if (i.identifier == this.pointerIdentifier) {
        return i;
      }
    }
  };

  r.onmousedown = function (t) {
    var e = t.button;

    if (e && e !== 0 && e !== 1) {
      return;
    }

    this._pointerDown(t, t);
  };

  r.ontouchstart = function (t) {
    this._pointerDown(t, t.changedTouches[0]);
  };

  r.onpointerdown = function (t) {
    this._pointerDown(t, t);
  };

  r._pointerDown = function (t, e) {
    if (t.button || this.isPointerDown) {
      return;
    }

    this.isPointerDown = true;
    this.pointerIdentifier = e.pointerId !== undefined ? e.pointerId : e.identifier;
    this.pointerDown(t, e);
  };

  r.pointerDown = function (t, e) {
    this._bindPostStartEvents(t);

    this.emitEvent("pointerDown", [t, e]);
  };

  var o = {
    mousedown: ["mousemove", "mouseup"],
    touchstart: ["touchmove", "touchend", "touchcancel"],
    pointerdown: ["pointermove", "pointerup", "pointercancel"]
  };

  r._bindPostStartEvents = function (t) {
    if (!t) {
      return;
    }

    var e = o[t.type];
    e.forEach(function (t) {
      s.addEventListener(t, this);
    }, this);
    this._boundPointerEvents = e;
  };

  r._unbindPostStartEvents = function () {
    if (!this._boundPointerEvents) {
      return;
    }

    this._boundPointerEvents.forEach(function (t) {
      s.removeEventListener(t, this);
    }, this);

    delete this._boundPointerEvents;
  };

  r.onmousemove = function (t) {
    this._pointerMove(t, t);
  };

  r.onpointermove = function (t) {
    if (t.pointerId == this.pointerIdentifier) {
      this._pointerMove(t, t);
    }
  };

  r.ontouchmove = function (t) {
    var e = this.getTouch(t.changedTouches);

    if (e) {
      this._pointerMove(t, e);
    }
  };

  r._pointerMove = function (t, e) {
    this.pointerMove(t, e);
  };

  r.pointerMove = function (t, e) {
    this.emitEvent("pointerMove", [t, e]);
  };

  r.onmouseup = function (t) {
    this._pointerUp(t, t);
  };

  r.onpointerup = function (t) {
    if (t.pointerId == this.pointerIdentifier) {
      this._pointerUp(t, t);
    }
  };

  r.ontouchend = function (t) {
    var e = this.getTouch(t.changedTouches);

    if (e) {
      this._pointerUp(t, e);
    }
  };

  r._pointerUp = function (t, e) {
    this._pointerDone();

    this.pointerUp(t, e);
  };

  r.pointerUp = function (t, e) {
    this.emitEvent("pointerUp", [t, e]);
  };

  r._pointerDone = function () {
    this._pointerReset();

    this._unbindPostStartEvents();

    this.pointerDone();
  };

  r._pointerReset = function () {
    this.isPointerDown = false;
    delete this.pointerIdentifier;
  };

  r.pointerDone = i;

  r.onpointercancel = function (t) {
    if (t.pointerId == this.pointerIdentifier) {
      this._pointerCancel(t, t);
    }
  };

  r.ontouchcancel = function (t) {
    var e = this.getTouch(t.changedTouches);

    if (e) {
      this._pointerCancel(t, e);
    }
  };

  r._pointerCancel = function (t, e) {
    this._pointerDone();

    this.pointerCancel(t, e);
  };

  r.pointerCancel = function (t, e) {
    this.emitEvent("pointerCancel", [t, e]);
  };

  n.getPointerPoint = function (t) {
    return {
      x: t.pageX,
      y: t.pageY
    };
  };

  return n;
});
/*!
 * Unidragger v2.3.1
 * Draggable base class
 * MIT license
 */


(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("unidragger/unidragger", ["unipointer/unipointer"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("unipointer"));
  } else {
    e.Unidragger = i(e, e.Unipointer);
  }
})(window, function t(r, e) {
  function i() {}

  var n = i.prototype = Object.create(e.prototype);

  n.bindHandles = function () {
    this._bindHandles(true);
  };

  n.unbindHandles = function () {
    this._bindHandles(false);
  };

  n._bindHandles = function (t) {
    t = t === undefined ? true : t;
    var e = t ? "addEventListener" : "removeEventListener";
    var i = t ? this._touchActionValue : "";

    for (var n = 0; n < this.handles.length; n++) {
      var s = this.handles[n];

      this._bindStartEvent(s, t);

      s[e]("click", this);

      if (r.PointerEvent) {
        s.style.touchAction = i;
      }
    }
  };

  n._touchActionValue = "none";

  n.pointerDown = function (t, e) {
    var i = this.okayPointerDown(t);

    if (!i) {
      return;
    }

    this.pointerDownPointer = {
      pageX: e.pageX,
      pageY: e.pageY
    };
    t.preventDefault();
    this.pointerDownBlur();

    this._bindPostStartEvents(t);

    this.emitEvent("pointerDown", [t, e]);
  };

  var s = {
    TEXTAREA: true,
    INPUT: true,
    SELECT: true,
    OPTION: true
  };
  var o = {
    radio: true,
    checkbox: true,
    button: true,
    submit: true,
    image: true,
    file: true
  };

  n.okayPointerDown = function (t) {
    var e = s[t.target.nodeName];
    var i = o[t.target.type];
    var n = !e || i;

    if (!n) {
      this._pointerReset();
    }

    return n;
  };

  n.pointerDownBlur = function () {
    var t = document.activeElement;
    var e = t && t.blur && t != document.body;

    if (e) {
      t.blur();
    }
  };

  n.pointerMove = function (t, e) {
    var i = this._dragPointerMove(t, e);

    this.emitEvent("pointerMove", [t, e, i]);

    this._dragMove(t, e, i);
  };

  n._dragPointerMove = function (t, e) {
    var i = {
      x: e.pageX - this.pointerDownPointer.pageX,
      y: e.pageY - this.pointerDownPointer.pageY
    };

    if (!this.isDragging && this.hasDragStarted(i)) {
      this._dragStart(t, e);
    }

    return i;
  };

  n.hasDragStarted = function (t) {
    return Math.abs(t.x) > 3 || Math.abs(t.y) > 3;
  };

  n.pointerUp = function (t, e) {
    this.emitEvent("pointerUp", [t, e]);

    this._dragPointerUp(t, e);
  };

  n._dragPointerUp = function (t, e) {
    if (this.isDragging) {
      this._dragEnd(t, e);
    } else {
      this._staticClick(t, e);
    }
  };

  n._dragStart = function (t, e) {
    this.isDragging = true;
    this.isPreventingClicks = true;
    this.dragStart(t, e);
  };

  n.dragStart = function (t, e) {
    this.emitEvent("dragStart", [t, e]);
  };

  n._dragMove = function (t, e, i) {
    if (!this.isDragging) {
      return;
    }

    this.dragMove(t, e, i);
  };

  n.dragMove = function (t, e, i) {
    t.preventDefault();
    this.emitEvent("dragMove", [t, e, i]);
  };

  n._dragEnd = function (t, e) {
    this.isDragging = false;
    setTimeout(function () {
      delete this.isPreventingClicks;
    }.bind(this));
    this.dragEnd(t, e);
  };

  n.dragEnd = function (t, e) {
    this.emitEvent("dragEnd", [t, e]);
  };

  n.onclick = function (t) {
    if (this.isPreventingClicks) {
      t.preventDefault();
    }
  };

  n._staticClick = function (t, e) {
    if (this.isIgnoringMouseUp && t.type == "mouseup") {
      return;
    }

    this.staticClick(t, e);

    if (t.type != "mouseup") {
      this.isIgnoringMouseUp = true;
      setTimeout(function () {
        delete this.isIgnoringMouseUp;
      }.bind(this), 400);
    }
  };

  n.staticClick = function (t, e) {
    this.emitEvent("staticClick", [t, e]);
  };

  i.getPointerPoint = e.getPointerPoint;
  return i;
});

(function (n, s) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/drag", ["./flickity", "unidragger/unidragger", "fizzy-ui-utils/utils"], function (t, e, i) {
      return s(n, t, e, i);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = s(n, require("./flickity"), require("unidragger"), require("fizzy-ui-utils"));
  } else {
    n.Flickity = s(n, n.Flickity, n.Unidragger, n.fizzyUIUtils);
  }
})(window, function t(n, e, i, a) {
  a.extend(e.defaults, {
    draggable: ">1",
    dragThreshold: 3
  });
  e.createMethods.push("_createDrag");
  var s = e.prototype;
  a.extend(s, i.prototype);
  s._touchActionValue = "pan-y";
  var r = ("createTouch" in document);
  var o = false;

  s._createDrag = function () {
    this.on("activate", this.onActivateDrag);
    this.on("uiChange", this._uiChangeDrag);
    this.on("deactivate", this.onDeactivateDrag);
    this.on("cellChange", this.updateDraggable);

    if (r && !o) {
      n.addEventListener("touchmove", function () {});
      o = true;
    }
  };

  s.onActivateDrag = function () {
    this.handles = [this.viewport];
    this.bindHandles();
    this.updateDraggable();
  };

  s.onDeactivateDrag = function () {
    this.unbindHandles();
    this.element.classList.remove("is-draggable");
  };

  s.updateDraggable = function () {
    if (this.options.draggable == ">1") {
      this.isDraggable = this.slides.length > 1;
    } else {
      this.isDraggable = this.options.draggable;
    }

    if (this.isDraggable) {
      this.element.classList.add("is-draggable");
    } else {
      this.element.classList.remove("is-draggable");
    }
  };

  s.bindDrag = function () {
    this.options.draggable = true;
    this.updateDraggable();
  };

  s.unbindDrag = function () {
    this.options.draggable = false;
    this.updateDraggable();
  };

  s._uiChangeDrag = function () {
    delete this.isFreeScrolling;
  };

  s.pointerDown = function (t, e) {
    if (!this.isDraggable) {
      this._pointerDownDefault(t, e);

      return;
    }

    var i = this.okayPointerDown(t);

    if (!i) {
      return;
    }

    this._pointerDownPreventDefault(t);

    this.pointerDownFocus(t);

    if (document.activeElement != this.element) {
      this.pointerDownBlur();
    }

    this.dragX = this.x;
    this.viewport.classList.add("is-pointer-down");
    this.pointerDownScroll = h();
    n.addEventListener("scroll", this);

    this._pointerDownDefault(t, e);
  };

  s._pointerDownDefault = function (t, e) {
    this.pointerDownPointer = {
      pageX: e.pageX,
      pageY: e.pageY
    };

    this._bindPostStartEvents(t);

    this.dispatchEvent("pointerDown", t, [e]);
  };

  var l = {
    INPUT: true,
    TEXTAREA: true,
    SELECT: true
  };

  s.pointerDownFocus = function (t) {
    var e = l[t.target.nodeName];

    if (!e) {
      this.focus();
    }
  };

  s._pointerDownPreventDefault = function (t) {
    var e = t.type == "touchstart";
    var i = t.pointerType == "touch";
    var n = l[t.target.nodeName];

    if (!e && !i && !n) {
      t.preventDefault();
    }
  };

  s.hasDragStarted = function (t) {
    return Math.abs(t.x) > this.options.dragThreshold;
  };

  s.pointerUp = function (t, e) {
    delete this.isTouchScrolling;
    this.viewport.classList.remove("is-pointer-down");
    this.dispatchEvent("pointerUp", t, [e]);

    this._dragPointerUp(t, e);
  };

  s.pointerDone = function () {
    n.removeEventListener("scroll", this);
    delete this.pointerDownScroll;
  };

  s.dragStart = function (t, e) {
    if (!this.isDraggable) {
      return;
    }

    this.dragStartPosition = this.x;
    this.startAnimation();
    n.removeEventListener("scroll", this);
    this.dispatchEvent("dragStart", t, [e]);
  };

  s.pointerMove = function (t, e) {
    var i = this._dragPointerMove(t, e);

    this.dispatchEvent("pointerMove", t, [e, i]);

    this._dragMove(t, e, i);
  };

  s.dragMove = function (t, e, i) {
    if (!this.isDraggable) {
      return;
    }

    t.preventDefault();
    this.previousDragX = this.dragX;
    var n = this.options.rightToLeft ? -1 : 1;

    if (this.options.wrapAround) {
      i.x %= this.slideableWidth;
    }

    var s = this.dragStartPosition + i.x * n;

    if (!this.options.wrapAround && this.slides.length) {
      var r = Math.max(-this.slides[0].target, this.dragStartPosition);
      s = s > r ? (s + r) * .5 : s;
      var o = Math.min(-this.getLastSlide().target, this.dragStartPosition);
      s = s < o ? (s + o) * .5 : s;
    }

    this.dragX = s;
    this.dragMoveTime = new Date();
    this.dispatchEvent("dragMove", t, [e, i]);
  };

  s.dragEnd = function (t, e) {
    if (!this.isDraggable) {
      return;
    }

    if (this.options.freeScroll) {
      this.isFreeScrolling = true;
    }

    var i = this.dragEndRestingSelect();

    if (this.options.freeScroll && !this.options.wrapAround) {
      var n = this.getRestingPosition();
      this.isFreeScrolling = -n > this.slides[0].target && -n < this.getLastSlide().target;
    } else if (!this.options.freeScroll && i == this.selectedIndex) {
      i += this.dragEndBoostSelect();
    }

    delete this.previousDragX;
    this.isDragSelect = this.options.wrapAround;
    this.select(i);
    delete this.isDragSelect;
    this.dispatchEvent("dragEnd", t, [e]);
  };

  s.dragEndRestingSelect = function () {
    var t = this.getRestingPosition();
    var e = Math.abs(this.getSlideDistance(-t, this.selectedIndex));

    var i = this._getClosestResting(t, e, 1);

    var n = this._getClosestResting(t, e, -1);

    var s = i.distance < n.distance ? i.index : n.index;
    return s;
  };

  s._getClosestResting = function (t, e, i) {
    var n = this.selectedIndex;
    var s = Infinity;
    var r = this.options.contain && !this.options.wrapAround ? function (t, e) {
      return t <= e;
    } : function (t, e) {
      return t < e;
    };

    while (r(e, s)) {
      n += i;
      s = e;
      e = this.getSlideDistance(-t, n);

      if (e === null) {
        break;
      }

      e = Math.abs(e);
    }

    return {
      distance: s,
      index: n - i
    };
  };

  s.getSlideDistance = function (t, e) {
    var i = this.slides.length;
    var n = this.options.wrapAround && i > 1;
    var s = n ? a.modulo(e, i) : e;
    var r = this.slides[s];

    if (!r) {
      return null;
    }

    var o = n ? this.slideableWidth * Math.floor(e / i) : 0;
    return t - (r.target + o);
  };

  s.dragEndBoostSelect = function () {
    if (this.previousDragX === undefined || !this.dragMoveTime || new Date() - this.dragMoveTime > 100) {
      return 0;
    }

    var t = this.getSlideDistance(-this.dragX, this.selectedIndex);
    var e = this.previousDragX - this.dragX;

    if (t > 0 && e > 0) {
      return 1;
    } else if (t < 0 && e < 0) {
      return -1;
    }

    return 0;
  };

  s.staticClick = function (t, e) {
    var i = this.getParentCell(t.target);
    var n = i && i.element;
    var s = i && this.cells.indexOf(i);
    this.dispatchEvent("staticClick", t, [e, n, s]);
  };

  s.onscroll = function () {
    var t = h();
    var e = this.pointerDownScroll.x - t.x;
    var i = this.pointerDownScroll.y - t.y;

    if (Math.abs(e) > 3 || Math.abs(i) > 3) {
      this._pointerDone();
    }
  };

  function h() {
    return {
      x: n.pageXOffset,
      y: n.pageYOffset
    };
  }

  return e;
});

(function (n, s) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/prev-next-button", ["./flickity", "unipointer/unipointer", "fizzy-ui-utils/utils"], function (t, e, i) {
      return s(n, t, e, i);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = s(n, require("./flickity"), require("unipointer"), require("fizzy-ui-utils"));
  } else {
    s(n, n.Flickity, n.Unipointer, n.fizzyUIUtils);
  }
})(window, function t(e, i, n, s) {
  "use strict";

  var r = "http://www.w3.org/2000/svg";

  function o(t, e) {
    this.direction = t;
    this.parent = e;

    this._create();
  }

  o.prototype = Object.create(n.prototype);

  o.prototype._create = function () {
    this.isEnabled = true;
    this.isPrevious = this.direction == -1;
    var t = this.parent.options.rightToLeft ? 1 : -1;
    this.isLeft = this.direction == t;
    var e = this.element = document.createElement("button");
    e.className = "flickity-button flickity-prev-next-button";
    e.className += this.isPrevious ? " previous" : " next";
    e.setAttribute("type", "button");
    this.disable();
    e.setAttribute("aria-label", this.isPrevious ? "Previous" : "Next");
    var i = this.createSVG();
    e.appendChild(i);
    this.parent.on("select", this.update.bind(this));
    this.on("pointerDown", this.parent.childUIPointerDown.bind(this.parent));
  };

  o.prototype.activate = function () {
    this.bindStartEvent(this.element);
    this.element.addEventListener("click", this);
    this.parent.element.appendChild(this.element);
  };

  o.prototype.deactivate = function () {
    this.parent.element.removeChild(this.element);
    this.unbindStartEvent(this.element);
    this.element.removeEventListener("click", this);
  };

  o.prototype.createSVG = function () {
    var t = document.createElementNS(r, "svg");
    t.setAttribute("class", "flickity-button-icon");
    t.setAttribute("viewBox", "0 0 100 100");
    var e = document.createElementNS(r, "path");
    var i = a(this.parent.options.arrowShape);
    e.setAttribute("d", i);
    e.setAttribute("class", "arrow");

    if (!this.isLeft) {
      e.setAttribute("transform", "translate(100, 100) rotate(180) ");
    }

    t.appendChild(e);
    return t;
  };

  function a(t) {
    if (typeof t == "string") {
      return t;
    }

    return "M " + t.x0 + ",50" + " L " + t.x1 + "," + (t.y1 + 50) + " L " + t.x2 + "," + (t.y2 + 50) + " L " + t.x3 + ",50 " + " L " + t.x2 + "," + (50 - t.y2) + " L " + t.x1 + "," + (50 - t.y1) + " Z";
  }

  o.prototype.handleEvent = s.handleEvent;

  o.prototype.onclick = function () {
    if (!this.isEnabled) {
      return;
    }

    this.parent.uiChange();
    var t = this.isPrevious ? "previous" : "next";
    this.parent[t]();
  };

  o.prototype.enable = function () {
    if (this.isEnabled) {
      return;
    }

    this.element.disabled = false;
    this.isEnabled = true;
  };

  o.prototype.disable = function () {
    if (!this.isEnabled) {
      return;
    }

    this.element.disabled = true;
    this.isEnabled = false;
  };

  o.prototype.update = function () {
    var t = this.parent.slides;

    if (this.parent.options.wrapAround && t.length > 1) {
      this.enable();
      return;
    }

    var e = t.length ? t.length - 1 : 0;
    var i = this.isPrevious ? 0 : e;
    var n = this.parent.selectedIndex == i ? "disable" : "enable";
    this[n]();
  };

  o.prototype.destroy = function () {
    this.deactivate();
    this.allOff();
  };

  s.extend(i.defaults, {
    prevNextButtons: true,
    arrowShape: {
      x0: 10,
      x1: 60,
      y1: 50,
      x2: 70,
      y2: 40,
      x3: 30
    }
  });
  i.createMethods.push("_createPrevNextButtons");
  var l = i.prototype;

  l._createPrevNextButtons = function () {
    if (!this.options.prevNextButtons) {
      return;
    }

    this.prevButton = new o(-1, this);
    this.nextButton = new o(1, this);
    this.on("activate", this.activatePrevNextButtons);
  };

  l.activatePrevNextButtons = function () {
    this.prevButton.activate();
    this.nextButton.activate();
    this.on("deactivate", this.deactivatePrevNextButtons);
  };

  l.deactivatePrevNextButtons = function () {
    this.prevButton.deactivate();
    this.nextButton.deactivate();
    this.off("deactivate", this.deactivatePrevNextButtons);
  };

  i.PrevNextButton = o;
  return i;
});

(function (n, s) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/page-dots", ["./flickity", "unipointer/unipointer", "fizzy-ui-utils/utils"], function (t, e, i) {
      return s(n, t, e, i);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = s(n, require("./flickity"), require("unipointer"), require("fizzy-ui-utils"));
  } else {
    s(n, n.Flickity, n.Unipointer, n.fizzyUIUtils);
  }
})(window, function t(e, i, n, s) {
  function r(t) {
    this.parent = t;

    this._create();
  }

  r.prototype = Object.create(n.prototype);

  r.prototype._create = function () {
    this.holder = document.createElement("ol");
    this.holder.className = "flickity-page-dots";
    this.dots = [];
    this.handleClick = this.onClick.bind(this);
    this.on("pointerDown", this.parent.childUIPointerDown.bind(this.parent));
  };

  r.prototype.activate = function () {
    this.setDots();
    this.holder.addEventListener("click", this.handleClick);
    this.bindStartEvent(this.holder);
    this.parent.element.appendChild(this.holder);
  };

  r.prototype.deactivate = function () {
    this.holder.removeEventListener("click", this.handleClick);
    this.unbindStartEvent(this.holder);
    this.parent.element.removeChild(this.holder);
  };

  r.prototype.setDots = function () {
    var t = this.parent.slides.length - this.dots.length;

    if (t > 0) {
      this.addDots(t);
    } else if (t < 0) {
      this.removeDots(-t);
    }
  };

  r.prototype.addDots = function (t) {
    var e = document.createDocumentFragment();
    var i = [];
    var n = this.dots.length;
    var s = n + t;

    for (var r = n; r < s; r++) {
      var o = document.createElement("li");
      o.className = "dot";
      o.setAttribute("aria-label", "Page dot " + (r + 1));
      e.appendChild(o);
      i.push(o);
    }

    this.holder.appendChild(e);
    this.dots = this.dots.concat(i);
  };

  r.prototype.removeDots = function (t) {
    var e = this.dots.splice(this.dots.length - t, t);
    e.forEach(function (t) {
      this.holder.removeChild(t);
    }, this);
  };

  r.prototype.updateSelected = function () {
    if (this.selectedDot) {
      this.selectedDot.className = "dot";
      this.selectedDot.removeAttribute("aria-current");
    }

    if (!this.dots.length) {
      return;
    }

    this.selectedDot = this.dots[this.parent.selectedIndex];
    this.selectedDot.className = "dot is-selected";
    this.selectedDot.setAttribute("aria-current", "step");
  };

  r.prototype.onTap = r.prototype.onClick = function (t) {
    var e = t.target;

    if (e.nodeName != "LI") {
      return;
    }

    this.parent.uiChange();
    var i = this.dots.indexOf(e);
    this.parent.select(i);
  };

  r.prototype.destroy = function () {
    this.deactivate();
    this.allOff();
  };

  i.PageDots = r;
  s.extend(i.defaults, {
    pageDots: true
  });
  i.createMethods.push("_createPageDots");
  var o = i.prototype;

  o._createPageDots = function () {
    if (!this.options.pageDots) {
      return;
    }

    this.pageDots = new r(this);
    this.on("activate", this.activatePageDots);
    this.on("select", this.updateSelectedPageDots);
    this.on("cellChange", this.updatePageDots);
    this.on("resize", this.updatePageDots);
    this.on("deactivate", this.deactivatePageDots);
  };

  o.activatePageDots = function () {
    this.pageDots.activate();
  };

  o.updateSelectedPageDots = function () {
    this.pageDots.updateSelected();
  };

  o.updatePageDots = function () {
    this.pageDots.setDots();
  };

  o.deactivatePageDots = function () {
    this.pageDots.deactivate();
  };

  i.PageDots = r;
  return i;
});

(function (t, n) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/player", ["ev-emitter/ev-emitter", "fizzy-ui-utils/utils", "./flickity"], function (t, e, i) {
      return n(t, e, i);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = n(require("ev-emitter"), require("fizzy-ui-utils"), require("./flickity"));
  } else {
    n(t.EvEmitter, t.fizzyUIUtils, t.Flickity);
  }
})(window, function t(e, i, n) {
  function s(t) {
    this.parent = t;
    this.state = "stopped";
    this.onVisibilityChange = this.visibilityChange.bind(this);
    this.onVisibilityPlay = this.visibilityPlay.bind(this);
  }

  s.prototype = Object.create(e.prototype);

  s.prototype.play = function () {
    if (this.state == "playing") {
      return;
    }

    var t = document.hidden;

    if (t) {
      document.addEventListener("visibilitychange", this.onVisibilityPlay);
      return;
    }

    this.state = "playing";
    document.addEventListener("visibilitychange", this.onVisibilityChange);
    this.tick();
  };

  s.prototype.tick = function () {
    if (this.state != "playing") {
      return;
    }

    var t = this.parent.options.autoPlay;
    t = typeof t == "number" ? t : 3e3;
    var e = this;
    this.clear();
    this.timeout = setTimeout(function () {
      e.parent.next(true);
      e.tick();
    }, t);
  };

  s.prototype.stop = function () {
    this.state = "stopped";
    this.clear();
    document.removeEventListener("visibilitychange", this.onVisibilityChange);
  };

  s.prototype.clear = function () {
    clearTimeout(this.timeout);
  };

  s.prototype.pause = function () {
    if (this.state == "playing") {
      this.state = "paused";
      this.clear();
    }
  };

  s.prototype.unpause = function () {
    if (this.state == "paused") {
      this.play();
    }
  };

  s.prototype.visibilityChange = function () {
    var t = document.hidden;
    this[t ? "pause" : "unpause"]();
  };

  s.prototype.visibilityPlay = function () {
    this.play();
    document.removeEventListener("visibilitychange", this.onVisibilityPlay);
  };

  i.extend(n.defaults, {
    pauseAutoPlayOnHover: true
  });
  n.createMethods.push("_createPlayer");
  var r = n.prototype;

  r._createPlayer = function () {
    this.player = new s(this);
    this.on("activate", this.activatePlayer);
    this.on("uiChange", this.stopPlayer);
    this.on("pointerDown", this.stopPlayer);
    this.on("deactivate", this.deactivatePlayer);
  };

  r.activatePlayer = function () {
    if (!this.options.autoPlay) {
      return;
    }

    this.player.play();
    this.element.addEventListener("mouseenter", this);
  };

  r.playPlayer = function () {
    this.player.play();
  };

  r.stopPlayer = function () {
    this.player.stop();
  };

  r.pausePlayer = function () {
    this.player.pause();
  };

  r.unpausePlayer = function () {
    this.player.unpause();
  };

  r.deactivatePlayer = function () {
    this.player.stop();
    this.element.removeEventListener("mouseenter", this);
  };

  r.onmouseenter = function () {
    if (!this.options.pauseAutoPlayOnHover) {
      return;
    }

    this.player.pause();
    this.element.addEventListener("mouseleave", this);
  };

  r.onmouseleave = function () {
    this.player.unpause();
    this.element.removeEventListener("mouseleave", this);
  };

  n.Player = s;
  return n;
});

(function (i, n) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/add-remove-cell", ["./flickity", "fizzy-ui-utils/utils"], function (t, e) {
      return n(i, t, e);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = n(i, require("./flickity"), require("fizzy-ui-utils"));
  } else {
    n(i, i.Flickity, i.fizzyUIUtils);
  }
})(window, function t(e, i, n) {
  function l(t) {
    var e = document.createDocumentFragment();
    t.forEach(function (t) {
      e.appendChild(t.element);
    });
    return e;
  }

  var s = i.prototype;

  s.insert = function (t, e) {
    var i = this._makeCells(t);

    if (!i || !i.length) {
      return;
    }

    var n = this.cells.length;
    e = e === undefined ? n : e;
    var s = l(i);
    var r = e == n;

    if (r) {
      this.slider.appendChild(s);
    } else {
      var o = this.cells[e].element;
      this.slider.insertBefore(s, o);
    }

    if (e === 0) {
      this.cells = i.concat(this.cells);
    } else if (r) {
      this.cells = this.cells.concat(i);
    } else {
      var a = this.cells.splice(e, n - e);
      this.cells = this.cells.concat(i).concat(a);
    }

    this._sizeCells(i);

    this.cellChange(e, true);
  };

  s.append = function (t) {
    this.insert(t, this.cells.length);
  };

  s.prepend = function (t) {
    this.insert(t, 0);
  };

  s.remove = function (t) {
    var e = this.getCells(t);

    if (!e || !e.length) {
      return;
    }

    var i = this.cells.length - 1;
    e.forEach(function (t) {
      t.remove();
      var e = this.cells.indexOf(t);
      i = Math.min(e, i);
      n.removeFrom(this.cells, t);
    }, this);
    this.cellChange(i, true);
  };

  s.cellSizeChange = function (t) {
    var e = this.getCell(t);

    if (!e) {
      return;
    }

    e.getSize();
    var i = this.cells.indexOf(e);
    this.cellChange(i);
  };

  s.cellChange = function (t, e) {
    var i = this.selectedElement;

    this._positionCells(t);

    this._getWrapShiftCells();

    this.setGallerySize();
    var n = this.getCell(i);

    if (n) {
      this.selectedIndex = this.getCellSlideIndex(n);
    }

    this.selectedIndex = Math.min(this.slides.length - 1, this.selectedIndex);
    this.emitEvent("cellChange", [t]);
    this.select(this.selectedIndex);

    if (e) {
      this.positionSliderAtSelected();
    }
  };

  return i;
});

(function (i, n) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/lazyload", ["./flickity", "fizzy-ui-utils/utils"], function (t, e) {
      return n(i, t, e);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = n(i, require("./flickity"), require("fizzy-ui-utils"));
  } else {
    n(i, i.Flickity, i.fizzyUIUtils);
  }
})(window, function t(e, i, o) {
  "use strict";

  i.createMethods.push("_createLazyload");
  var n = i.prototype;

  n._createLazyload = function () {
    this.on("select", this.lazyLoad);
  };

  n.lazyLoad = function () {
    var t = this.options.lazyLoad;

    if (!t) {
      return;
    }

    var e = typeof t == "number" ? t : 0;
    var i = this.getAdjacentCellElements(e);
    var n = [];
    i.forEach(function (t) {
      var e = s(t);
      n = n.concat(e);
    });
    n.forEach(function (t) {
      new r(t, this);
    }, this);
  };

  function s(t) {
    if (t.nodeName == "IMG") {
      var e = t.getAttribute("data-flickity-lazyload");
      var i = t.getAttribute("data-flickity-lazyload-src");
      var n = t.getAttribute("data-flickity-lazyload-srcset");

      if (e || i || n) {
        return [t];
      }
    }

    var s = "img[data-flickity-lazyload], " + "img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]";
    var r = t.querySelectorAll(s);
    return o.makeArray(r);
  }

  function r(t, e) {
    this.img = t;
    this.flickity = e;
    this.load();
  }

  r.prototype.handleEvent = o.handleEvent;

  r.prototype.load = function () {
    this.img.addEventListener("load", this);
    this.img.addEventListener("error", this);
    var t = this.img.getAttribute("data-flickity-lazyload") || this.img.getAttribute("data-flickity-lazyload-src");
    var e = this.img.getAttribute("data-flickity-lazyload-srcset");
    this.img.src = t;

    if (e) {
      this.img.setAttribute("srcset", e);
    }

    this.img.removeAttribute("data-flickity-lazyload");
    this.img.removeAttribute("data-flickity-lazyload-src");
    this.img.removeAttribute("data-flickity-lazyload-srcset");
  };

  r.prototype.onload = function (t) {
    this.complete(t, "flickity-lazyloaded");
  };

  r.prototype.onerror = function (t) {
    this.complete(t, "flickity-lazyerror");
  };

  r.prototype.complete = function (t, e) {
    this.img.removeEventListener("load", this);
    this.img.removeEventListener("error", this);
    var i = this.flickity.getParentCell(this.img);
    var n = i && i.element;
    this.flickity.cellSizeChange(n);
    this.img.classList.add(e);
    this.flickity.dispatchEvent("lazyLoad", t, n);
  };

  i.LazyLoader = r;
  return i;
});
/*!
 * Flickity v2.2.2
 * Touch, responsive, flickable carousels
 *
 * Licensed GPLv3 for open source use
 * or Flickity Commercial License for commercial use
 *
 * https://flickity.metafizzy.co
 * Copyright 2015-2021 Metafizzy
 */


(function (t, e) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/index", ["./flickity", "./drag", "./prev-next-button", "./page-dots", "./player", "./add-remove-cell", "./lazyload"], e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e(require("./flickity"), require("./drag"), require("./prev-next-button"), require("./page-dots"), require("./player"), require("./add-remove-cell"), require("./lazyload"));
  }
})(window, function t(e) {
  return e;
});
/*!
 * Flickity asNavFor v2.0.2
 * enable asNavFor for Flickity
 */


(function (t, e) {
  if (typeof define == "function" && define.amd) {
    define("flickity-as-nav-for/as-nav-for", ["flickity/js/index", "fizzy-ui-utils/utils"], e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e(require("flickity"), require("fizzy-ui-utils"));
  } else {
    t.Flickity = e(t.Flickity, t.fizzyUIUtils);
  }
})(window, function t(n, s) {
  n.createMethods.push("_createAsNavFor");
  var e = n.prototype;

  e._createAsNavFor = function () {
    this.on("activate", this.activateAsNavFor);
    this.on("deactivate", this.deactivateAsNavFor);
    this.on("destroy", this.destroyAsNavFor);
    var e = this.options.asNavFor;

    if (!e) {
      return;
    }

    var i = this;
    setTimeout(function t() {
      i.setNavCompanion(e);
    });
  };

  e.setNavCompanion = function (t) {
    t = s.getQueryElement(t);
    var e = n.data(t);

    if (!e || e == this) {
      return;
    }

    this.navCompanion = e;
    var i = this;

    this.onNavCompanionSelect = function () {
      i.navCompanionSelect();
    };

    e.on("select", this.onNavCompanionSelect);
    this.on("staticClick", this.onNavStaticClick);
    this.navCompanionSelect(true);
  };

  e.navCompanionSelect = function (t) {
    var e = this.navCompanion && this.navCompanion.selectedCells;

    if (!e) {
      return;
    }

    var i = e[0];
    var n = this.navCompanion.cells.indexOf(i);
    var s = n + e.length - 1;
    var r = Math.floor(a(n, s, this.navCompanion.cellAlign));
    this.selectCell(r, false, t);
    this.removeNavSelectedElements();

    if (r >= this.cells.length) {
      return;
    }

    var o = this.cells.slice(n, s + 1);
    this.navSelectedElements = o.map(function (t) {
      return t.element;
    });
    this.changeNavSelectedClass("add");
  };

  function a(t, e, i) {
    return (e - t) * i + t;
  }

  e.changeNavSelectedClass = function (e) {
    this.navSelectedElements.forEach(function (t) {
      t.classList[e]("is-nav-selected");
    });
  };

  e.activateAsNavFor = function () {
    this.navCompanionSelect(true);
  };

  e.removeNavSelectedElements = function () {
    if (!this.navSelectedElements) {
      return;
    }

    this.changeNavSelectedClass("remove");
    delete this.navSelectedElements;
  };

  e.onNavStaticClick = function (t, e, i, n) {
    if (typeof n == "number") {
      this.navCompanion.selectCell(n);
    }
  };

  e.deactivateAsNavFor = function () {
    this.removeNavSelectedElements();
  };

  e.destroyAsNavFor = function () {
    if (!this.navCompanion) {
      return;
    }

    this.navCompanion.off("select", this.onNavCompanionSelect);
    this.off("staticClick", this.onNavStaticClick);
    delete this.navCompanion;
  };

  return n;
});
/*!
 * imagesLoaded v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */


(function (e, i) {
  "use strict";

  if (typeof define == "function" && define.amd) {
    define("imagesloaded/imagesloaded", ["ev-emitter/ev-emitter"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("ev-emitter"));
  } else {
    e.imagesLoaded = i(e, e.EvEmitter);
  }
})(typeof window !== "undefined" ? window : this, function t(e, i) {
  var s = e.jQuery;
  var r = e.console;

  function o(t, e) {
    for (var i in e) {
      t[i] = e[i];
    }

    return t;
  }

  var n = Array.prototype.slice;

  function a(t) {
    if (Array.isArray(t)) {
      return t;
    }

    var e = typeof t == "object" && typeof t.length == "number";

    if (e) {
      return n.call(t);
    }

    return [t];
  }

  function l(t, e, i) {
    if (!(this instanceof l)) {
      return new l(t, e, i);
    }

    var n = t;

    if (typeof t == "string") {
      n = document.querySelectorAll(t);
    }

    if (!n) {
      r.error("Bad element for imagesLoaded " + (n || t));
      return;
    }

    this.elements = a(n);
    this.options = o({}, this.options);

    if (typeof e == "function") {
      i = e;
    } else {
      o(this.options, e);
    }

    if (i) {
      this.on("always", i);
    }

    this.getImages();

    if (s) {
      this.jqDeferred = new s.Deferred();
    }

    setTimeout(this.check.bind(this));
  }

  l.prototype = Object.create(i.prototype);
  l.prototype.options = {};

  l.prototype.getImages = function () {
    this.images = [];
    this.elements.forEach(this.addElementImages, this);
  };

  l.prototype.addElementImages = function (t) {
    if (t.nodeName == "IMG") {
      this.addImage(t);
    }

    if (this.options.background === true) {
      this.addElementBackgroundImages(t);
    }

    var e = t.nodeType;

    if (!e || !h[e]) {
      return;
    }

    var i = t.querySelectorAll("img");

    for (var n = 0; n < i.length; n++) {
      var s = i[n];
      this.addImage(s);
    }

    if (typeof this.options.background == "string") {
      var r = t.querySelectorAll(this.options.background);

      for (n = 0; n < r.length; n++) {
        var o = r[n];
        this.addElementBackgroundImages(o);
      }
    }
  };

  var h = {
    1: true,
    9: true,
    11: true
  };

  l.prototype.addElementBackgroundImages = function (t) {
    var e = getComputedStyle(t);

    if (!e) {
      return;
    }

    var i = /url\((['"])?(.*?)\1\)/gi;
    var n = i.exec(e.backgroundImage);

    while (n !== null) {
      var s = n && n[2];

      if (s) {
        this.addBackground(s, t);
      }

      n = i.exec(e.backgroundImage);
    }
  };

  l.prototype.addImage = function (t) {
    var e = new c(t);
    this.images.push(e);
  };

  l.prototype.addBackground = function (t, e) {
    var i = new u(t, e);
    this.images.push(i);
  };

  l.prototype.check = function () {
    var n = this;
    this.progressedCount = 0;
    this.hasAnyBroken = false;

    if (!this.images.length) {
      this.complete();
      return;
    }

    function e(t, e, i) {
      setTimeout(function () {
        n.progress(t, e, i);
      });
    }

    this.images.forEach(function (t) {
      t.once("progress", e);
      t.check();
    });
  };

  l.prototype.progress = function (t, e, i) {
    this.progressedCount++;
    this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded;
    this.emitEvent("progress", [this, t, e]);

    if (this.jqDeferred && this.jqDeferred.notify) {
      this.jqDeferred.notify(this, t);
    }

    if (this.progressedCount == this.images.length) {
      this.complete();
    }

    if (this.options.debug && r) {
      r.log("progress: " + i, t, e);
    }
  };

  l.prototype.complete = function () {
    var t = this.hasAnyBroken ? "fail" : "done";
    this.isComplete = true;
    this.emitEvent(t, [this]);
    this.emitEvent("always", [this]);

    if (this.jqDeferred) {
      var e = this.hasAnyBroken ? "reject" : "resolve";
      this.jqDeferred[e](this);
    }
  };

  function c(t) {
    this.img = t;
  }

  c.prototype = Object.create(i.prototype);

  c.prototype.check = function () {
    var t = this.getIsImageComplete();

    if (t) {
      this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
      return;
    }

    this.proxyImage = new Image();
    this.proxyImage.addEventListener("load", this);
    this.proxyImage.addEventListener("error", this);
    this.img.addEventListener("load", this);
    this.img.addEventListener("error", this);
    this.proxyImage.src = this.img.src;
  };

  c.prototype.getIsImageComplete = function () {
    return this.img.complete && this.img.naturalWidth;
  };

  c.prototype.confirm = function (t, e) {
    this.isLoaded = t;
    this.emitEvent("progress", [this, this.img, e]);
  };

  c.prototype.handleEvent = function (t) {
    var e = "on" + t.type;

    if (this[e]) {
      this[e](t);
    }
  };

  c.prototype.onload = function () {
    this.confirm(true, "onload");
    this.unbindEvents();
  };

  c.prototype.onerror = function () {
    this.confirm(false, "onerror");
    this.unbindEvents();
  };

  c.prototype.unbindEvents = function () {
    this.proxyImage.removeEventListener("load", this);
    this.proxyImage.removeEventListener("error", this);
    this.img.removeEventListener("load", this);
    this.img.removeEventListener("error", this);
  };

  function u(t, e) {
    this.url = t;
    this.element = e;
    this.img = new Image();
  }

  u.prototype = Object.create(c.prototype);

  u.prototype.check = function () {
    this.img.addEventListener("load", this);
    this.img.addEventListener("error", this);
    this.img.src = this.url;
    var t = this.getIsImageComplete();

    if (t) {
      this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
      this.unbindEvents();
    }
  };

  u.prototype.unbindEvents = function () {
    this.img.removeEventListener("load", this);
    this.img.removeEventListener("error", this);
  };

  u.prototype.confirm = function (t, e) {
    this.isLoaded = t;
    this.emitEvent("progress", [this, this.element, e]);
  };

  l.makeJQueryPlugin = function (t) {
    t = t || e.jQuery;

    if (!t) {
      return;
    }

    s = t;

    s.fn.imagesLoaded = function (t, e) {
      var i = new l(this, t, e);
      return i.jqDeferred.promise(s(this));
    };
  };

  l.makeJQueryPlugin();
  return l;
});
/*!
 * Flickity imagesLoaded v2.0.0
 * enables imagesLoaded option for Flickity
 */


(function (i, n) {
  if (typeof define == "function" && define.amd) {
    define(["flickity/js/index", "imagesloaded/imagesloaded"], function (t, e) {
      return n(i, t, e);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = n(i, require("flickity"), require("imagesloaded"));
  } else {
    i.Flickity = n(i, i.Flickity, i.imagesLoaded);
  }
})(window, function t(e, i, s) {
  "use strict";

  i.createMethods.push("_createImagesLoaded");
  var n = i.prototype;

  n._createImagesLoaded = function () {
    this.on("activate", this.imagesLoaded);
  };

  n.imagesLoaded = function () {
    if (!this.options.imagesLoaded) {
      return;
    }

    var n = this;

    function t(t, e) {
      var i = n.getParentCell(e.img);
      n.cellSizeChange(i && i.element);

      if (!n.options.freeScroll) {
        n.positionSliderAtSelected();
      }
    }

    s(this.slider).on("progress", t);
  };

  return i;
});
!function (root, factory) {
  "function" == typeof define && define.amd ? // AMD. Register as an anonymous module unless amdModuleId is set
  define([], function () {
    return root.svg4everybody = factory();
  }) : "object" == typeof module && module.exports ? // Node. Does not work with strict CommonJS, but
  // only CommonJS-like environments that support module.exports,
  // like Node.
  module.exports = factory() : root.svg4everybody = factory();
}(this, function () {
  /*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody */
  function embed(parent, svg, target) {
    // if the target exists
    if (target) {
      // create a document fragment to hold the contents of the target
      var fragment = document.createDocumentFragment(),
          viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox"); // conditionally set the viewBox on the svg

      viewBox && svg.setAttribute("viewBox", viewBox); // copy the contents of the clone into the fragment

      for ( // clone the target
      var clone = target.cloneNode(!0); clone.childNodes.length;) {
        fragment.appendChild(clone.firstChild);
      } // append the fragment into the svg


      parent.appendChild(fragment);
    }
  }

  function loadreadystatechange(xhr) {
    // listen to changes in the request
    xhr.onreadystatechange = function () {
      // if the request is ready
      if (4 === xhr.readyState) {
        // get the cached html document
        var cachedDocument = xhr._cachedDocument; // ensure the cached html document based on the xhr response

        cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}), // clear the xhr embeds list and embed each item
        xhr._embeds.splice(0).map(function (item) {
          // get the cached target
          var target = xhr._cachedTarget[item.id]; // ensure the cached target

          target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)), // embed the target into the svg
          embed(item.parent, item.svg, target);
        });
      }
    }, // test the ready state change immediately
    xhr.onreadystatechange();
  }

  function svg4everybody(rawopts) {
    function oninterval() {
      // while the index exists in the live <use> collection
      for ( // get the cached <use> index
      var index = 0; index < uses.length;) {
        // get the current <use>
        var use = uses[index],
            parent = use.parentNode,
            svg = getSVGAncestor(parent),
            src = use.getAttribute("xlink:href") || use.getAttribute("href");

        if (!src && opts.attributeName && (src = use.getAttribute(opts.attributeName)), svg && src) {
          if (polyfill) {
            if (!opts.validate || opts.validate(src, svg, use)) {
              // remove the <use> element
              parent.removeChild(use); // parse the src and get the url and id

              var srcSplit = src.split("#"),
                  url = srcSplit.shift(),
                  id = srcSplit.join("#"); // if the link is external

              if (url.length) {
                // get the cached xhr request
                var xhr = requests[url]; // ensure the xhr request exists

                xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), xhr._embeds = []), // add the svg and id as an item to the xhr embeds list
                xhr._embeds.push({
                  parent: parent,
                  svg: svg,
                  id: id
                }), // prepare the xhr ready state change event
                loadreadystatechange(xhr);
              } else {
                // embed the local id into the svg
                embed(parent, svg, document.getElementById(id));
              }
            } else {
              // increase the index when the previous value was not "valid"
              ++index, ++numberOfSvgUseElementsToBypass;
            }
          }
        } else {
          // increase the index when the previous value was not "valid"
          ++index;
        }
      } // continue the interval


      (!uses.length || uses.length - numberOfSvgUseElementsToBypass > 0) && requestAnimationFrame(oninterval, 67);
    }

    var polyfill,
        opts = Object(rawopts),
        newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/,
        webkitUA = /\bAppleWebKit\/(\d+)\b/,
        olderEdgeUA = /\bEdge\/12\.(\d+)\b/,
        edgeUA = /\bEdge\/.(\d+)\b/,
        inIframe = window.top !== window.self;
    polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537 || edgeUA.test(navigator.userAgent) && inIframe; // create xhr requests object

    var requests = {},
        requestAnimationFrame = window.requestAnimationFrame || setTimeout,
        uses = document.getElementsByTagName("use"),
        numberOfSvgUseElementsToBypass = 0; // conditionally start the interval if the polyfill is active

    polyfill && oninterval();
  }

  function getSVGAncestor(node) {
    for (var svg = node; "svg" !== svg.nodeName.toLowerCase() && (svg = svg.parentNode);) {}

    return svg;
  }

  return svg4everybody;
});
// document.addEventListener('DOMContentLoaded', function(){});
(function () {
  // Добавление/удаление модификаторов при клике на переключение видимости
  var toggler = document.getElementById('burger');

  if (toggler) {
    toggler.addEventListener('click', mobNavVisibleToggle);

    function mobNavVisibleToggle(e) {
      e.preventDefault(); //toggler.classList.toggle('burger--close'); // модификатор иконки (должен быть .burger)
      //document.getElementById('main-nav').classList.toggle('main-nav--open');
    }
  }
})();
/*(function() {
  window.cookieconsent.initialise({
    "palette": {
      "popup": {
        "background": "#ffffff",
        "text": "#020406"
      },
      "button": {
        "background": "#1870b7",
        "text": "#ffffff"
      }
    },
    "position": "bottom-right",
    "content": {
      "message": "Этот сайт использует файлы cookie в соответствии с <a href='https://www.cookiesandyou.com/'>Политикой использования файлов cookie</a>. Если Вы согласны на использование нами файлов cookie, то нажмите кнопку «Принять».",
      "dismiss": "Принять!",
      "link": "Подробнее"
    }
  });
})();
*/
// (function(){
//   const langSwitcher = document.getElementById('lang-switcher');
//   let togglerBtn = document.getElementById('lang-switcher-toggler');
//   let page = document.documentElement;
//   let lang = page.lang;
//   if (langSwitcher) {
//     const langChangeHandler = function (e) {
//       togglerBtn.innerHTML = lang;
//     }();
//   }
// }());
/*(function (){
  const mainNav = document.getElementById('main-nav');
  const menuItemArr = mainNav.querySelectorAll('.main-nav__list>.main-nav__item');
  const activeClass = 'active';
  const linkArrowClass = 'main-nav__link--arrow';

  for (let i = 0; i < menuItemArr.length; i++) {
    let currentItem = menuItemArr[i];
    let currentItemFirstChild = currentItem.firstChild.nextSibling;
    if ( currentItem.classList.contains(activeClass) && currentItemFirstChild.classList.contains(linkArrowClass) ) {
      mainNav.classList.add('main-nav--bot-margin');
    }
  }
})()*/
(function () {
  let new_scroll_position = 0;
  let last_scroll_position;
  const header = document.getElementById('header');
  window.addEventListener('scroll', function (e) {
    last_scroll_position = window.scrollY; // Scrolling down

    if (new_scroll_position < last_scroll_position && last_scroll_position > 80) {
      // header.removeClass('slideDown').addClass('slideUp');
      header.classList.remove('page-header--slideDown');
      header.classList.add('page-header--slideUp'); // Scrolling up
    } else if (new_scroll_position > last_scroll_position) {
      // header.removeClass('slideUp').addClass('slideDown');
      header.classList.remove('page-header--slideUp');
      header.classList.add('page-header--slideDown');
    }

    new_scroll_position = last_scroll_position;
  });
})();
document.addEventListener('DOMContentLoaded', function () {
  (function () {
    // указатель на текущую страницу
    var pagination = document.querySelector('.pagination');
    var btns = document.querySelectorAll('.pagination__item');
    Array.prototype.forEach.call(btns, function (item) {
      var link = item.children[0];

      if (item.classList.contains('active')) {
        link.setAttribute('aria-current', 'page');
      } else {
        link.removeAttribute('aria-current');
      }
    });
  })();
});
document.addEventListener('DOMContentLoaded', function () {
  var links = document.querySelectorAll('[href^="#"][data-scroll-link]');

  for (var i = 0; i < links.length; i++) {
    links[i].addEventListener('click', function (e) {
      var hash = this.href.replace(/[^#]*(.*)/, '$1');

      if (hash && hash !== '#') {
        e.preventDefault();
        var scroll = window.pageYOffset;
        var targetTop = getOffsetRect(document.querySelector(hash)).top - 10; // С поправкой в 10px

        var scrollDiff = (scroll - targetTop) * -1;
        animate({
          duration: 500,
          timing: function (timeFraction) {
            return Math.pow(timeFraction, 4); // https://learn.javascript.ru/js-animation
          },
          draw: function (progress) {
            var scrollNow = scroll + progress * scrollDiff;
            window.scrollTo(0, scrollNow);
          }
        });
      }
    }, false);
  }

  function animate(_ref) {
    var timing = _ref.timing,
        draw = _ref.draw,
        duration = _ref.duration;
    var start = performance.now();
    requestAnimationFrame(function animate(time) {
      var timeFraction = (time - start) / duration;
      if (timeFraction > 1) timeFraction = 1;
      var progress = timing(timeFraction);
      draw(progress);

      if (timeFraction < 1) {
        requestAnimationFrame(animate);
      }
    });
  }

  function getOffsetRect(elem) {
    var box = elem.getBoundingClientRect();
    var body = document.body;
    var docElem = document.documentElement;
    var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
    var clientTop = docElem.clientTop || body.clientTop || 0;
    var clientLeft = docElem.clientLeft || body.clientLeft || 0;
    var top = box.top + scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;
    return {
      top: Math.round(top),
      left: Math.round(left)
    };
  }
});
svg4everybody();
// document.addEventListener('DOMContentLoaded', function(){});
(function () {
  const utils = window.fizzyUIUtils;
  const hero = document.querySelector('.main-carousel');

  if (!hero) {
    return;
  }

  const heroSlider = new Flickity(hero, {
    lazyLoad: true,
    cellAlign: 'center',
    contain: true,
    wrapAround: true,
    prevNextButtons: false,
    pageDots: false
  });
  const cellsButtonGroup = document.querySelector('.hero__dot-group--cells');
  const cellsButtons = utils.makeArray(cellsButtonGroup.children); // update buttons on select

  heroSlider.on('select', function () {
    const previousSelectedButton = cellsButtonGroup.querySelector('.is-selected');
    let selectedButton = cellsButtonGroup.children[heroSlider.selectedIndex];
    previousSelectedButton.classList.remove('is-selected');
    selectedButton.classList.add('is-selected');
  }); // cell select

  cellsButtonGroup.addEventListener('click', function (event) {
    if (!matchesSelector(event.target, '.hero__dot')) {
      return;
    }

    let index = cellsButtons.indexOf(event.target);
    heroSlider.select(index);
  }); // previous

  const previousButton = document.querySelector('.hero__btn--prev');
  previousButton.addEventListener('click', function () {
    heroSlider.previous();
  }); // next

  const nextButton = document.querySelector('.hero__btn--next');
  nextButton.addEventListener('click', function () {
    heroSlider.next();
  });
})();
// document.addEventListener('DOMContentLoaded', function(){});
//}());
(function () {
  const miniCartOverlay = document.getElementById('miniCartOverlay');
  const showCartBtn = document.getElementById('showCartBtn');
  const miniCart = document.getElementById('mini-cart');
  const body = document.querySelector('body');

  if (!miniCartOverlay) {
    return;
  }

  const bodyStyleHandler = function (e) {
    if (!body.hasAttribute('style')) {
      body.style = 'overflow:hidden;'; //console.log(true);
    } else {
      //console.log(false);
      body.removeAttribute('style');
    }
  };

  const clickOverlayHandler = function (e) {
    miniCart.classList.remove('show');
    showCartBtn.classList.add('collapsed');
    showCartBtn.setAttribute('aria-expanded', false);
    bodyStyleHandler();
  };

  miniCartOverlay.addEventListener('click', clickOverlayHandler);
  showCartBtn.addEventListener('click', bodyStyleHandler);
  document.addEventListener('keydown', function (e) {
    const key = e.key; // const {key} = event; in ES6+

    if (key === 'Escape' || e.keyCode === 27) {
      clickOverlayHandler(); //bodyStyleHandler();
    }
  });
})();
// document.addEventListener('DOMContentLoaded', function(){});
(function () {
  const clients = document.querySelector('.clients-slider__carousel');

  if (!clients) {
    return;
  }

  const heroSlider = new Flickity(clients, {
    lazyLoad: 3,
    autoPlay: 3500,
    cellAlign: 'center',
    percentPosition: false,
    //freeScroll: true,
    wrapAround: true,
    prevNextButtons: false,
    pageDots: false
  });
})();
// document.addEventListener('DOMContentLoaded', function(){});

/*(function(){
  // init Isotope
  const iso = new Isotope( '.grid', {
    itemSelector: '.grid-item',
    layoutMode: 'fitRows'
  });

  // filter functions
  var filterFns = {
    // show if number is greater than 50
    numberGreaterThan50: function( itemElem ) {
      var number = itemElem.querySelector('.number').textContent;
      return parseInt( number, 10 ) > 50;
    },
    // show if name ends with -ium
    ium: function( itemElem ) {
      var name = itemElem.querySelector('.name').textContent;
      return name.match( /ium$/ );
    }
  };

  // bind filter button click
  var filtersElem = document.querySelector('.btn-filter-group');
  filtersElem.addEventListener( 'click', function( event ) {
    // only work with buttons
    if ( !matchesSelector( event.target, 'button' ) ) {
      return;
    }
    var filterValue = event.target.getAttribute('data-filter');
    // use matching filter function
    filterValue = filterFns[ filterValue ] || filterValue;
    iso.arrange({ filter: filterValue });
  });

  // change is-checked class on buttons
  var buttonGroups = document.querySelectorAll('.btn-filter-group');
  for ( var i=0, len = buttonGroups.length; i < len; i++ ) {
    var buttonGroup = buttonGroups[i];
    radioButtonGroup( buttonGroup );
  }

  function radioButtonGroup( buttonGroup ) {
    buttonGroup.addEventListener( 'click', function( event ) {
      // only work with buttons
      if ( !matchesSelector( event.target, 'button' ) ) {
        return;
      }
      buttonGroup.querySelector('.is-checked').classList.remove('is-checked');
      event.target.classList.add('is-checked');
    });
  }

}());*/
(function () {
  // change is-checked class on buttons
  const buttonGroups = document.querySelectorAll('.btn-filter-group');
  const filteredElems = document.querySelectorAll('.grid-item');

  for (let i = 0; i < buttonGroups.length; i++) {
    var buttonGroup = buttonGroups[i];
    radioButtonGroup(buttonGroup);
  }

  function radioButtonGroup(buttonGroup) {
    buttonGroup.addEventListener('click', function (e) {
      let currentBtn = e.target; // only work with buttons

      if (!matchesSelector(currentBtn, 'button')) {
        return;
      }

      buttonGroup.querySelector('.is-checked').classList.remove('is-checked');
      currentBtn.classList.add('is-checked'); //console.log(`Кнопка: ${currentBtn.dataset.filter}`);

      for (let i = 0; i < filteredElems.length; i++) {
        let currentItem = filteredElems[i];

        if (!currentItem.matches(`.${currentBtn.dataset.filter}`)) {
          //currentItem.style = 'display:none;';
          currentItem.setAttribute('will-change', 'transform');
          currentItem.animate([// keyframes
          {
            transform: 'scale3d(1, 1, 1)'
          }, {
            transform: 'scale3d(0.3, 0.3, 0.3)'
          }], {
            // timing options
            duration: 150,
            iterations: 1
          });
          currentItem.style = 'display:none;';
          currentItem.removeAttribute('will-change');
        }

        if (currentItem.matches(`.${currentBtn.dataset.filter}`) || currentBtn.dataset.filter == 'all') {
          //console.log('Совпало');
          //currentItem.style = 'display:block;';
          currentItem.setAttribute('will-change', 'transform');
          currentItem.animate([// keyframes
          {
            transform: 'scale3d(0.3, 0.3, 0.3)'
          }, {
            transform: 'scale3d(1, 1, 1)'
          }], {
            // timing options
            duration: 150,
            iterations: 1
          });
          currentItem.style = 'display:block;';
          currentItem.removeAttribute('will-change');
        }
      }
    });
  }
})();

(function () {
  const cardsAll = document.querySelectorAll('.equipment-card');

  if (!cardsAll) {
    return;
  }

  for (let i = 0; i < cardsAll.length; i++) {
    const card = cardsAll[i];
    const moreBtn = card.querySelector('.btn--more');
    const returnBtn = card.querySelector('.btn--return');
    const flipElem = card.querySelector('.equipment-card__inner');

    const moreBtnClickHandler = function (e) {
      flipElem.classList.toggle('equipment-card__inner--backface');
    };

    if (moreBtn && returnBtn) {
      moreBtn.addEventListener('click', moreBtnClickHandler);
      returnBtn.addEventListener('click', moreBtnClickHandler);
    }
  }
})();
/*(function(){
  // Балансировка высоты колонок
  const gridElemAll = document.querySelectorAll('.grid-item');

  if (!gridElemAll) { return; }
  let elemMaxHeight = 0;
  let elemMaxWidth = 0;

  const setSize = function () {
    // Находим самый высокий элемент и балансируем высоту
    for (let i = 0; i < gridElemAll.length; i++) {
      let currentElem = gridElemAll[i];
      let currentCard = currentElem.children[0];
      let currentCardHeight = Math.ceil(currentCard.offsetHeight)

      if (elemMaxHeight < currentCardHeight) {
        elemMaxHeight = currentCardHeight;
      }
      // if (elemMaxWidth < currentCard.offsetWidth) {
      //   elemMaxWidth = Math.ceil(currentCard.offsetWidth);
      // }

      if (currentCardHeight < elemMaxHeight) {
         currentCard.style = `height: ${elemMaxHeight}px;`;
      }
      // if (currentCard.offsetWidth < elemMaxWidth) {
      //     currentCard.style = `width: ${elemMaxWidth}px;`;
      // }
    }
  };

  setSize();

  // Ресайз при изменении р-ра экрана
  let resizeTimeout;
  const resizeThrottler = function () {
    // ignore resize events as long as an actualResizeHandler execution is in the queue
    if ( !resizeTimeout ) {
      resizeTimeout = setTimeout(function() {
        resizeTimeout = null;
        setSize();
       // The actualResizeHandler will execute at a rate of 15fps
       }, 100);
    }
  };

  window.addEventListener("resize", resizeThrottler, false);

  //задаем высоту элементам, который ниже самого высокого
  // for (let j = 0; j < gridElemAll.length; j++) {
  //   let currentElem = gridElemAll[j];
  //   let currentCard = currentElem.children[0];

  //   if (currentCard.offsetHeight < elemMaxHeight) {
  //      currentCard.style = `height: ${elemMaxHeight}px;`;
  //   }
  // }

  //console.log(`Макс высота элемента: ${elemMaxHeight}`);
  //console.log(`Макс ширина элемента: ${elemMaxWidth}`);
}());*/
(function () {
  //const agreementElems = document.querySelectorAll('.contacts__agreement');
  const agreementElems = document.querySelectorAll('[class$="__agreement"]');

  for (let i = 0; i < agreementElems.length; i++) {
    let agreementElem = agreementElems[i]; //const submitBtn = agreementElem.querySelector('.contacts__submit');

    const submitBtn = agreementElem.querySelector('button[type=submit]');
    const agreementCheckbox = agreementElem.querySelector('input[name=agreement]');

    if (agreementCheckbox) {
      agreementCheckbox.addEventListener('change', function (e) {
        if (!e.target.checked) {
          submitBtn.disabled = true;
        } else {
          submitBtn.disabled = false;
        }
      });
    }
  }
})();
/*(function(){
  const coverForm = document.getElementById('coverage-form');
  const coverResult = document.getElementById('coverage-result');
  if (!coverForm) { return; }

  const coverResultCity = coverResult.querySelector('.coverage-result__city');
  const formSubmitBtn = coverForm.querySelector('#coverage-form-submit');
  const loader = coverForm.querySelector('.loader');
  const inputArr = coverForm.querySelectorAll('.field-text__input');
  const citySelect = coverForm.querySelector('.field-select__select');

  const coverResultShow = function () {
    if (!coverResult.classList.contains('show')) {
      coverResult.classList.add('show');
    }
    const coverResultCity = coverResult.querySelector('.coverage-result__city');
    const coverResultStreet = coverResult.querySelector('.coverage-result__street');
    const coverResultHouse = coverResult.querySelector('.coverage-result__house');
    const selectOptions = citySelect.options;

    for (let i = 0; i < selectOptions.length; i++) {
      let currentOption = selectOptions[i];
      if (currentOption.selected) {
        coverResultCity.textContent = currentOption.value;
      }
    }
    for (let j = 0; j < inputArr.length; j++) {
      let currentInput = inputArr[j];
      if (currentInput.name === 'street') {
        coverResultStreet.textContent = currentInput.value;
      }
      if (currentInput.name === 'house') {
        coverResultHouse.textContent = currentInput.value;
      }
    }
  }

  const checkEmptyInput = function () {
    let returnedBulean = true;
    for (let i = 0; i < inputArr.length; i++) {
      let currentInput = inputArr[i];
      let currentInputValue = currentInput.value;
      let voidFlag = !!currentInputValue;
      if (!voidFlag) {
        //currentInput.nextElementSibling.textContent = 'Это поле должно быть заполнено!';
        currentInput.style = 'border-color:#fd0000;';
        returnedBulean = false;
        break;
      }
      currentInput.style = 'border-color:#158e30;';
    }

    return returnedBulean;
  };

  const formSubmitBtnHandler = function (e) {
    e.preventDefault();
    if (checkEmptyInput()) {
      e.target.setAttribute('disabled', true);
      loader.classList.add('show');
      window.setTimeout(function () {
        e.target.removeAttribute('disabled');
        loader.classList.remove('show');
        coverResultShow();
      } , 5000);
    }
  };

  if (formSubmitBtn) {
    formSubmitBtn.addEventListener('click', formSubmitBtnHandler);
  }
}());
*/
(function () {
  const orderModal = document.getElementById('orderModal');

  if (!orderModal) {
    return;
  }

  orderModal.addEventListener('show.bs.modal', function (event) {
    // Button that triggered the modal
    let button = event.relatedTarget; // Extract info from data-bs-* attributes

    let subTitle = button.getAttribute('data-bs-whatever'); // If necessary, you could initiate an AJAX request here
    // and then do the updating in a callback.
    //
    // Update the modal's content.

    let modalAddTitle = orderModal.querySelector('.modal-title__add'); //var modalBodyInput = orderModal.querySelector('.modal-body input')

    modalAddTitle.textContent = '' + subTitle; //modalBodyInput.value = recipient;
  });
})();
document.addEventListener('DOMContentLoaded', function () {
  const countdownArr = document.getElementsByClassName('countdown');

  if (!countdownArr) {
    return;
  }

  function getTimeRemaining(endtime) {
    let t = Date.parse(endtime) - Date.parse(new Date());
    let seconds = Math.floor(t / 1000 % 60);
    let minutes = Math.floor(t / 1000 / 60 % 60);
    let hours = Math.floor(t / (1000 * 60 * 60) % 24);
    let days = Math.floor(t / (1000 * 60 * 60 * 24));
    return {
      'total': t,
      'days': days,
      'hours': hours,
      'minutes': minutes,
      'seconds': seconds
    };
  }

  function initializeClock(id, endtime) {
    const clock = id;
    const daysSpan = clock.querySelector('.days');
    const hoursSpan = clock.querySelector('.hours');
    const minutesSpan = clock.querySelector('.minutes');
    const secondsSpan = clock.querySelector('.seconds');
    const countdownContainer = clock.querySelector('.countdown__inner');
    const deadlineMessage = clock.querySelector('.countdown__deadline-message');

    function updateClock() {
      const timeinterval = setInterval(updateClock, 1000);
      let t = getTimeRemaining(endtime);
      daysSpan.innerHTML = t.days;
      hoursSpan.innerHTML = ('0' + t.hours).slice(-2);
      minutesSpan.innerHTML = ('0' + t.minutes).slice(-2);
      secondsSpan.innerHTML = ('0' + t.seconds).slice(-2);
      /*if (t.total <= 0) {
        clearInterval(timeinterval);
      }*/

      if (t.total <= 0) {
        //document.getElementById("countdown").classList.add('hidden');
        countdownContainer.classList.add('hidden');
        deadlineMessage.classList.add('visible');
        clearInterval(timeinterval);
        return true;
      }
    }

    updateClock();
  } // var deadline = new Date(Date.parse(new Date()) + 15 * 24 * 60 * 60 * 1000); // for endless timer
  //const deadline = 'August 31 2021 18:59:00 GMT+0300'; //GMT+0300 - летнее время


  for (let j = 0; j < countdownArr.length; j++) {
    let currentItem = countdownArr[j];
    let currentItemDeadline = currentItem.dataset.deadline;

    if (currentItemDeadline === '') {
      continue;
    }

    initializeClock(currentItem, currentItemDeadline);
  } //initializeClock('countdown', deadline);

  /**
   * Взято за основу https://denis-creative.com/jstimer/
   * Добавлен функционал инициализации множественных объектов,
   * каждый из которых имеет свой атрибут - deadline
   *
   * Формат вывода даты ISO 8601:
   * var deadline = '2015-12-31';
   *
   * Вывод даты с точным временем и часовым поясом:
   * var deadline="September 01 2021 00:00:00 GMT+0300";
   *
   * Вывод таймера для лендингов – таймер все время будет выводить,
   * что осталось 15 дней (можно указать любое время)
   * var deadline = new Date(Date.parse(new Date()) + 15 * 24 * 60 * 60 * 1000);
   */

});
(function () {
  const utils = window.fizzyUIUtils;
  const rates = document.querySelector('.home-rates-card__slider');

  if (!rates) {
    return;
  }

  const ratesSlider = new Flickity(rates, {
    cellAlign: 'left',
    contain: true,
    dragThreshold: 5,
    //watchCSS: true,
    prevNextButtons: false,
    pageDots: false
  }); //const cellsButtonGroup = document.querySelector('.hero__dot-group--cells');
  //const cellsButtons = utils.makeArray( cellsButtonGroup.children );
  // update buttons on select

  /*heroSlider.on( 'select', function() {
    const previousSelectedButton = cellsButtonGroup.querySelector('.is-selected');
    let selectedButton = cellsButtonGroup.children[ heroSlider.selectedIndex ];
    previousSelectedButton.classList.remove('is-selected');
    selectedButton.classList.add('is-selected');
  });*/
  // cell select

  /*cellsButtonGroup.addEventListener( 'click', function( event ) {
    if ( !matchesSelector( event.target, '.hero__dot' ) ) {
      return;
    }
    let index = cellsButtons.indexOf( event.target );
    heroSlider.select( index );
  });*/
  // previous

  /*const previousButton = document.querySelector('.hero__btn--prev');
  previousButton.addEventListener( 'click', function() {
    heroSlider.previous();
  });*/
  // next

  /*const nextButton = document.querySelector('.hero__btn--next');
  nextButton.addEventListener( 'click', function() {
    heroSlider.next();
  });*/
})();

(function () {
  const cardsAll = document.querySelectorAll('.home-rates-card');

  if (!cardsAll) {
    return;
  }

  for (let i = 0; i < cardsAll.length; i++) {
    const card = cardsAll[i];
    const moreBtn = card.querySelector('.home-rates-card__btn--info');
    const returnBtn = card.querySelector('.btn--return');
    const flipElem = card.querySelector('.home-rates-card__inner'); //console.log(flipElem);

    const moreBtnClickHandler = function (e) {
      flipElem.classList.toggle('home-rates-card__inner--backface');
    };

    if (moreBtn && returnBtn) {
      moreBtn.addEventListener('click', moreBtnClickHandler);
      returnBtn.addEventListener('click', moreBtnClickHandler);
    }
  }
})();
// document.addEventListener('DOMContentLoaded', function(){});
(function () {
  const tooltip = new Drooltip({
    "element": ".tooltip",
    "trigger": "click",
    "background": "#fff",
    "color": "#252525" //"position" : "bottom"

  });
})();
document.addEventListener('DOMContentLoaded', function () {
  const modalEl = document.getElementById('promoModal');

  if (!modalEl) {
    return;
  }

  const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
  const dateTimeOut = modalEl.dataset.timeout;
  const dateExpired = modalEl.dataset.expired; //console.log(dateTimeOut);
  //modal.show();

  const convertToNum = function (num) {
    //console.log(Number.isNaN(num));
    if (!num || num < 0 || isNaN(num)) {
      return 30;
    }

    return parseInt(num, 10);
  };

  const convertTimeoutToNum = function (num) {
    //console.log(Number.isNaN(num));
    if (!num || num < 0 || isNaN(num)) {
      return 30000;
    }

    return parseInt(num, 10);
  }; //console.log(convertToNum(dateExpired));


  const setNewDate = function () {
    const nowDate = new Date(); //console.log(nowDate);

    nowDate.setDate(nowDate.getDate() + convertToNum(dateExpired)); //console.log(nowDate);

    return nowDate;
  };

  function executeOnce() {
    var argc = arguments.length,
        bImplGlob = typeof arguments[argc - 1] === "string";

    if (bImplGlob) {
      argc++;
    }

    if (argc < 3) {
      throw new TypeError("executeOnce - not enough arguments");
    }

    var fExec = arguments[0],
        sKey = arguments[argc - 2];

    if (typeof fExec !== "function") {
      throw new TypeError("executeOnce - first argument must be a function");
    }

    if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
      throw new TypeError("executeOnce - invalid identifier");
    }

    if (decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) === "1") {
      return false;
    }

    fExec.apply(argc > 3 ? arguments[1] : null, argc > 4 ? Array.prototype.slice.call(arguments, 2, argc - 2) : []);
    document.cookie = encodeURIComponent(sKey) + `=1; expires=${setNewDate()}` + (bImplGlob || !arguments[argc - 1] ? "; path=/" : ""); //Fri, 31 Dec 9999 23:59:59 GMT

    return true;
  } //console.log(setNewDate());
  //console.log(document.cookie);


  function promoShow(timeout) {
    timeout = convertTimeoutToNum(timeout);
    window.setTimeout(function () {
      modal.show();
    }, timeout);
  }

  executeOnce(promoShow, null, dateTimeOut, "promo_show"); //executeOnce(callback, null, callback's argument, identifier (string));
  //identifier - is a name of the cookie
});
document.documentElement.className = document.documentElement.className.replace('no-js', 'js');

function cth(c) {
  document.documentElement.classList.add(c);
}

'ontouchstart' in window ? cth('touch') : cth('no-touch');
if (typeof InstallTrigger !== 'undefined') cth('firefox');
if (/constructor/i.test(window.HTMLElement) || function (p) {
  return p.toString() === "[object SafariRemoteNotification]";
}(!window['safari'] || typeof safari !== 'undefined' && safari.pushNotification)) cth('safari');
if (
/*@cc_on!@*/
false || !!document.documentMode) cth('ie');
if (!(
/*@cc_on!@*/
false || !!document.documentMode) && !!window.StyleMedia) cth('edge');
if (!!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime)) cth('chrome');
if (~navigator.appVersion.indexOf("Win")) cth('windows');
if (~navigator.appVersion.indexOf("Mac")) cth('osx');
if (~navigator.appVersion.indexOf("Linux")) cth('linux');

(function () {
  // Поддержка формата webp для background-img
  // 1. Проверяем, можно ли использовать Webp формат
  function canUseWebp() {
    // Создаем элемент canvas
    let elem = document.createElement('canvas'); // Приводим элемент к булеву типу

    if (!!(elem.getContext && elem.getContext('2d'))) {
      // Создаем изображение в формате webp, возвращаем индекс искомого элемента и сразу же проверяем его
      return elem.toDataURL('image/webp').indexOf('data:image/webp') == 0;
    } // Иначе Webp не используем


    return false;
  } // 2. Заменв формата изображений


  window.onload = function () {
    // Получаем все элементы с дата-атрибутом data-bg
    let images = document.querySelectorAll('[data-bg]'); // Проходимся по каждому

    for (let i = 0; i < images.length; i++) {
      // Получаем значение каждого дата-атрибута
      let image = images[i].getAttribute('data-bg'); // Каждому найденному элементу задаем свойство background-image с изображение формата jpg

      images[i].style.backgroundImage = 'url(' + image + ')';
    } // Проверяем, является ли браузер посетителя сайта Firefox и получаем его версию


    let isitFirefox = window.navigator.userAgent.match(/Firefox\/([0-9]+)\./);
    let firefoxVer = isitFirefox ? parseInt(isitFirefox[1]) : 0; // Если есть поддержка Webp или браузер Firefox версии больше или равно 65

    if (canUseWebp() || firefoxVer >= 65) {
      // Делаем все то же самое что и для jpg, но уже для изображений формата Webp
      let imagesWebp = document.querySelectorAll('[data-bg-webp]');

      for (let i = 0; i < imagesWebp.length; i++) {
        let imageWebp = imagesWebp[i].getAttribute('data-bg-webp');
        imagesWebp[i].style.backgroundImage = 'url(' + imageWebp + ')';
      }
    }
  }; // Разметка:
  //<div style="background-image: url('/images/image.webp')" data-bg="/images/image.jpg" data-bg-webp="/images/image.webp"></div>

})();

(function () {
  let bLazy = new Blazy({
    selector: '.b-lazy'
  });
})();

(function () {
  var phoneElems = document.getElementsByClassName('phone-mask');
  Array.prototype.forEach.call(phoneElems, function (item) {
    var phoneMask = IMask(item, {
      mask: '+{38} (\\000) 000 00 00',
      lazy: false // make placeholder always visible

    });
  });
})(); // На проекте нет jQuery, но хочется $( document ).ready...
// function ready(fn) {
//   if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading"){
//     fn();
//   } else {
//     document.addEventListener('DOMContentLoaded', fn);
//   }
// }
//
// ready(function(){
//   // code
// });
// $(document).ready(function(){
//   if(window.matchMedia('(min-width: 1366px)').matches){
//   // do functionality on screens bigger than 1366px
//     $("#sticker").sticky({
//       topSpacing: 100
//     });
//   }
//   return false;
// });