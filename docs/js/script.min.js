/**
 * @popperjs/core v2.9.3 - MIT License
 */
"use strict";

!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).Popper = {});
}(this, function (e) {
  function t(e) {
    return null == e ? window : "[object Window]" !== e.toString() ? (e = e.ownerDocument) && e.defaultView || window : e;
  }

  function n(e) {
    return e instanceof t(e).Element || e instanceof Element;
  }

  function o(e) {
    return e instanceof t(e).HTMLElement || e instanceof HTMLElement;
  }

  function r(e) {
    return "undefined" != typeof ShadowRoot && (e instanceof t(e).ShadowRoot || e instanceof ShadowRoot);
  }

  function i(e, t) {
    void 0 === t && (t = !1);
    var n = e.getBoundingClientRect(),
        r = 1,
        i = 1;
    return o(e) && t && (r = n.width / e.offsetWidth || 1, i = n.height / e.offsetHeight || 1), {
      width: q(n.width / r),
      height: q(n.height / i),
      top: q(n.top / i),
      right: q(n.right / r),
      bottom: q(n.bottom / i),
      left: q(n.left / r),
      x: q(n.left / r),
      y: q(n.top / i)
    };
  }

  function a(e) {
    return {
      scrollLeft: (e = t(e)).pageXOffset,
      scrollTop: e.pageYOffset
    };
  }

  function s(e) {
    return e ? (e.nodeName || "").toLowerCase() : null;
  }

  function f(e) {
    return ((n(e) ? e.ownerDocument : e.document) || window.document).documentElement;
  }

  function p(e) {
    return i(f(e)).left + a(e).scrollLeft;
  }

  function c(e) {
    return t(e).getComputedStyle(e);
  }

  function l(e) {
    return e = c(e), /auto|scroll|overlay|hidden/.test(e.overflow + e.overflowY + e.overflowX);
  }

  function u(e, n, r) {
    void 0 === r && (r = !1);
    var c,
        u = o(n);

    if (c = o(n)) {
      var d = (c = n.getBoundingClientRect()).height / n.offsetHeight || 1;
      c = 1 !== (c.width / n.offsetWidth || 1) || 1 !== d;
    }

    d = c, c = f(n), e = i(e, d), d = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var h = {
      x: 0,
      y: 0
    };
    return (u || !u && !r) && (("body" !== s(n) || l(c)) && (d = n !== t(n) && o(n) ? {
      scrollLeft: n.scrollLeft,
      scrollTop: n.scrollTop
    } : a(n)), o(n) ? ((h = i(n, !0)).x += n.clientLeft, h.y += n.clientTop) : c && (h.x = p(c))), {
      x: e.left + d.scrollLeft - h.x,
      y: e.top + d.scrollTop - h.y,
      width: e.width,
      height: e.height
    };
  }

  function d(e) {
    var t = i(e),
        n = e.offsetWidth,
        o = e.offsetHeight;
    return 1 >= Math.abs(t.width - n) && (n = t.width), 1 >= Math.abs(t.height - o) && (o = t.height), {
      x: e.offsetLeft,
      y: e.offsetTop,
      width: n,
      height: o
    };
  }

  function h(e) {
    return "html" === s(e) ? e : e.assignedSlot || e.parentNode || (r(e) ? e.host : null) || f(e);
  }

  function m(e) {
    return 0 <= ["html", "body", "#document"].indexOf(s(e)) ? e.ownerDocument.body : o(e) && l(e) ? e : m(h(e));
  }

  function v(e, n) {
    var o;
    void 0 === n && (n = []);
    var r = m(e);
    return e = r === (null == (o = e.ownerDocument) ? void 0 : o.body), o = t(r), r = e ? [o].concat(o.visualViewport || [], l(r) ? r : []) : r, n = n.concat(r), e ? n : n.concat(v(h(r)));
  }

  function g(e) {
    return o(e) && "fixed" !== c(e).position ? e.offsetParent : null;
  }

  function y(e) {
    for (var n = t(e), r = g(e); r && 0 <= ["table", "td", "th"].indexOf(s(r)) && "static" === c(r).position;) r = g(r);

    if (r && ("html" === s(r) || "body" === s(r) && "static" === c(r).position)) return n;
    if (!r) e: {
      if (r = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"), -1 === navigator.userAgent.indexOf("Trident") || !o(e) || "fixed" !== c(e).position) for (e = h(e); o(e) && 0 > ["html", "body"].indexOf(s(e));) {
        var i = c(e);

        if ("none" !== i.transform || "none" !== i.perspective || "paint" === i.contain || -1 !== ["transform", "perspective"].indexOf(i.willChange) || r && "filter" === i.willChange || r && i.filter && "none" !== i.filter) {
          r = e;
          break e;
        }

        e = e.parentNode;
      }
      r = null;
    }
    return r || n;
  }

  function b(e) {
    function t(e) {
      o.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) {
        o.has(e) || (e = n.get(e)) && t(e);
      }), r.push(e);
    }

    var n = new Map(),
        o = new Set(),
        r = [];
    return e.forEach(function (e) {
      n.set(e.name, e);
    }), e.forEach(function (e) {
      o.has(e.name) || t(e);
    }), r;
  }

  function w(e) {
    var t;
    return function () {
      return t || (t = new Promise(function (n) {
        Promise.resolve().then(function () {
          t = void 0, n(e());
        });
      })), t;
    };
  }

  function x(e) {
    return e.split("-")[0];
  }

  function O(e, t) {
    var n = t.getRootNode && t.getRootNode();
    if (e.contains(t)) return !0;
    if (n && r(n)) do {
      if (t && e.isSameNode(t)) return !0;
      t = t.parentNode || t.host;
    } while (t);
    return !1;
  }

  function j(e) {
    return Object.assign({}, e, {
      left: e.x,
      top: e.y,
      right: e.x + e.width,
      bottom: e.y + e.height
    });
  }

  function E(e, n) {
    if ("viewport" === n) {
      n = t(e);
      var r = f(e);
      n = n.visualViewport;
      var s = r.clientWidth;
      r = r.clientHeight;
      var l = 0,
          u = 0;
      n && (s = n.width, r = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (l = n.offsetLeft, u = n.offsetTop)), e = j(e = {
        width: s,
        height: r,
        x: l + p(e),
        y: u
      });
    } else o(n) ? ((e = i(n)).top += n.clientTop, e.left += n.clientLeft, e.bottom = e.top + n.clientHeight, e.right = e.left + n.clientWidth, e.width = n.clientWidth, e.height = n.clientHeight, e.x = e.left, e.y = e.top) : (u = f(e), e = f(u), s = a(u), n = null == (r = u.ownerDocument) ? void 0 : r.body, r = U(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), l = U(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), u = -s.scrollLeft + p(u), s = -s.scrollTop, "rtl" === c(n || e).direction && (u += U(e.clientWidth, n ? n.clientWidth : 0) - r), e = j({
      width: r,
      height: l,
      x: u,
      y: s
    }));

    return e;
  }

  function D(e, t, r) {
    return t = "clippingParents" === t ? function (e) {
      var t = v(h(e)),
          r = 0 <= ["absolute", "fixed"].indexOf(c(e).position) && o(e) ? y(e) : e;
      return n(r) ? t.filter(function (e) {
        return n(e) && O(e, r) && "body" !== s(e);
      }) : [];
    }(e) : [].concat(t), (r = (r = [].concat(t, [r])).reduce(function (t, n) {
      return n = E(e, n), t.top = U(n.top, t.top), t.right = z(n.right, t.right), t.bottom = z(n.bottom, t.bottom), t.left = U(n.left, t.left), t;
    }, E(e, r[0]))).width = r.right - r.left, r.height = r.bottom - r.top, r.x = r.left, r.y = r.top, r;
  }

  function L(e) {
    return 0 <= ["top", "bottom"].indexOf(e) ? "x" : "y";
  }

  function M(e) {
    var t = e.reference,
        n = e.element,
        o = (e = e.placement) ? x(e) : null;
    e = e ? e.split("-")[1] : null;
    var r = t.x + t.width / 2 - n.width / 2,
        i = t.y + t.height / 2 - n.height / 2;

    switch (o) {
      case "top":
        r = {
          x: r,
          y: t.y - n.height
        };
        break;

      case "bottom":
        r = {
          x: r,
          y: t.y + t.height
        };
        break;

      case "right":
        r = {
          x: t.x + t.width,
          y: i
        };
        break;

      case "left":
        r = {
          x: t.x - n.width,
          y: i
        };
        break;

      default:
        r = {
          x: t.x,
          y: t.y
        };
    }

    if (null != (o = o ? L(o) : null)) switch (i = "y" === o ? "height" : "width", e) {
      case "start":
        r[o] -= t[i] / 2 - n[i] / 2;
        break;

      case "end":
        r[o] += t[i] / 2 - n[i] / 2;
    }
    return r;
  }

  function P(e) {
    return Object.assign({}, {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, e);
  }

  function k(e, t) {
    return t.reduce(function (t, n) {
      return t[n] = e, t;
    }, {});
  }

  function W(e, t) {
    void 0 === t && (t = {});
    var o = t;
    t = void 0 === (t = o.placement) ? e.placement : t;
    var r = o.boundary,
        a = void 0 === r ? "clippingParents" : r,
        s = void 0 === (r = o.rootBoundary) ? "viewport" : r;
    r = void 0 === (r = o.elementContext) ? "popper" : r;
    var p = o.altBoundary,
        c = void 0 !== p && p;
    o = P("number" != typeof (o = void 0 === (o = o.padding) ? 0 : o) ? o : k(o, N));
    var l = e.elements.reference;
    p = e.rects.popper, a = D(n(c = e.elements[c ? "popper" === r ? "reference" : "popper" : r]) ? c : c.contextElement || f(e.elements.popper), a, s), c = M({
      reference: s = i(l),
      element: p,
      strategy: "absolute",
      placement: t
    }), p = j(Object.assign({}, p, c)), s = "popper" === r ? p : s;
    var u = {
      top: a.top - s.top + o.top,
      bottom: s.bottom - a.bottom + o.bottom,
      left: a.left - s.left + o.left,
      right: s.right - a.right + o.right
    };

    if (e = e.modifiersData.offset, "popper" === r && e) {
      var d = e[t];
      Object.keys(u).forEach(function (e) {
        var t = 0 <= ["right", "bottom"].indexOf(e) ? 1 : -1,
            n = 0 <= ["top", "bottom"].indexOf(e) ? "y" : "x";
        u[e] += d[n] * t;
      });
    }

    return u;
  }

  function A() {
    for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];

    return !t.some(function (e) {
      return !(e && "function" == typeof e.getBoundingClientRect);
    });
  }

  function B(e) {
    void 0 === e && (e = {});
    var t = e.defaultModifiers,
        o = void 0 === t ? [] : t,
        r = void 0 === (e = e.defaultOptions) ? X : e;
    return function (e, t, i) {
      function a() {
        f.forEach(function (e) {
          return e();
        }), f = [];
      }

      void 0 === i && (i = r);
      var s = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, X, r),
        modifiersData: {},
        elements: {
          reference: e,
          popper: t
        },
        attributes: {},
        styles: {}
      },
          f = [],
          p = !1,
          c = {
        state: s,
        setOptions: function (i) {
          return a(), s.options = Object.assign({}, r, s.options, i), s.scrollParents = {
            reference: n(e) ? v(e) : e.contextElement ? v(e.contextElement) : [],
            popper: v(t)
          }, i = function (e) {
            var t = b(e);
            return _.reduce(function (e, n) {
              return e.concat(t.filter(function (e) {
                return e.phase === n;
              }));
            }, []);
          }(function (e) {
            var t = e.reduce(function (e, t) {
              var n = e[t.name];
              return e[t.name] = n ? Object.assign({}, n, t, {
                options: Object.assign({}, n.options, t.options),
                data: Object.assign({}, n.data, t.data)
              }) : t, e;
            }, {});
            return Object.keys(t).map(function (e) {
              return t[e];
            });
          }([].concat(o, s.options.modifiers))), s.orderedModifiers = i.filter(function (e) {
            return e.enabled;
          }), s.orderedModifiers.forEach(function (e) {
            var t = e.name,
                n = e.options;
            n = void 0 === n ? {} : n, "function" == typeof (e = e.effect) && (t = e({
              state: s,
              name: t,
              instance: c,
              options: n
            }), f.push(t || function () {}));
          }), c.update();
        },
        forceUpdate: function () {
          if (!p) {
            var e = s.elements,
                t = e.reference;
            if (A(t, e = e.popper)) for (s.rects = {
              reference: u(t, y(e), "fixed" === s.options.strategy),
              popper: d(e)
            }, s.reset = !1, s.placement = s.options.placement, s.orderedModifiers.forEach(function (e) {
              return s.modifiersData[e.name] = Object.assign({}, e.data);
            }), t = 0; t < s.orderedModifiers.length; t++) if (!0 === s.reset) s.reset = !1, t = -1;else {
              var n = s.orderedModifiers[t];
              e = n.fn;
              var o = n.options;
              o = void 0 === o ? {} : o, n = n.name, "function" == typeof e && (s = e({
                state: s,
                options: o,
                name: n,
                instance: c
              }) || s);
            }
          }
        },
        update: w(function () {
          return new Promise(function (e) {
            c.forceUpdate(), e(s);
          });
        }),
        destroy: function () {
          a(), p = !0;
        }
      };
      return A(e, t) ? (c.setOptions(i).then(function (e) {
        !p && i.onFirstUpdate && i.onFirstUpdate(e);
      }), c) : c;
    };
  }

  function H(e) {
    var n,
        o = e.popper,
        r = e.popperRect,
        i = e.placement,
        a = e.offsets,
        s = e.position,
        p = e.gpuAcceleration,
        l = e.adaptive;

    if (!0 === (e = e.roundOffsets)) {
      e = a.y;
      var u = window.devicePixelRatio || 1;
      e = {
        x: F(F(a.x * u) / u) || 0,
        y: F(F(e * u) / u) || 0
      };
    } else e = "function" == typeof e ? e(a) : a;

    e = void 0 === (e = (u = e).x) ? 0 : e, u = void 0 === (u = u.y) ? 0 : u;
    var d = a.hasOwnProperty("x");
    a = a.hasOwnProperty("y");
    var h,
        m = "left",
        v = "top",
        g = window;

    if (l) {
      var b = y(o),
          w = "clientHeight",
          x = "clientWidth";
      b === t(o) && "static" !== c(b = f(o)).position && (w = "scrollHeight", x = "scrollWidth"), "top" === i && (v = "bottom", u -= b[w] - r.height, u *= p ? 1 : -1), "left" === i && (m = "right", e -= b[x] - r.width, e *= p ? 1 : -1);
    }

    return o = Object.assign({
      position: s
    }, l && K), p ? Object.assign({}, o, ((h = {})[v] = a ? "0" : "", h[m] = d ? "0" : "", h.transform = 2 > (g.devicePixelRatio || 1) ? "translate(" + e + "px, " + u + "px)" : "translate3d(" + e + "px, " + u + "px, 0)", h)) : Object.assign({}, o, ((n = {})[v] = a ? u + "px" : "", n[m] = d ? e + "px" : "", n.transform = "", n));
  }

  function T(e) {
    return e.replace(/left|right|bottom|top/g, function (e) {
      return ee[e];
    });
  }

  function R(e) {
    return e.replace(/start|end/g, function (e) {
      return te[e];
    });
  }

  function S(e, t, n) {
    return void 0 === n && (n = {
      x: 0,
      y: 0
    }), {
      top: e.top - t.height - n.y,
      right: e.right - t.width + n.x,
      bottom: e.bottom - t.height + n.y,
      left: e.left - t.width - n.x
    };
  }

  function C(e) {
    return ["top", "right", "bottom", "left"].some(function (t) {
      return 0 <= e[t];
    });
  }

  var q = Math.round,
      N = ["top", "bottom", "right", "left"],
      V = N.reduce(function (e, t) {
    return e.concat([t + "-start", t + "-end"]);
  }, []),
      I = [].concat(N, ["auto"]).reduce(function (e, t) {
    return e.concat([t, t + "-start", t + "-end"]);
  }, []),
      _ = "beforeRead read afterRead beforeMain main afterMain beforeWrite write afterWrite".split(" "),
      U = Math.max,
      z = Math.min,
      F = Math.round,
      X = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  },
      Y = {
    passive: !0
  },
      G = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: function (e) {
      var n = e.state,
          o = e.instance,
          r = (e = e.options).scroll,
          i = void 0 === r || r,
          a = void 0 === (e = e.resize) || e,
          s = t(n.elements.popper),
          f = [].concat(n.scrollParents.reference, n.scrollParents.popper);
      return i && f.forEach(function (e) {
        e.addEventListener("scroll", o.update, Y);
      }), a && s.addEventListener("resize", o.update, Y), function () {
        i && f.forEach(function (e) {
          e.removeEventListener("scroll", o.update, Y);
        }), a && s.removeEventListener("resize", o.update, Y);
      };
    },
    data: {}
  },
      J = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: function (e) {
      var t = e.state;
      t.modifiersData[e.name] = M({
        reference: t.rects.reference,
        element: t.rects.popper,
        strategy: "absolute",
        placement: t.placement
      });
    },
    data: {}
  },
      K = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  },
      Q = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: function (e) {
      var t = e.state,
          n = e.options;
      e = void 0 === (e = n.gpuAcceleration) || e;
      var o = n.adaptive;
      o = void 0 === o || o, n = void 0 === (n = n.roundOffsets) || n, e = {
        placement: x(t.placement),
        popper: t.elements.popper,
        popperRect: t.rects.popper,
        gpuAcceleration: e
      }, null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, H(Object.assign({}, e, {
        offsets: t.modifiersData.popperOffsets,
        position: t.options.strategy,
        adaptive: o,
        roundOffsets: n
      })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, H(Object.assign({}, e, {
        offsets: t.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: n
      })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
      });
    },
    data: {}
  },
      Z = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: function (e) {
      var t = e.state;
      Object.keys(t.elements).forEach(function (e) {
        var n = t.styles[e] || {},
            r = t.attributes[e] || {},
            i = t.elements[e];
        o(i) && s(i) && (Object.assign(i.style, n), Object.keys(r).forEach(function (e) {
          var t = r[e];
          !1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t);
        }));
      });
    },
    effect: function (e) {
      var t = e.state,
          n = {
        popper: {
          position: t.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () {
        Object.keys(t.elements).forEach(function (e) {
          var r = t.elements[e],
              i = t.attributes[e] || {};
          e = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce(function (e, t) {
            return e[t] = "", e;
          }, {}), o(r) && s(r) && (Object.assign(r.style, e), Object.keys(i).forEach(function (e) {
            r.removeAttribute(e);
          }));
        });
      };
    },
    requires: ["computeStyles"]
  },
      $ = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: function (e) {
      var t = e.state,
          n = e.name,
          o = void 0 === (e = e.options.offset) ? [0, 0] : e,
          r = (e = I.reduce(function (e, n) {
        var r = t.rects,
            i = x(n),
            a = 0 <= ["left", "top"].indexOf(i) ? -1 : 1,
            s = "function" == typeof o ? o(Object.assign({}, r, {
          placement: n
        })) : o;
        return r = (r = s[0]) || 0, s = ((s = s[1]) || 0) * a, i = 0 <= ["left", "right"].indexOf(i) ? {
          x: s,
          y: r
        } : {
          x: r,
          y: s
        }, e[n] = i, e;
      }, {}))[t.placement],
          i = r.x;
      r = r.y, null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += i, t.modifiersData.popperOffsets.y += r), t.modifiersData[n] = e;
    }
  },
      ee = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  },
      te = {
    start: "end",
    end: "start"
  },
      ne = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t = e.state,
          n = e.options;

      if (e = e.name, !t.modifiersData[e]._skip) {
        var o = n.mainAxis;
        o = void 0 === o || o;
        var r = n.altAxis;
        r = void 0 === r || r;
        var i = n.fallbackPlacements,
            a = n.padding,
            s = n.boundary,
            f = n.rootBoundary,
            p = n.altBoundary,
            c = n.flipVariations,
            l = void 0 === c || c,
            u = n.allowedAutoPlacements;
        c = x(n = t.options.placement), i = i || (c !== n && l ? function (e) {
          if ("auto" === x(e)) return [];
          var t = T(e);
          return [R(e), t, R(t)];
        }(n) : [T(n)]);
        var d = [n].concat(i).reduce(function (e, n) {
          return e.concat("auto" === x(n) ? function (e, t) {
            void 0 === t && (t = {});
            var n = t.boundary,
                o = t.rootBoundary,
                r = t.padding,
                i = t.flipVariations,
                a = t.allowedAutoPlacements,
                s = void 0 === a ? I : a,
                f = t.placement.split("-")[1];
            0 === (i = (t = f ? i ? V : V.filter(function (e) {
              return e.split("-")[1] === f;
            }) : N).filter(function (e) {
              return 0 <= s.indexOf(e);
            })).length && (i = t);
            var p = i.reduce(function (t, i) {
              return t[i] = W(e, {
                placement: i,
                boundary: n,
                rootBoundary: o,
                padding: r
              })[x(i)], t;
            }, {});
            return Object.keys(p).sort(function (e, t) {
              return p[e] - p[t];
            });
          }(t, {
            placement: n,
            boundary: s,
            rootBoundary: f,
            padding: a,
            flipVariations: l,
            allowedAutoPlacements: u
          }) : n);
        }, []);
        n = t.rects.reference, i = t.rects.popper;
        var h = new Map();
        c = !0;

        for (var m = d[0], v = 0; v < d.length; v++) {
          var g = d[v],
              y = x(g),
              b = "start" === g.split("-")[1],
              w = 0 <= ["top", "bottom"].indexOf(y),
              O = w ? "width" : "height",
              j = W(t, {
            placement: g,
            boundary: s,
            rootBoundary: f,
            altBoundary: p,
            padding: a
          });

          if (b = w ? b ? "right" : "left" : b ? "bottom" : "top", n[O] > i[O] && (b = T(b)), O = T(b), w = [], o && w.push(0 >= j[y]), r && w.push(0 >= j[b], 0 >= j[O]), w.every(function (e) {
            return e;
          })) {
            m = g, c = !1;
            break;
          }

          h.set(g, w);
        }

        if (c) for (o = function (e) {
          var t = d.find(function (t) {
            if (t = h.get(t)) return t.slice(0, e).every(function (e) {
              return e;
            });
          });
          if (t) return m = t, "break";
        }, r = l ? 3 : 1; 0 < r && "break" !== o(r); r--);
        t.placement !== m && (t.modifiersData[e]._skip = !0, t.placement = m, t.reset = !0);
      }
    },
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  },
      oe = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t = e.state,
          n = e.options;
      e = e.name;
      var o = n.mainAxis,
          r = void 0 === o || o,
          i = void 0 !== (o = n.altAxis) && o;
      o = void 0 === (o = n.tether) || o;
      var a = n.tetherOffset,
          s = void 0 === a ? 0 : a,
          f = W(t, {
        boundary: n.boundary,
        rootBoundary: n.rootBoundary,
        padding: n.padding,
        altBoundary: n.altBoundary
      });
      n = x(t.placement);
      var p = t.placement.split("-")[1],
          c = !p,
          l = L(n);
      n = "x" === l ? "y" : "x", a = t.modifiersData.popperOffsets;
      var u = t.rects.reference,
          h = t.rects.popper,
          m = "function" == typeof s ? s(Object.assign({}, t.rects, {
        placement: t.placement
      })) : s;

      if (s = {
        x: 0,
        y: 0
      }, a) {
        if (r || i) {
          var v = "y" === l ? "top" : "left",
              g = "y" === l ? "bottom" : "right",
              b = "y" === l ? "height" : "width",
              w = a[l],
              O = a[l] + f[v],
              j = a[l] - f[g],
              E = o ? -h[b] / 2 : 0,
              D = "start" === p ? u[b] : h[b];
          p = "start" === p ? -h[b] : -u[b], h = t.elements.arrow, h = o && h ? d(h) : {
            width: 0,
            height: 0
          };
          var M = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          };
          v = M[v], g = M[g], h = U(0, z(u[b], h[b])), D = c ? u[b] / 2 - E - h - v - m : D - h - v - m, u = c ? -u[b] / 2 + E + h + g + m : p + h + g + m, c = t.elements.arrow && y(t.elements.arrow), m = t.modifiersData.offset ? t.modifiersData.offset[t.placement][l] : 0, c = a[l] + D - m - (c ? "y" === l ? c.clientTop || 0 : c.clientLeft || 0 : 0), u = a[l] + u - m, r && (r = o ? z(O, c) : O, j = o ? U(j, u) : j, r = U(r, z(w, j)), a[l] = r, s[l] = r - w), i && (r = (i = a[n]) + f["x" === l ? "top" : "left"], f = i - f["x" === l ? "bottom" : "right"], r = o ? z(r, c) : r, o = o ? U(f, u) : f, o = U(r, z(i, o)), a[n] = o, s[n] = o - i);
        }

        t.modifiersData[e] = s;
      }
    },
    requiresIfExists: ["offset"]
  },
      re = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: function (e) {
      var t,
          n = e.state,
          o = e.name,
          r = e.options,
          i = n.elements.arrow,
          a = n.modifiersData.popperOffsets,
          s = x(n.placement);

      if (e = L(s), s = 0 <= ["left", "right"].indexOf(s) ? "height" : "width", i && a) {
        r = P("number" != typeof (r = "function" == typeof (r = r.padding) ? r(Object.assign({}, n.rects, {
          placement: n.placement
        })) : r) ? r : k(r, N));
        var f = d(i),
            p = "y" === e ? "top" : "left",
            c = "y" === e ? "bottom" : "right",
            l = n.rects.reference[s] + n.rects.reference[e] - a[e] - n.rects.popper[s];
        a = a[e] - n.rects.reference[e], a = (i = (i = y(i)) ? "y" === e ? i.clientHeight || 0 : i.clientWidth || 0 : 0) / 2 - f[s] / 2 + (l / 2 - a / 2), s = U(r[p], z(a, i - f[s] - r[c])), n.modifiersData[o] = ((t = {})[e] = s, t.centerOffset = s - a, t);
      }
    },
    effect: function (e) {
      var t = e.state;

      if (null != (e = void 0 === (e = e.options.element) ? "[data-popper-arrow]" : e)) {
        if ("string" == typeof e && !(e = t.elements.popper.querySelector(e))) return;
        O(t.elements.popper, e) && (t.elements.arrow = e);
      }
    },
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  },
      ie = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: function (e) {
      var t = e.state;
      e = e.name;
      var n = t.rects.reference,
          o = t.rects.popper,
          r = t.modifiersData.preventOverflow,
          i = W(t, {
        elementContext: "reference"
      }),
          a = W(t, {
        altBoundary: !0
      });
      n = S(i, n), o = S(a, o, r), r = C(n), a = C(o), t.modifiersData[e] = {
        referenceClippingOffsets: n,
        popperEscapeOffsets: o,
        isReferenceHidden: r,
        hasPopperEscaped: a
      }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": r,
        "data-popper-escaped": a
      });
    }
  },
      ae = B({
    defaultModifiers: [G, J, Q, Z]
  }),
      se = [G, J, Q, Z, $, ne, oe, re, ie],
      fe = B({
    defaultModifiers: se
  });

  e.applyStyles = Z, e.arrow = re, e.computeStyles = Q, e.createPopper = fe, e.createPopperLite = ae, e.defaultModifiers = se, e.detectOverflow = W, e.eventListeners = G, e.flip = ne, e.hide = ie, e.offset = $, e.popperGenerator = B, e.popperOffsets = J, e.preventOverflow = oe, Object.defineProperty(e, "__esModule", {
    value: !0
  });
});
/******/
(function (modules) {
  // webpackBootstrap

  /******/
  // The module cache

  /******/
  var installedModules = {};
  /******/

  /******/
  // The require function

  /******/

  function __webpack_require__(moduleId) {
    /******/

    /******/
    // Check if module is in cache

    /******/
    if (installedModules[moduleId]) {
      /******/
      return installedModules[moduleId].exports;
      /******/
    }
    /******/
    // Create a new module (and put it into the cache)

    /******/


    var module = installedModules[moduleId] = {
      /******/
      i: moduleId,

      /******/
      l: false,

      /******/
      exports: {}
      /******/

    };
    /******/

    /******/
    // Execute the module function

    /******/

    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/

    /******/
    // Flag the module as loaded

    /******/

    module.l = true;
    /******/

    /******/
    // Return the exports of the module

    /******/

    return module.exports;
    /******/
  }
  /******/

  /******/

  /******/
  // expose the modules object (__webpack_modules__)

  /******/


  __webpack_require__.m = modules;
  /******/

  /******/
  // expose the module cache

  /******/

  __webpack_require__.c = installedModules;
  /******/

  /******/
  // define getter function for harmony exports

  /******/

  __webpack_require__.d = function (exports, name, getter) {
    /******/
    if (!__webpack_require__.o(exports, name)) {
      /******/
      Object.defineProperty(exports, name, {
        /******/
        configurable: false,

        /******/
        enumerable: true,

        /******/
        get: getter
        /******/

      });
      /******/
    }
    /******/

  };
  /******/

  /******/
  // getDefaultExport function for compatibility with non-harmony modules

  /******/


  __webpack_require__.n = function (module) {
    /******/
    var getter = module && module.__esModule ?
    /******/
    function getDefault() {
      return module['default'];
    } :
    /******/
    function getModuleExports() {
      return module;
    };
    /******/

    __webpack_require__.d(getter, 'a', getter);
    /******/


    return getter;
    /******/
  };
  /******/

  /******/
  // Object.prototype.hasOwnProperty.call

  /******/


  __webpack_require__.o = function (object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  };
  /******/

  /******/
  // __webpack_public_path__

  /******/


  __webpack_require__.p = "";
  /******/

  /******/
  // Load entry module and return exports

  /******/

  return __webpack_require__(__webpack_require__.s = 0);
  /******/
})([
  /* 0 */

  /***/

  /******/
function (module, exports, __webpack_require__) {
  "use strict";

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  /**
  Drooltip.js
  Developed by: Prev Wong	(imprev.co)
  Documentation: https://prevwong.github.io/drooltip.js/
  Github: https://github.com/prevwong/drooltip.js/
  License: MIT (https://raw.githubusercontent.com/prevwong/drooltip.js/master/LICENSE)
  **/


  (function () {
    window["Drooltip"] = function () {
      this.tooltips = {};
      var defaults = {
        "element": ".drooltip",
        "trigger": "hover",
        "position": "top",
        "background": "#2175ff",
        "color": "#fff",
        "animation": "bounce",
        "content": null,
        "callback": null
      };

      if (arguments[0] && _typeof(arguments[0]) === "object") {
        this.options = extendDefaults(defaults, arguments[0]);
      }

      this.build();
    };

    function formatPrivateContent(content) {
      if (content.match(/(?![^{]+})(?:\.|#)([_a-zA-Z]+[_a-zA-Z0-9-]*)/) !== null && content.replace(content.match(/(?![^{]+})(?:\.|#)([_a-zA-Z]+[_a-zA-Z0-9-]*)/)[0], "").replace(/ /g, "") === "") {
        // use element
        return {
          "type": "element",
          "element": content.match(/(?![^{]+})(?:\.|#)([_a-zA-Z]+[_a-zA-Z0-9-]*)/)[0]
        };
      } else if (content.match(/\:(.*)\:/) !== null && content.replace(content.match(/\:(.*)\:/)[0], "") === "") {
        var pattern = content.match(/\:(.*)\:/);
        var dataString = pattern[1].match(/\[(.*)\]/);
        var type = pattern[1].replace(dataString[0], "").replace(/ /g, "");
        var url = dataString[1].split(',')[0];
        var json = null;

        if (dataString[1].split(',')[1] !== null) {
          json = dataString[1].split(',')[1].replace(/ /g, '');
        }

        return {
          url: url,
          json: json,
          type: type
        };
      } else {
        return content;
      }
    }

    function createTooltip(id, sourceElem, options) {
      var content = options["content"];

      if (_typeof(options["content"]) === "object") {
        if (options["content"]["type"] === "jsonp" || options["content"]["type"] === "ajax") {
          requests[id] = {
            info: {
              source: sourceElem,
              position: options["position"]
            },
            data: options["content"],
            loaded: false
          };
          content = "<div class = 'drooltipLoaderWrapper'><span style='background:" + options["color"] + "' class = 'drooltipLoader'></span></div>";
        } else if (options["content"]["type"] === "element") {
          var elem = document.querySelector(options["content"]["element"]);

          if (elem !== null) {
            elem.style.display = "none";
            content = elem.outerHTML;
            elem.parentNode.removeChild(elem);
          } else {
            content = "HTML element not found";
          }
        }
      }

      var tooltip = document.createElement("div");
      tooltip.setAttribute("data-identifiers", id);
      tooltip.setAttribute("class", "drooltip");
      tooltip.setAttribute("style", "color: " + options["background"]); // for arrow

      document.body.appendChild(tooltip);
      var html = "";
      html += "<div style='background:" + options["background"] + "' class = 'bg'></div>";
      html += "<div style='color:" + options["color"] + "' class = 'content'>";
      html += content;
      html += "</div>";
      tooltip.innerHTML = html;

      if (options["content"]["element"] !== undefined) {
        if (tooltip.querySelector(options["content"]["element"]) !== null) {
          tooltip.querySelector(options["content"]["element"]).style.display = "";
        }
      }

      return document.querySelector("[data-identifiers='" + id + "']");
    }

    function jsonp(url, callback) {
      var callbackName = "jsonp_callback_" + Math.round(100000 * Math.random());

      window[callbackName] = function (data) {
        delete window[callbackName];
        document.body.removeChild(script);
        callback(data);
      };

      var script = document.createElement("script");
      script.src = url + (url.indexOf("?") >= 0 ? "&" : "?") + "callback=" + callbackName;
      document.body.appendChild(script);
    }

    function requestsHandler(id, element) {
      var type = requests[id]["data"]["type"],
          json = requests[id]["data"]["json"],
          url = requests[id]["data"]["url"],
          source = requests[id]["info"]["source"],
          loaded = requests[id]["loaded"],
          position = requests[id]["info"]["position"];

      if (loaded !== true) {
        if (type === "ajax") {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", url);

          if (json !== undefined) {
            //json format
            xhr.setRequestHeader("Content-Type", "application/json");
          }

          xhr.onload = function () {
            if (xhr.status === 200) {
              var content;

              if (json !== undefined) {
                //json format
                if (json.slice(-2) === "()") {
                  content = window[json.replace("()", "")](JSON.parse(xhr.responseText));
                } else {
                  content = JSON.parse(xhr.responseText)[json];
                }
              } else {
                content = xhr.responseText;
              }

              updateDynamicContent(id, element, source, position, content);
            }
          };

          xhr.send();
        } else if (type === "jsonp") {
          jsonp(url, function (jsObject) {
            var content;

            if (json.slice(-2) === "()") {
              content = window[json.replace("()", "")](jsObject);
            } else {
              content = jsObject[json];
            }

            updateDynamicContent(id, element, source, position, content);
          });
        }
      }
    }

    function updateDynamicContent(id, element, source, position, content) {
      element.querySelector(".content .drooltipLoader").classList.add("stop");
      setTimeout(function () {
        element.querySelector(".content").classList.add("showDynamic");
        setTimeout(function () {
          element.querySelector(".content").innerHTML = content;
          element.querySelector(".content").classList.remove("showDynamic");
          getPosition(element, source, position, {
            "x": 0,
            "y": 0
          });
        }, 200);
        requests[id]["loaded"] = true;
      }, 400);
    }

    function extendDefaults(source, properties) {
      var property;

      for (property in properties) {
        if (properties.hasOwnProperty(property)) {
          source[property] = properties[property];
        }
      }

      return source;
    }
    /** Replicating jQuery Offset Method @thanks ubugnu **/


    function isWindow(obj) {
      return obj !== null && obj === obj.window;
    }

    function getWindow(elem) {
      return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    function offset(elem) {
      var docElem,
          win,
          box = {
        top: 0,
        left: 0
      },
          doc = elem && elem.ownerDocument;
      docElem = doc.documentElement;

      if (_typeof(elem.getBoundingClientRect) !== (true ? "undefined" : _typeof(undefined))) {
        box = elem.getBoundingClientRect();
      }

      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    }

    function getElemDimensions(element) {
      var top = window.pageYOffset;
      var info = {
        "left": offset(element).left,
        "top": offset(element).top
      };
      element.classList.add("fake");
      info["width"] = element.offsetWidth;
      info["height"] = element.offsetHeight;
      element.classList.remove("fake");
      return info;
    }

    function getPosition(tooltip, source, required) {
      var _tooltip$classList;

      var _pos = ["top", "bottom", "right", "left"],
          sourceDimensions = getElemDimensions(source),
          tooltipDimensions = getElemDimensions(tooltip),
          arrowSize = 6;
      var imaginaryPositions = {
        "if_top_y": sourceDimensions["top"] - tooltipDimensions["height"] - arrowSize,
        "if_vertical_x": sourceDimensions["left"] + sourceDimensions["width"] / 2 - tooltipDimensions["width"] / 2,
        "if_bottom_y": sourceDimensions["top"] + sourceDimensions["height"],
        "if_horizontal_y": sourceDimensions["top"] + (sourceDimensions["height"] / 2 - tooltipDimensions["height"] / 2) - arrowSize,
        "if_left_x": sourceDimensions["left"] - tooltipDimensions["width"],
        "if_right_x": sourceDimensions["left"] + sourceDimensions["width"]
      };
      var positions = {
        "top": {
          "y_pos": imaginaryPositions["if_top_y"],
          "x_pos": imaginaryPositions["if_vertical_x"]
        },
        "bottom": {
          "y_pos": imaginaryPositions["if_bottom_y"],
          "x_pos": imaginaryPositions["if_vertical_x"]
        },
        "right": {
          "y_pos": imaginaryPositions["if_horizontal_y"],
          "x_pos": imaginaryPositions["if_right_x"]
        },
        "left": {
          "y_pos": imaginaryPositions["if_horizontal_y"],
          "x_pos": imaginaryPositions["if_left_x"]
        }
      };
      var key = Object.keys(positions)[computeBestPosition(imaginaryPositions, tooltipDimensions, required)];

      (_tooltip$classList = tooltip.classList).remove.apply(_tooltip$classList, _pos);

      tooltip.classList.add(key);

      _extends(tooltip.style, {
        "left": positions[key]["x_pos"] + "px",
        "top": positions[key]["y_pos"] + "px"
      });
    }

    function computeBestPosition(imaginaryPositions, tooltipDimensions, required) {
      var screenTop = window.pageYOffset,
          screenWidth = window.innerWidth,
          screenHeight = window.innerHeight,
          selector = [0, 0, 0, 0];

      if (screenTop < imaginaryPositions["if_top_y"]) {
        selector[0] += 1;

        if (required === "top") {
          selector[0] += 2;
        }
      }

      if (screenTop > imaginaryPositions["if_top_y"] || screenTop < imaginaryPositions["if_bottom_y"]) {
        selector[1] += 1;

        if (required === "bottom") {
          selector[1] += 2;
        }
      }

      if (imaginaryPositions["if_vertical_x"] < 0 || required === "right" && imaginaryPositions["if_right_x"] + tooltipDimensions["width"] < screenWidth) {
        selector[2] += 1;

        if (required === "right") {
          selector[2] += 2;
        }
      }

      if (imaginaryPositions["if_left_x"] > 0) {
        selector[3] += 1;

        if (required === "left") {
          selector[3] += 2;
        }
      }

      return selector.indexOf(Math.max.apply(Math, selector));
    }

    function showTooltip() {
      var _ = this;

      var elem = _["tooltip"];
      var options = _["options"];
      var callback = options["callback"];
      var animateEffect = options["animation"];
      getPosition(_["tooltip"], _["source"], _["options"]["position"]);
      setTimeout(function () {
        elem.classList.remove("hideTooltip");

        if (elem.classList.contains("open") === false) {
          if (standardAnimations.indexOf(animateEffect) === -1) {
            window[animateEffect]("animate", _, callback);
          } else {
            addStandardEffect(elem, animateEffect, callback);
          }
        }

        elem.classList.add("open");
        setTimeout(function () {
          if (options["content"]["type"] === "ajax" || options["content"]["type"] === "jsonp" && requests[_["id"]]["loaded"] === false) {
            elem.style.transition = "none";
            requestsHandler(_["id"], elem);
            element.style.transition = "";
          }
        }, 500);
      }, 200);
    }

    function hideTooltip() {
      var _ = this;

      var elem = _["tooltip"];
      var options = _["options"];
      var callback = options["callback"];
      var animateEffect = options["animation"];
      var timeout = 0;

      if (elem.classList.contains("animating") !== false) {
        // User clicked even though tooltip is still animating
        timeout = 400;
      }

      setTimeout(function () {
        if (elem.classList.contains("open") === true) {
          if (standardAnimations.indexOf(animateEffect) === -1) {
            window[animateEffect]("deanimate", _, callback);
          } else {
            removeStandardEffect(elem, animateEffect);
          }

          elem.classList.remove("open");
        }
      }, timeout);
    }
    /** Custom Effects **/


    function floatEffect(fn, elem, callback) {
      if (fn === "animate") {
        addStandardEffect(elem, "bounce", null);
        setTimeout(function () {
          elem.classList.add("drooltipFloat");

          if (callback !== null && callback !== undefined) {
            window[callback]();
          }
        }, 100);
      } else {
        elem.classList.remove("drooltipFloat");
        removeStandardEffect(elem, "bounce");
      }
    }

    function materialEffect(fn, elem, callback) {
      if (fn === "animate") {
        elem.classList.add("drooltipMaterial");
        setTimeout(function () {
          elem.classList.remove("hideTooltip");
          setTimeout(function () {
            elem.classList.add("animate");
            setTimeout(function () {
              arrowDisplay(elem, "show");
            }, 100);
          }, 200);
        }, 100);
      } else {
        arrowDisplay(elem, "hide");
        setTimeout(function () {
          elem.classList.remove("animate");
          setTimeout(function () {
            elem.classList.remove("drooltipMaterial");
            elem.classList.add("hideTooltip");
          }, 100);
        }, 200);
      }
    }
    /** Standard Effects **/


    function addStandardEffect(elem, animateEffect, callback) {
      if (animateEffect === "material") {
        materialEffect("animate", elem, callback);
        return false;
      }

      if (animateEffect === "float") {
        floatEffect("animate", elem, callback);
        return false;
      }

      var animateEffectClass = "drooltip" + animateEffect[0].toUpperCase() + animateEffect.slice(1);
      elem.classList.remove("out");
      elem.classList.add(animateEffectClass, "animating");
      arrowDisplay(elem, "show");
      setTimeout(function () {
        elem.classList.remove("hideTooltip");
        setTimeout(function () {
          elem.classList.remove(animateEffectClass, "animating");
        }, 200);

        if (callback !== null && callback !== undefined) {
          window[callback]();
        }
      }, 200);
    }

    function removeStandardEffect(elem, animateEffect) {
      if (animateEffect === "material") {
        materialEffect("deanimate", elem);
        return false;
      }

      if (animateEffect === "float") {
        floatEffect("deanimate", elem);
        return false;
      }

      var animateEffectClass = "drooltip" + animateEffect[0].toUpperCase() + animateEffect.slice(1);
      elem.classList.add(animateEffectClass);
      elem.classList.add("out");
      arrowDisplay(elem, "hide");
      setTimeout(function () {
        elem.classList.add("hideTooltip");
        elem.classList.remove(animateEffectClass);
      }, 400);
    }

    function arrowDisplay(elem, action) {
      if (action === "show") {
        elem.classList.add("showArrow");
      } else {
        elem.classList.remove("showArrow");
      }
    }

    function listenerAdd(data, trigger) {
      var standardTriggers = ["hover", "click", "none"]; //var tooltips = Object.assign({}, publicTooltips);

      if (standardTriggers.indexOf(trigger) === -1) {
        window[trigger].call(this, data);
        return false;
      } else {
        data["tooltip"].classList.add("hideTooltip");

        if (trigger === "hover") {
          drooltipHover(data);
        } else if (trigger === "click") {
          drooltipClick(data);
        } else if (trigger === "none") {
          showTooltip.call(data);
        }
      }
      /**
      for ( var i in tooltips ) {
        publicTooltips[i]["tooltip"].classList.add("hideTooltip");
        if ( trigger === "hover" ) {
          drooltipHover(publicTooltips[i]);
        } else if ( trigger === "click" ) {
          drooltipClick(publicTooltips[i]);
        } else if ( trigger === "none" ) {
          showTooltip.call(publicTooltips[i]);
        }
      }
      **/

    }

    function drooltipHover(data) {
      var mouseover = function mouseover(data) {
        var timeout = null;
        var exit = null;
        window.addEventListener("mouseover", function (e) {
          if (data["source"].contains(e.target) || data["tooltip"].contains(e.target)) {
            clearTimeout(exit);
          } else {
            exit = setTimeout(function () {
              if (data["tooltip"].classList.contains("open")) {
                hideTooltip.call(data);
              }
            }, 200);
          }
        });
        data["source"].addEventListener("mouseenter", function (e) {
          timeout = setTimeout(function () {
            showTooltip.call(data);
          }, 200);
        });
        data["source"].addEventListener("mouseleave", function (e) {
          clearTimeout(timeout);
        });
      };

      mouseover(data);
    }

    function drooltipClick(data) {
      window.addEventListener("click", function (e) {
        if (data["source"].contains(e.target) || data["tooltip"].contains(e.target)) {
          showTooltip.call(data);
        } else {
          hideTooltip.call(data);
        }
      });
    }

    function animateOrDeanimate(fn, data) {
      if (fn === "animate") {
        showTooltip.call(data);
      } else {
        hideTooltip.call(data);
      }
    }

    function animateOrDeanimateAll(fn) {
      var instances = this.tooltips;

      for (var i in instances) {
        if (fn === "animate") {
          showTooltip.call(instances[i], this.tooltips[i]["options"]);
        } else {
          hideTooltip.call(instances[i], this.tooltips[i]["options"]);
        }
      }
    }

    function showOrHideAllTooltips(fn) {
      var instances = this.tooltips;

      for (var i in instances) {
        if (fn === "show") {
          instances[i]["tooltip"].classList.remove("hideTooltip");
        } else {
          instances[i]["tooltip"].classList.add("hideTooltip");
        }
      }
    }
    /** Global Objects, contains tooltips across all instances in a page; 
    required for setting positions and processing ajax/jsonp requests **/


    var tooltips = {},
        requests = {},
        standardAnimations = ["bounce", "fade", "material", "float"];
    /** Build(); Creates tooltips for given element(s) **/

    Drooltip.prototype.build = function () {
      var elems = document.querySelectorAll(this.options["element"]),
          id = this.options["element"];

      var _ = this;

      tooltips[id] = {};
      this.tooltips = {};

      for (var i = 0; i < elems.length; ++i) {
        elems[i].setAttribute("data-id", i);

        var options = _extends({}, this.options),
            privateOptions = elems[i].getAttribute("data-options"),
            privateContent = elems[i].getAttribute("title");

        if (privateOptions !== null) {
          for (var x in privateOptions.split(";")) {
            var property = privateOptions.split(";")[x].split(":")[0];

            if (property !== "content") {
              var value = privateOptions.split(";")[x].split(":")[1];
              options[property] = value;
            }
          }
        }

        if (privateContent !== null && privateContent !== "") {
          options["content"] = formatPrivateContent(privateContent);
          elems[i].removeAttribute("title");
        }

        if (options["content"] !== null) {
          var tooltip = createTooltip(id + "_" + i, elems[i], options);
          tooltips[id][i] = {
            "id": id + "_" + i,
            "source": elems[i],
            tooltip: tooltip,
            options: options
          };
          this.tooltips[i] = {
            "id": id + "_" + i,
            "source": elems[i],
            tooltip: tooltip,
            options: options
          };
        }

        attachTriggerEvent.call(_, this.tooltips[i]);
      }
    };

    Drooltip.prototype.animateAllTooltips = function () {
      animateOrDeanimateAll.call(this, "animate");
    };

    Drooltip.prototype.deanimateAllTooltips = function () {
      animateOrDeanimateAll.call(this, "deanimate");
    };

    Drooltip.prototype.animateTooltip = function (data) {
      animateOrDeanimate.call(this, "animate", data);
    };

    Drooltip.prototype.deanimateTooltip = function (data) {
      animateOrDeanimate.call(this, "deanimate", data);
    };

    Drooltip.prototype.hideAllTooltips = function () {
      showOrHideAllTooltips.call(this, "hide");
    };

    Drooltip.prototype.showAllTooltips = function () {
      showOrHideAllTooltips.call(this, "show");
    };

    Drooltip.prototype.hideTooltip = function (tooltip) {
      tooltip.classList.add("hideTooltip");
    };

    Drooltip.prototype.showTooltip = function (tooltip) {
      tooltip.classList.remove("hideTooltip");
    };

    Drooltip.prototype.addStandardEffect = function (elem, effect) {
      addStandardEffect(elem, effect);
    };

    Drooltip.prototype.removeStandardEffect = function (elem, effect) {
      removeStandardEffect(elem, effect);
    };

    Drooltip.prototype.showArrow = function (elem) {
      arrowDisplay(elem, "show");
    };

    Drooltip.prototype.hideArrow = function (elem) {
      arrowDisplay(elem, "hide");
    };

    Drooltip.prototype.loadRequests = function () {
      for (var i in requests) {
        var elem = document.querySelector("[data-identifiers='" + i + "']");
        requestsHandler(requests[i], elem);
      }
    };
    /** Sets tooltips position **/


    Drooltip.prototype.setTooltipsPos = function () {
      var _ = this;

      for (var i in tooltips) {
        for (var j in tooltips[i]) {
          var current = tooltips[i][j];
          var position = current["options"]["position"];
          var source = current["source"];
          var tooltip = current["tooltip"];
          var sourceDimensions = getElemDimensions(source);
          var tooltipDimensions = getElemDimensions(tooltip);
          getPosition(tooltip, source, position);
        }
      }
    };

    Drooltip.prototype.updatePosition = function (data) {
      getPosition(data["tooltip"], data["source"], data["options"]["position"]);
    };

    function attachTriggerEvent(data) {
      var source = data["source"],
          tooltip = data["tooltip"],
          options = data["options"],
          trigger = options["trigger"];
      tooltip.classList.add("loaded");
      listenerAdd.call(this, data, trigger);
    }
  })();

  window.onload = function () {
    Drooltip.prototype.setTooltipsPos();
    window.addEventListener('scroll', function () {
      Drooltip.prototype.setTooltipsPos();
    }, true);

    window.onresize = function () {
      Drooltip.prototype.setTooltipsPos();
    };
  };
  /***/

}]);
/*!
  * Bootstrap data.js v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Data = factory());
})(this, function () {
  'use strict';
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): dom/data.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  const elementMap = new Map();
  var data = {
    set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, new Map());
      }

      const instanceMap = elementMap.get(element); // make it clear we only want one instance per element
      // can be removed later when multiple key/instances are fine to be used

      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        // eslint-disable-next-line no-console
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
        return;
      }

      instanceMap.set(key, instance);
    },

    get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }

      return null;
    },

    remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }

      const instanceMap = elementMap.get(element);
      instanceMap.delete(key); // free up element references if there are no instances left for an element

      if (instanceMap.size === 0) {
        elementMap.delete(element);
      }
    }

  };
  return data;
});
/*!
  * Bootstrap event-handler.js v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.EventHandler = factory());
})(this, function () {
  'use strict';
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const getjQuery = () => {
    const {
      jQuery
    } = window;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): dom/event-handler.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  const stripNameRegex = /\..*/;
  const stripUidRegex = /::\d+$/;
  const eventRegistry = {}; // Events storage

  let uidEvent = 1;
  const customEvents = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  };
  const customEventsRegex = /^(mouseenter|mouseleave)/i;
  const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);
  /**
   * ------------------------------------------------------------------------
   * Private methods
   * ------------------------------------------------------------------------
   */

  function getUidEvent(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
  }

  function getEvent(element) {
    const uid = getUidEvent(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }

  function bootstrapHandler(element, fn) {
    return function handler(event) {
      event.delegateTarget = element;

      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn);
      }

      return fn.apply(element, [event]);
    };
  }

  function bootstrapDelegationHandler(element, selector, fn) {
    return function handler(event) {
      const domElements = element.querySelectorAll(selector);

      for (let {
        target
      } = event; target && target !== this; target = target.parentNode) {
        for (let i = domElements.length; i--;) {
          if (domElements[i] === target) {
            event.delegateTarget = target;

            if (handler.oneOff) {
              // eslint-disable-next-line unicorn/consistent-destructuring
              EventHandler.off(element, event.type, selector, fn);
            }

            return fn.apply(target, [event]);
          }
        }
      } // To please ESLint


      return null;
    };
  }

  function findHandler(events, handler, delegationSelector = null) {
    const uidEventList = Object.keys(events);

    for (let i = 0, len = uidEventList.length; i < len; i++) {
      const event = events[uidEventList[i]];

      if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {
        return event;
      }
    }

    return null;
  }

  function normalizeParams(originalTypeEvent, handler, delegationFn) {
    const delegation = typeof handler === 'string';
    const originalHandler = delegation ? delegationFn : handler;
    let typeEvent = getTypeEvent(originalTypeEvent);
    const isNative = nativeEvents.has(typeEvent);

    if (!isNative) {
      typeEvent = originalTypeEvent;
    }

    return [delegation, originalHandler, typeEvent];
  }

  function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }

    if (!handler) {
      handler = delegationFn;
      delegationFn = null;
    } // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
    // this prevents the handler from being dispatched the same way as mouseover or mouseout does


    if (customEventsRegex.test(originalTypeEvent)) {
      const wrapFn = fn => {
        return function (event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn.call(this, event);
          }
        };
      };

      if (delegationFn) {
        delegationFn = wrapFn(delegationFn);
      } else {
        handler = wrapFn(handler);
      }
    }

    const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
    const events = getEvent(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);

    if (previousFn) {
      previousFn.oneOff = previousFn.oneOff && oneOff;
      return;
    }

    const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ''));
    const fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);
    fn.delegationSelector = delegation ? handler : null;
    fn.originalHandler = originalHandler;
    fn.oneOff = oneOff;
    fn.uidEvent = uid;
    handlers[uid] = fn;
    element.addEventListener(typeEvent, fn, delegation);
  }

  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn = findHandler(events[typeEvent], handler, delegationSelector);

    if (!fn) {
      return;
    }

    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
    delete events[typeEvent][fn.uidEvent];
  }

  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    Object.keys(storeElementEvent).forEach(handlerKey => {
      if (handlerKey.includes(namespace)) {
        const event = storeElementEvent[handlerKey];
        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
      }
    });
  }

  function getTypeEvent(event) {
    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
    event = event.replace(stripNameRegex, '');
    return customEvents[event] || event;
  }

  const EventHandler = {
    on(element, event, handler, delegationFn) {
      addHandler(element, event, handler, delegationFn, false);
    },

    one(element, event, handler, delegationFn) {
      addHandler(element, event, handler, delegationFn, true);
    },

    off(element, originalTypeEvent, handler, delegationFn) {
      if (typeof originalTypeEvent !== 'string' || !element) {
        return;
      }

      const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
      const inNamespace = typeEvent !== originalTypeEvent;
      const events = getEvent(element);
      const isNamespace = originalTypeEvent.startsWith('.');

      if (typeof originalHandler !== 'undefined') {
        // Simplest case: handler is passed, remove that listener ONLY.
        if (!events || !events[typeEvent]) {
          return;
        }

        removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);
        return;
      }

      if (isNamespace) {
        Object.keys(events).forEach(elementEvent => {
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        });
      }

      const storeElementEvent = events[typeEvent] || {};
      Object.keys(storeElementEvent).forEach(keyHandlers => {
        const handlerKey = keyHandlers.replace(stripUidRegex, '');

        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          const event = storeElementEvent[keyHandlers];
          removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
        }
      });
    },

    trigger(element, event, args) {
      if (typeof event !== 'string' || !element) {
        return null;
      }

      const $ = getjQuery();
      const typeEvent = getTypeEvent(event);
      const inNamespace = event !== typeEvent;
      const isNative = nativeEvents.has(typeEvent);
      let jQueryEvent;
      let bubbles = true;
      let nativeDispatch = true;
      let defaultPrevented = false;
      let evt = null;

      if (inNamespace && $) {
        jQueryEvent = $.Event(event, args);
        $(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }

      if (isNative) {
        evt = document.createEvent('HTMLEvents');
        evt.initEvent(typeEvent, bubbles, true);
      } else {
        evt = new CustomEvent(event, {
          bubbles,
          cancelable: true
        });
      } // merge custom information in our event


      if (typeof args !== 'undefined') {
        Object.keys(args).forEach(key => {
          Object.defineProperty(evt, key, {
            get() {
              return args[key];
            }

          });
        });
      }

      if (defaultPrevented) {
        evt.preventDefault();
      }

      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }

      if (evt.defaultPrevented && typeof jQueryEvent !== 'undefined') {
        jQueryEvent.preventDefault();
      }

      return evt;
    }

  };
  return EventHandler;
});
/*!
  * Bootstrap manipulator.js v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Manipulator = factory());
})(this, function () {
  'use strict';
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): dom/manipulator.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  function normalizeData(val) {
    if (val === 'true') {
      return true;
    }

    if (val === 'false') {
      return false;
    }

    if (val === Number(val).toString()) {
      return Number(val);
    }

    if (val === '' || val === 'null') {
      return null;
    }

    return val;
  }

  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);
  }

  const Manipulator = {
    setDataAttribute(element, key, value) {
      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },

    removeDataAttribute(element, key) {
      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },

    getDataAttributes(element) {
      if (!element) {
        return {};
      }

      const attributes = {};
      Object.keys(element.dataset).filter(key => key.startsWith('bs')).forEach(key => {
        let pureKey = key.replace(/^bs/, '');
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      });
      return attributes;
    },

    getDataAttribute(element, key) {
      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    },

    offset(element) {
      const rect = element.getBoundingClientRect();
      return {
        top: rect.top + window.pageYOffset,
        left: rect.left + window.pageXOffset
      };
    },

    position(element) {
      return {
        top: element.offsetTop,
        left: element.offsetLeft
      };
    }

  };
  return Manipulator;
});
/*!
  * Bootstrap selector-engine.js v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.SelectorEngine = factory());
})(this, function () {
  'use strict';
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const isElement = obj => {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  const isVisible = element => {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }

    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  };

  const isDisabled = element => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): dom/selector-engine.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const NODE_TEXT = 3;
  const SelectorEngine = {
    find(selector, element = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },

    findOne(selector, element = document.documentElement) {
      return Element.prototype.querySelector.call(element, selector);
    },

    children(element, selector) {
      return [].concat(...element.children).filter(child => child.matches(selector));
    },

    parents(element, selector) {
      const parents = [];
      let ancestor = element.parentNode;

      while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {
        if (ancestor.matches(selector)) {
          parents.push(ancestor);
        }

        ancestor = ancestor.parentNode;
      }

      return parents;
    },

    prev(element, selector) {
      let previous = element.previousElementSibling;

      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }

        previous = previous.previousElementSibling;
      }

      return [];
    },

    next(element, selector) {
      let next = element.nextElementSibling;

      while (next) {
        if (next.matches(selector)) {
          return [next];
        }

        next = next.nextElementSibling;
      }

      return [];
    },

    focusableChildren(element) {
      const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(selector => `${selector}:not([tabindex^="-"])`).join(', ');
      return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));
    }

  };
  return SelectorEngine;
});
/*!
  * Bootstrap base-component.js v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/data.js'), require('./dom/event-handler.js')) : typeof define === 'function' && define.amd ? define(['./dom/data', './dom/event-handler'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Base = factory(global.Data, global.EventHandler));
})(this, function (Data, EventHandler) {
  'use strict';

  function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
      'default': e
    };
  }

  var Data__default = /*#__PURE__*/_interopDefaultLegacy(Data);

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const MILLISECONDS_MULTIPLIER = 1000;
  const TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  const getTransitionDurationFromElement = element => {
    if (!element) {
      return 0;
    } // Get transition-duration of the element


    let {
      transitionDuration,
      transitionDelay
    } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    } // If multiple durations are defined, take the first


    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };

  const triggerTransitionEnd = element => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };

  const isElement = obj => {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  const getElement = obj => {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  const execute = callback => {
    if (typeof callback === 'function') {
      callback();
    }
  };

  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }

    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;

    const handler = ({
      target
    }) => {
      if (target !== transitionElement) {
        return;
      }

      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };

    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): base-component.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  const VERSION = '5.1.0';

  class BaseComponent {
    constructor(element) {
      element = getElement(element);

      if (!element) {
        return;
      }

      this._element = element;
      Data__default['default'].set(this._element, this.constructor.DATA_KEY, this);
    }

    dispose() {
      Data__default['default'].remove(this._element, this.constructor.DATA_KEY);
      EventHandler__default['default'].off(this._element, this.constructor.EVENT_KEY);
      Object.getOwnPropertyNames(this).forEach(propertyName => {
        this[propertyName] = null;
      });
    }

    _queueCallback(callback, element, isAnimated = true) {
      executeAfterTransition(callback, element, isAnimated);
    }
    /** Static */


    static getInstance(element) {
      return Data__default['default'].get(getElement(element), this.DATA_KEY);
    }

    static getOrCreateInstance(element, config = {}) {
      return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
    }

    static get VERSION() {
      return VERSION;
    }

    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }

    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }

    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }

  }

  return BaseComponent;
});
/*!
  * Bootstrap collapse.js v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/data.js'), require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/data', './dom/event-handler', './dom/manipulator', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Collapse = factory(global.Data, global.EventHandler, global.Manipulator, global.SelectorEngine, global.Base));
})(this, function (Data, EventHandler, Manipulator, SelectorEngine, BaseComponent) {
  'use strict';

  function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
      'default': e
    };
  }

  var Data__default = /*#__PURE__*/_interopDefaultLegacy(Data);

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const toType = obj => {
    if (obj === null || obj === undefined) {
      return `${obj}`;
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  const getSelector = element => {
    let selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = `#${hrefAttr.split('#')[1]}`;
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  const getSelectorFromElement = element => {
    const selector = getSelector(element);

    if (selector) {
      return document.querySelector(selector) ? selector : null;
    }

    return null;
  };

  const getElementFromSelector = element => {
    const selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  const isElement = obj => {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  const getElement = obj => {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  const typeCheckConfig = (componentName, config, configTypes) => {
    Object.keys(configTypes).forEach(property => {
      const expectedTypes = configTypes[property];
      const value = config[property];
      const valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    });
  };
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  const reflow = element => {
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
  };

  const getjQuery = () => {
    const {
      jQuery
    } = window;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  const DOMContentLoadedCallbacks = [];

  const onDOMContentLoaded = callback => {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', () => {
          DOMContentLoadedCallbacks.forEach(callback => callback());
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  const defineJQueryPlugin = plugin => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): collapse.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  const NAME = 'collapse';
  const DATA_KEY = 'bs.collapse';
  const EVENT_KEY = `.${DATA_KEY}`;
  const DATA_API_KEY = '.data-api';
  const Default = {
    toggle: true,
    parent: null
  };
  const DefaultType = {
    toggle: 'boolean',
    parent: '(null|element)'
  };
  const EVENT_SHOW = `show${EVENT_KEY}`;
  const EVENT_SHOWN = `shown${EVENT_KEY}`;
  const EVENT_HIDE = `hide${EVENT_KEY}`;
  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  const EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;
  const CLASS_NAME_SHOW = 'show';
  const CLASS_NAME_COLLAPSE = 'collapse';
  const CLASS_NAME_COLLAPSING = 'collapsing';
  const CLASS_NAME_COLLAPSED = 'collapsed';
  const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
  const WIDTH = 'width';
  const HEIGHT = 'height';
  const SELECTOR_ACTIVES = '.show, .collapsing';
  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="collapse"]';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  class Collapse extends BaseComponent__default['default'] {
    constructor(element, config) {
      super(element);
      this._isTransitioning = false;
      this._config = this._getConfig(config);
      this._triggerArray = [];
      const toggleList = SelectorEngine__default['default'].find(SELECTOR_DATA_TOGGLE);

      for (let i = 0, len = toggleList.length; i < len; i++) {
        const elem = toggleList[i];
        const selector = getSelectorFromElement(elem);
        const filterElement = SelectorEngine__default['default'].find(selector).filter(foundElem => foundElem === this._element);

        if (selector !== null && filterElement.length) {
          this._selector = selector;

          this._triggerArray.push(elem);
        }
      }

      this._initializeChildren();

      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }

      if (this._config.toggle) {
        this.toggle();
      }
    } // Getters


    static get Default() {
      return Default;
    }

    static get NAME() {
      return NAME;
    } // Public


    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }

    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }

      let actives = [];
      let activesData;

      if (this._config.parent) {
        const children = SelectorEngine__default['default'].find(`.${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`, this._config.parent);
        actives = SelectorEngine__default['default'].find(SELECTOR_ACTIVES, this._config.parent).filter(elem => !children.includes(elem)); // remove children if greater depth
      }

      const container = SelectorEngine__default['default'].findOne(this._selector);

      if (actives.length) {
        const tempActiveData = actives.find(elem => container !== elem);
        activesData = tempActiveData ? Collapse.getInstance(tempActiveData) : null;

        if (activesData && activesData._isTransitioning) {
          return;
        }
      }

      const startEvent = EventHandler__default['default'].trigger(this._element, EVENT_SHOW);

      if (startEvent.defaultPrevented) {
        return;
      }

      actives.forEach(elemActive => {
        if (container !== elemActive) {
          Collapse.getOrCreateInstance(elemActive, {
            toggle: false
          }).hide();
        }

        if (!activesData) {
          Data__default['default'].set(elemActive, DATA_KEY, null);
        }
      });

      const dimension = this._getDimension();

      this._element.classList.remove(CLASS_NAME_COLLAPSE);

      this._element.classList.add(CLASS_NAME_COLLAPSING);

      this._element.style[dimension] = 0;

      this._addAriaAndCollapsedClass(this._triggerArray, true);

      this._isTransitioning = true;

      const complete = () => {
        this._isTransitioning = false;

        this._element.classList.remove(CLASS_NAME_COLLAPSING);

        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW);

        this._element.style[dimension] = '';
        EventHandler__default['default'].trigger(this._element, EVENT_SHOWN);
      };

      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      const scrollSize = `scroll${capitalizedDimension}`;

      this._queueCallback(complete, this._element, true);

      this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }

    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }

      const startEvent = EventHandler__default['default'].trigger(this._element, EVENT_HIDE);

      if (startEvent.defaultPrevented) {
        return;
      }

      const dimension = this._getDimension();

      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
      reflow(this._element);

      this._element.classList.add(CLASS_NAME_COLLAPSING);

      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW);

      const triggerArrayLength = this._triggerArray.length;

      for (let i = 0; i < triggerArrayLength; i++) {
        const trigger = this._triggerArray[i];
        const elem = getElementFromSelector(trigger);

        if (elem && !this._isShown(elem)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }

      this._isTransitioning = true;

      const complete = () => {
        this._isTransitioning = false;

        this._element.classList.remove(CLASS_NAME_COLLAPSING);

        this._element.classList.add(CLASS_NAME_COLLAPSE);

        EventHandler__default['default'].trigger(this._element, EVENT_HIDDEN);
      };

      this._element.style[dimension] = '';

      this._queueCallback(complete, this._element, true);
    }

    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW);
    } // Private


    _getConfig(config) {
      config = { ...Default,
        ...Manipulator__default['default'].getDataAttributes(this._element),
        ...config
      };
      config.toggle = Boolean(config.toggle); // Coerce string values

      config.parent = getElement(config.parent);
      typeCheckConfig(NAME, config, DefaultType);
      return config;
    }

    _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }

    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }

      const children = SelectorEngine__default['default'].find(`.${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`, this._config.parent);
      SelectorEngine__default['default'].find(SELECTOR_DATA_TOGGLE, this._config.parent).filter(elem => !children.includes(elem)).forEach(element => {
        const selected = getElementFromSelector(element);

        if (selected) {
          this._addAriaAndCollapsedClass([element], this._isShown(selected));
        }
      });
    }

    _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }

      triggerArray.forEach(elem => {
        if (isOpen) {
          elem.classList.remove(CLASS_NAME_COLLAPSED);
        } else {
          elem.classList.add(CLASS_NAME_COLLAPSED);
        }

        elem.setAttribute('aria-expanded', isOpen);
      });
    } // Static


    static jQueryInterface(config) {
      return this.each(function () {
        const _config = {};

        if (typeof config === 'string' && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        const data = Collapse.getOrCreateInstance(this, _config);

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError(`No method named "${config}"`);
          }

          data[config]();
        }
      });
    }

  }
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default['default'].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
      event.preventDefault();
    }

    const selector = getSelectorFromElement(this);
    const selectorElements = SelectorEngine__default['default'].find(selector);
    selectorElements.forEach(element => {
      Collapse.getOrCreateInstance(element, {
        toggle: false
      }).toggle();
    });
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Collapse to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Collapse);
  return Collapse;
});
/*!
  * Bootstrap modal.js v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/event-handler', './dom/manipulator', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Modal = factory(global.EventHandler, global.Manipulator, global.SelectorEngine, global.Base));
})(this, function (EventHandler, Manipulator, SelectorEngine, BaseComponent) {
  'use strict';

  function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
      'default': e
    };
  }

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const MILLISECONDS_MULTIPLIER = 1000;
  const TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  const toType = obj => {
    if (obj === null || obj === undefined) {
      return `${obj}`;
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  const getSelector = element => {
    let selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = `#${hrefAttr.split('#')[1]}`;
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  const getElementFromSelector = element => {
    const selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  const getTransitionDurationFromElement = element => {
    if (!element) {
      return 0;
    } // Get transition-duration of the element


    let {
      transitionDuration,
      transitionDelay
    } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    } // If multiple durations are defined, take the first


    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };

  const triggerTransitionEnd = element => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };

  const isElement = obj => {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  const getElement = obj => {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  const typeCheckConfig = (componentName, config, configTypes) => {
    Object.keys(configTypes).forEach(property => {
      const expectedTypes = configTypes[property];
      const value = config[property];
      const valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    });
  };

  const isVisible = element => {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }

    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  };

  const isDisabled = element => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  const reflow = element => {
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
  };

  const getjQuery = () => {
    const {
      jQuery
    } = window;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  const DOMContentLoadedCallbacks = [];

  const onDOMContentLoaded = callback => {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', () => {
          DOMContentLoadedCallbacks.forEach(callback => callback());
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  const isRTL = () => document.documentElement.dir === 'rtl';

  const defineJQueryPlugin = plugin => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };

  const execute = callback => {
    if (typeof callback === 'function') {
      callback();
    }
  };

  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }

    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;

    const handler = ({
      target
    }) => {
      if (target !== transitionElement) {
        return;
      }

      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };

    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/scrollBar.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
  const SELECTOR_STICKY_CONTENT = '.sticky-top';

  class ScrollBarHelper {
    constructor() {
      this._element = document.body;
    }

    getWidth() {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }

    hide() {
      const width = this.getWidth();

      this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width


      this._setElementAttributes(this._element, 'paddingRight', calculatedValue => calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth


      this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', calculatedValue => calculatedValue + width);

      this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', calculatedValue => calculatedValue - width);
    }

    _disableOverFlow() {
      this._saveInitialAttribute(this._element, 'overflow');

      this._element.style.overflow = 'hidden';
    }

    _setElementAttributes(selector, styleProp, callback) {
      const scrollbarWidth = this.getWidth();

      const manipulationCallBack = element => {
        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }

        this._saveInitialAttribute(element, styleProp);

        const calculatedValue = window.getComputedStyle(element)[styleProp];
        element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;
      };

      this._applyManipulationCallback(selector, manipulationCallBack);
    }

    reset() {
      this._resetElementAttributes(this._element, 'overflow');

      this._resetElementAttributes(this._element, 'paddingRight');

      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');

      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');
    }

    _saveInitialAttribute(element, styleProp) {
      const actualValue = element.style[styleProp];

      if (actualValue) {
        Manipulator__default['default'].setDataAttribute(element, styleProp, actualValue);
      }
    }

    _resetElementAttributes(selector, styleProp) {
      const manipulationCallBack = element => {
        const value = Manipulator__default['default'].getDataAttribute(element, styleProp);

        if (typeof value === 'undefined') {
          element.style.removeProperty(styleProp);
        } else {
          Manipulator__default['default'].removeDataAttribute(element, styleProp);
          element.style[styleProp] = value;
        }
      };

      this._applyManipulationCallback(selector, manipulationCallBack);
    }

    _applyManipulationCallback(selector, callBack) {
      if (isElement(selector)) {
        callBack(selector);
      } else {
        SelectorEngine__default['default'].find(selector, this._element).forEach(callBack);
      }
    }

    isOverflowing() {
      return this.getWidth() > 0;
    }

  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/backdrop.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */


  const Default$2 = {
    className: 'modal-backdrop',
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    isAnimated: false,
    rootElement: 'body',
    // give the choice to place backdrop under different elements
    clickCallback: null
  };
  const DefaultType$2 = {
    className: 'string',
    isVisible: 'boolean',
    isAnimated: 'boolean',
    rootElement: '(element|string)',
    clickCallback: '(function|null)'
  };
  const NAME$2 = 'backdrop';
  const CLASS_NAME_FADE$1 = 'fade';
  const CLASS_NAME_SHOW$1 = 'show';
  const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$2}`;

  class Backdrop {
    constructor(config) {
      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }

    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }

      this._append();

      if (this._config.isAnimated) {
        reflow(this._getElement());
      }

      this._getElement().classList.add(CLASS_NAME_SHOW$1);

      this._emulateAnimation(() => {
        execute(callback);
      });
    }

    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }

      this._getElement().classList.remove(CLASS_NAME_SHOW$1);

      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    } // Private


    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement('div');
        backdrop.className = this._config.className;

        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE$1);
        }

        this._element = backdrop;
      }

      return this._element;
    }

    _getConfig(config) {
      config = { ...Default$2,
        ...(typeof config === 'object' ? config : {})
      }; // use getElement() with the default "body" to get a fresh Element on each instantiation

      config.rootElement = getElement(config.rootElement);
      typeCheckConfig(NAME$2, config, DefaultType$2);
      return config;
    }

    _append() {
      if (this._isAppended) {
        return;
      }

      this._config.rootElement.append(this._getElement());

      EventHandler__default['default'].on(this._getElement(), EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }

    dispose() {
      if (!this._isAppended) {
        return;
      }

      EventHandler__default['default'].off(this._element, EVENT_MOUSEDOWN);

      this._element.remove();

      this._isAppended = false;
    }

    _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }

  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/focustrap.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */


  const Default$1 = {
    trapElement: null,
    // The element to trap focus inside of
    autofocus: true
  };
  const DefaultType$1 = {
    trapElement: 'element',
    autofocus: 'boolean'
  };
  const NAME$1 = 'focustrap';
  const DATA_KEY$1 = 'bs.focustrap';
  const EVENT_KEY$1 = `.${DATA_KEY$1}`;
  const EVENT_FOCUSIN = `focusin${EVENT_KEY$1}`;
  const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$1}`;
  const TAB_KEY = 'Tab';
  const TAB_NAV_FORWARD = 'forward';
  const TAB_NAV_BACKWARD = 'backward';

  class FocusTrap {
    constructor(config) {
      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }

    activate() {
      const {
        trapElement,
        autofocus
      } = this._config;

      if (this._isActive) {
        return;
      }

      if (autofocus) {
        trapElement.focus();
      }

      EventHandler__default['default'].off(document, EVENT_KEY$1); // guard against infinite focus loop

      EventHandler__default['default'].on(document, EVENT_FOCUSIN, event => this._handleFocusin(event));
      EventHandler__default['default'].on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
      this._isActive = true;
    }

    deactivate() {
      if (!this._isActive) {
        return;
      }

      this._isActive = false;
      EventHandler__default['default'].off(document, EVENT_KEY$1);
    } // Private


    _handleFocusin(event) {
      const {
        target
      } = event;
      const {
        trapElement
      } = this._config;

      if (target === document || target === trapElement || trapElement.contains(target)) {
        return;
      }

      const elements = SelectorEngine__default['default'].focusableChildren(trapElement);

      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }

    _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }

      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }

    _getConfig(config) {
      config = { ...Default$1,
        ...(typeof config === 'object' ? config : {})
      };
      typeCheckConfig(NAME$1, config, DefaultType$1);
      return config;
    }

  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/component-functions.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const enableDismissTrigger = (component, method = 'hide') => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler__default['default'].on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function (event) {
      if (['A', 'AREA'].includes(this.tagName)) {
        event.preventDefault();
      }

      if (isDisabled(this)) {
        return;
      }

      const target = getElementFromSelector(this) || this.closest(`.${name}`);
      const instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method

      instance[method]();
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  const NAME = 'modal';
  const DATA_KEY = 'bs.modal';
  const EVENT_KEY = `.${DATA_KEY}`;
  const DATA_API_KEY = '.data-api';
  const ESCAPE_KEY = 'Escape';
  const Default = {
    backdrop: true,
    keyboard: true,
    focus: true
  };
  const DefaultType = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    focus: 'boolean'
  };
  const EVENT_HIDE = `hide${EVENT_KEY}`;
  const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY}`;
  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  const EVENT_SHOW = `show${EVENT_KEY}`;
  const EVENT_SHOWN = `shown${EVENT_KEY}`;
  const EVENT_RESIZE = `resize${EVENT_KEY}`;
  const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY}`;
  const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY}`;
  const EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY}`;
  const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY}`;
  const EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;
  const CLASS_NAME_OPEN = 'modal-open';
  const CLASS_NAME_FADE = 'fade';
  const CLASS_NAME_SHOW = 'show';
  const CLASS_NAME_STATIC = 'modal-static';
  const SELECTOR_DIALOG = '.modal-dialog';
  const SELECTOR_MODAL_BODY = '.modal-body';
  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="modal"]';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  class Modal extends BaseComponent__default['default'] {
    constructor(element, config) {
      super(element);
      this._config = this._getConfig(config);
      this._dialog = SelectorEngine__default['default'].findOne(SELECTOR_DIALOG, this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._ignoreBackdropClick = false;
      this._isTransitioning = false;
      this._scrollBar = new ScrollBarHelper();
    } // Getters


    static get Default() {
      return Default;
    }

    static get NAME() {
      return NAME;
    } // Public


    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }

    show(relatedTarget) {
      if (this._isShown || this._isTransitioning) {
        return;
      }

      const showEvent = EventHandler__default['default'].trigger(this._element, EVENT_SHOW, {
        relatedTarget
      });

      if (showEvent.defaultPrevented) {
        return;
      }

      this._isShown = true;

      if (this._isAnimated()) {
        this._isTransitioning = true;
      }

      this._scrollBar.hide();

      document.body.classList.add(CLASS_NAME_OPEN);

      this._adjustDialog();

      this._setEscapeEvent();

      this._setResizeEvent();

      EventHandler__default['default'].on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => {
        EventHandler__default['default'].one(this._element, EVENT_MOUSEUP_DISMISS, event => {
          if (event.target === this._element) {
            this._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(() => this._showElement(relatedTarget));
    }

    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }

      const hideEvent = EventHandler__default['default'].trigger(this._element, EVENT_HIDE);

      if (hideEvent.defaultPrevented) {
        return;
      }

      this._isShown = false;

      const isAnimated = this._isAnimated();

      if (isAnimated) {
        this._isTransitioning = true;
      }

      this._setEscapeEvent();

      this._setResizeEvent();

      this._focustrap.deactivate();

      this._element.classList.remove(CLASS_NAME_SHOW);

      EventHandler__default['default'].off(this._element, EVENT_CLICK_DISMISS);
      EventHandler__default['default'].off(this._dialog, EVENT_MOUSEDOWN_DISMISS);

      this._queueCallback(() => this._hideModal(), this._element, isAnimated);
    }

    dispose() {
      [window, this._dialog].forEach(htmlElement => EventHandler__default['default'].off(htmlElement, EVENT_KEY));

      this._backdrop.dispose();

      this._focustrap.deactivate();

      super.dispose();
    }

    handleUpdate() {
      this._adjustDialog();
    } // Private


    _initializeBackDrop() {
      return new Backdrop({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value
        isAnimated: this._isAnimated()
      });
    }

    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }

    _getConfig(config) {
      config = { ...Default,
        ...Manipulator__default['default'].getDataAttributes(this._element),
        ...(typeof config === 'object' ? config : {})
      };
      typeCheckConfig(NAME, config, DefaultType);
      return config;
    }

    _showElement(relatedTarget) {
      const isAnimated = this._isAnimated();

      const modalBody = SelectorEngine__default['default'].findOne(SELECTOR_MODAL_BODY, this._dialog);

      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // Don't move modal's DOM position
        document.body.append(this._element);
      }

      this._element.style.display = 'block';

      this._element.removeAttribute('aria-hidden');

      this._element.setAttribute('aria-modal', true);

      this._element.setAttribute('role', 'dialog');

      this._element.scrollTop = 0;

      if (modalBody) {
        modalBody.scrollTop = 0;
      }

      if (isAnimated) {
        reflow(this._element);
      }

      this._element.classList.add(CLASS_NAME_SHOW);

      const transitionComplete = () => {
        if (this._config.focus) {
          this._focustrap.activate();
        }

        this._isTransitioning = false;
        EventHandler__default['default'].trigger(this._element, EVENT_SHOWN, {
          relatedTarget
        });
      };

      this._queueCallback(transitionComplete, this._dialog, isAnimated);
    }

    _setEscapeEvent() {
      if (this._isShown) {
        EventHandler__default['default'].on(this._element, EVENT_KEYDOWN_DISMISS, event => {
          if (this._config.keyboard && event.key === ESCAPE_KEY) {
            event.preventDefault();
            this.hide();
          } else if (!this._config.keyboard && event.key === ESCAPE_KEY) {
            this._triggerBackdropTransition();
          }
        });
      } else {
        EventHandler__default['default'].off(this._element, EVENT_KEYDOWN_DISMISS);
      }
    }

    _setResizeEvent() {
      if (this._isShown) {
        EventHandler__default['default'].on(window, EVENT_RESIZE, () => this._adjustDialog());
      } else {
        EventHandler__default['default'].off(window, EVENT_RESIZE);
      }
    }

    _hideModal() {
      this._element.style.display = 'none';

      this._element.setAttribute('aria-hidden', true);

      this._element.removeAttribute('aria-modal');

      this._element.removeAttribute('role');

      this._isTransitioning = false;

      this._backdrop.hide(() => {
        document.body.classList.remove(CLASS_NAME_OPEN);

        this._resetAdjustments();

        this._scrollBar.reset();

        EventHandler__default['default'].trigger(this._element, EVENT_HIDDEN);
      });
    }

    _showBackdrop(callback) {
      EventHandler__default['default'].on(this._element, EVENT_CLICK_DISMISS, event => {
        if (this._ignoreBackdropClick) {
          this._ignoreBackdropClick = false;
          return;
        }

        if (event.target !== event.currentTarget) {
          return;
        }

        if (this._config.backdrop === true) {
          this.hide();
        } else if (this._config.backdrop === 'static') {
          this._triggerBackdropTransition();
        }
      });

      this._backdrop.show(callback);
    }

    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE);
    }

    _triggerBackdropTransition() {
      const hideEvent = EventHandler__default['default'].trigger(this._element, EVENT_HIDE_PREVENTED);

      if (hideEvent.defaultPrevented) {
        return;
      }

      const {
        classList,
        scrollHeight,
        style
      } = this._element;
      const isModalOverflowing = scrollHeight > document.documentElement.clientHeight; // return if the following background transition hasn't yet completed

      if (!isModalOverflowing && style.overflowY === 'hidden' || classList.contains(CLASS_NAME_STATIC)) {
        return;
      }

      if (!isModalOverflowing) {
        style.overflowY = 'hidden';
      }

      classList.add(CLASS_NAME_STATIC);

      this._queueCallback(() => {
        classList.remove(CLASS_NAME_STATIC);

        if (!isModalOverflowing) {
          this._queueCallback(() => {
            style.overflowY = '';
          }, this._dialog);
        }
      }, this._dialog);

      this._element.focus();
    } // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // ----------------------------------------------------------------------


    _adjustDialog() {
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      const scrollbarWidth = this._scrollBar.getWidth();

      const isBodyOverflowing = scrollbarWidth > 0;

      if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) {
        this._element.style.paddingLeft = `${scrollbarWidth}px`;
      }

      if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) {
        this._element.style.paddingRight = `${scrollbarWidth}px`;
      }
    }

    _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    } // Static


    static jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        const data = Modal.getOrCreateInstance(this, config);

        if (typeof config !== 'string') {
          return;
        }

        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config](relatedTarget);
      });
    }

  }
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default['default'].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    const target = getElementFromSelector(this);

    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    EventHandler__default['default'].one(target, EVENT_SHOW, showEvent => {
      if (showEvent.defaultPrevented) {
        // only register focus restorer if modal will actually get shown
        return;
      }

      EventHandler__default['default'].one(target, EVENT_HIDDEN, () => {
        if (isVisible(this)) {
          this.focus();
        }
      });
    });
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Modal to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Modal);
  return Modal;
});
/*!
  * Bootstrap offcanvas.js v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/selector-engine.js'), require('./dom/manipulator.js'), require('./dom/event-handler.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/selector-engine', './dom/manipulator', './dom/event-handler', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Offcanvas = factory(global.SelectorEngine, global.Manipulator, global.EventHandler, global.Base));
})(this, function (SelectorEngine, Manipulator, EventHandler, BaseComponent) {
  'use strict';

  function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
      'default': e
    };
  }

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const MILLISECONDS_MULTIPLIER = 1000;
  const TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  const toType = obj => {
    if (obj === null || obj === undefined) {
      return `${obj}`;
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  const getSelector = element => {
    let selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = `#${hrefAttr.split('#')[1]}`;
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  const getElementFromSelector = element => {
    const selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  const getTransitionDurationFromElement = element => {
    if (!element) {
      return 0;
    } // Get transition-duration of the element


    let {
      transitionDuration,
      transitionDelay
    } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    } // If multiple durations are defined, take the first


    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };

  const triggerTransitionEnd = element => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };

  const isElement = obj => {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  const getElement = obj => {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  const typeCheckConfig = (componentName, config, configTypes) => {
    Object.keys(configTypes).forEach(property => {
      const expectedTypes = configTypes[property];
      const value = config[property];
      const valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    });
  };

  const isVisible = element => {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }

    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  };

  const isDisabled = element => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  const reflow = element => {
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
  };

  const getjQuery = () => {
    const {
      jQuery
    } = window;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  const DOMContentLoadedCallbacks = [];

  const onDOMContentLoaded = callback => {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', () => {
          DOMContentLoadedCallbacks.forEach(callback => callback());
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  const defineJQueryPlugin = plugin => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };

  const execute = callback => {
    if (typeof callback === 'function') {
      callback();
    }
  };

  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }

    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;

    const handler = ({
      target
    }) => {
      if (target !== transitionElement) {
        return;
      }

      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };

    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/scrollBar.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
  const SELECTOR_STICKY_CONTENT = '.sticky-top';

  class ScrollBarHelper {
    constructor() {
      this._element = document.body;
    }

    getWidth() {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }

    hide() {
      const width = this.getWidth();

      this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width


      this._setElementAttributes(this._element, 'paddingRight', calculatedValue => calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth


      this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', calculatedValue => calculatedValue + width);

      this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', calculatedValue => calculatedValue - width);
    }

    _disableOverFlow() {
      this._saveInitialAttribute(this._element, 'overflow');

      this._element.style.overflow = 'hidden';
    }

    _setElementAttributes(selector, styleProp, callback) {
      const scrollbarWidth = this.getWidth();

      const manipulationCallBack = element => {
        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }

        this._saveInitialAttribute(element, styleProp);

        const calculatedValue = window.getComputedStyle(element)[styleProp];
        element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;
      };

      this._applyManipulationCallback(selector, manipulationCallBack);
    }

    reset() {
      this._resetElementAttributes(this._element, 'overflow');

      this._resetElementAttributes(this._element, 'paddingRight');

      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');

      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');
    }

    _saveInitialAttribute(element, styleProp) {
      const actualValue = element.style[styleProp];

      if (actualValue) {
        Manipulator__default['default'].setDataAttribute(element, styleProp, actualValue);
      }
    }

    _resetElementAttributes(selector, styleProp) {
      const manipulationCallBack = element => {
        const value = Manipulator__default['default'].getDataAttribute(element, styleProp);

        if (typeof value === 'undefined') {
          element.style.removeProperty(styleProp);
        } else {
          Manipulator__default['default'].removeDataAttribute(element, styleProp);
          element.style[styleProp] = value;
        }
      };

      this._applyManipulationCallback(selector, manipulationCallBack);
    }

    _applyManipulationCallback(selector, callBack) {
      if (isElement(selector)) {
        callBack(selector);
      } else {
        SelectorEngine__default['default'].find(selector, this._element).forEach(callBack);
      }
    }

    isOverflowing() {
      return this.getWidth() > 0;
    }

  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/backdrop.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */


  const Default$2 = {
    className: 'modal-backdrop',
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    isAnimated: false,
    rootElement: 'body',
    // give the choice to place backdrop under different elements
    clickCallback: null
  };
  const DefaultType$2 = {
    className: 'string',
    isVisible: 'boolean',
    isAnimated: 'boolean',
    rootElement: '(element|string)',
    clickCallback: '(function|null)'
  };
  const NAME$2 = 'backdrop';
  const CLASS_NAME_FADE = 'fade';
  const CLASS_NAME_SHOW$1 = 'show';
  const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$2}`;

  class Backdrop {
    constructor(config) {
      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }

    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }

      this._append();

      if (this._config.isAnimated) {
        reflow(this._getElement());
      }

      this._getElement().classList.add(CLASS_NAME_SHOW$1);

      this._emulateAnimation(() => {
        execute(callback);
      });
    }

    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }

      this._getElement().classList.remove(CLASS_NAME_SHOW$1);

      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    } // Private


    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement('div');
        backdrop.className = this._config.className;

        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE);
        }

        this._element = backdrop;
      }

      return this._element;
    }

    _getConfig(config) {
      config = { ...Default$2,
        ...(typeof config === 'object' ? config : {})
      }; // use getElement() with the default "body" to get a fresh Element on each instantiation

      config.rootElement = getElement(config.rootElement);
      typeCheckConfig(NAME$2, config, DefaultType$2);
      return config;
    }

    _append() {
      if (this._isAppended) {
        return;
      }

      this._config.rootElement.append(this._getElement());

      EventHandler__default['default'].on(this._getElement(), EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }

    dispose() {
      if (!this._isAppended) {
        return;
      }

      EventHandler__default['default'].off(this._element, EVENT_MOUSEDOWN);

      this._element.remove();

      this._isAppended = false;
    }

    _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }

  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/focustrap.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */


  const Default$1 = {
    trapElement: null,
    // The element to trap focus inside of
    autofocus: true
  };
  const DefaultType$1 = {
    trapElement: 'element',
    autofocus: 'boolean'
  };
  const NAME$1 = 'focustrap';
  const DATA_KEY$1 = 'bs.focustrap';
  const EVENT_KEY$1 = `.${DATA_KEY$1}`;
  const EVENT_FOCUSIN = `focusin${EVENT_KEY$1}`;
  const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$1}`;
  const TAB_KEY = 'Tab';
  const TAB_NAV_FORWARD = 'forward';
  const TAB_NAV_BACKWARD = 'backward';

  class FocusTrap {
    constructor(config) {
      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }

    activate() {
      const {
        trapElement,
        autofocus
      } = this._config;

      if (this._isActive) {
        return;
      }

      if (autofocus) {
        trapElement.focus();
      }

      EventHandler__default['default'].off(document, EVENT_KEY$1); // guard against infinite focus loop

      EventHandler__default['default'].on(document, EVENT_FOCUSIN, event => this._handleFocusin(event));
      EventHandler__default['default'].on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
      this._isActive = true;
    }

    deactivate() {
      if (!this._isActive) {
        return;
      }

      this._isActive = false;
      EventHandler__default['default'].off(document, EVENT_KEY$1);
    } // Private


    _handleFocusin(event) {
      const {
        target
      } = event;
      const {
        trapElement
      } = this._config;

      if (target === document || target === trapElement || trapElement.contains(target)) {
        return;
      }

      const elements = SelectorEngine__default['default'].focusableChildren(trapElement);

      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }

    _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }

      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }

    _getConfig(config) {
      config = { ...Default$1,
        ...(typeof config === 'object' ? config : {})
      };
      typeCheckConfig(NAME$1, config, DefaultType$1);
      return config;
    }

  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/component-functions.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const enableDismissTrigger = (component, method = 'hide') => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler__default['default'].on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function (event) {
      if (['A', 'AREA'].includes(this.tagName)) {
        event.preventDefault();
      }

      if (isDisabled(this)) {
        return;
      }

      const target = getElementFromSelector(this) || this.closest(`.${name}`);
      const instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method

      instance[method]();
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): offcanvas.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  const NAME = 'offcanvas';
  const DATA_KEY = 'bs.offcanvas';
  const EVENT_KEY = `.${DATA_KEY}`;
  const DATA_API_KEY = '.data-api';
  const EVENT_LOAD_DATA_API = `load${EVENT_KEY}${DATA_API_KEY}`;
  const ESCAPE_KEY = 'Escape';
  const Default = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  const DefaultType = {
    backdrop: 'boolean',
    keyboard: 'boolean',
    scroll: 'boolean'
  };
  const CLASS_NAME_SHOW = 'show';
  const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
  const OPEN_SELECTOR = '.offcanvas.show';
  const EVENT_SHOW = `show${EVENT_KEY}`;
  const EVENT_SHOWN = `shown${EVENT_KEY}`;
  const EVENT_HIDE = `hide${EVENT_KEY}`;
  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  const EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;
  const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY}`;
  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="offcanvas"]';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  class Offcanvas extends BaseComponent__default['default'] {
    constructor(element, config) {
      super(element);
      this._config = this._getConfig(config);
      this._isShown = false;
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();

      this._addEventListeners();
    } // Getters


    static get NAME() {
      return NAME;
    }

    static get Default() {
      return Default;
    } // Public


    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }

    show(relatedTarget) {
      if (this._isShown) {
        return;
      }

      const showEvent = EventHandler__default['default'].trigger(this._element, EVENT_SHOW, {
        relatedTarget
      });

      if (showEvent.defaultPrevented) {
        return;
      }

      this._isShown = true;
      this._element.style.visibility = 'visible';

      this._backdrop.show();

      if (!this._config.scroll) {
        new ScrollBarHelper().hide();
      }

      this._element.removeAttribute('aria-hidden');

      this._element.setAttribute('aria-modal', true);

      this._element.setAttribute('role', 'dialog');

      this._element.classList.add(CLASS_NAME_SHOW);

      const completeCallBack = () => {
        if (!this._config.scroll) {
          this._focustrap.activate();
        }

        EventHandler__default['default'].trigger(this._element, EVENT_SHOWN, {
          relatedTarget
        });
      };

      this._queueCallback(completeCallBack, this._element, true);
    }

    hide() {
      if (!this._isShown) {
        return;
      }

      const hideEvent = EventHandler__default['default'].trigger(this._element, EVENT_HIDE);

      if (hideEvent.defaultPrevented) {
        return;
      }

      this._focustrap.deactivate();

      this._element.blur();

      this._isShown = false;

      this._element.classList.remove(CLASS_NAME_SHOW);

      this._backdrop.hide();

      const completeCallback = () => {
        this._element.setAttribute('aria-hidden', true);

        this._element.removeAttribute('aria-modal');

        this._element.removeAttribute('role');

        this._element.style.visibility = 'hidden';

        if (!this._config.scroll) {
          new ScrollBarHelper().reset();
        }

        EventHandler__default['default'].trigger(this._element, EVENT_HIDDEN);
      };

      this._queueCallback(completeCallback, this._element, true);
    }

    dispose() {
      this._backdrop.dispose();

      this._focustrap.deactivate();

      super.dispose();
    } // Private


    _getConfig(config) {
      config = { ...Default,
        ...Manipulator__default['default'].getDataAttributes(this._element),
        ...(typeof config === 'object' ? config : {})
      };
      typeCheckConfig(NAME, config, DefaultType);
      return config;
    }

    _initializeBackDrop() {
      return new Backdrop({
        className: CLASS_NAME_BACKDROP,
        isVisible: this._config.backdrop,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: () => this.hide()
      });
    }

    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }

    _addEventListeners() {
      EventHandler__default['default'].on(this._element, EVENT_KEYDOWN_DISMISS, event => {
        if (this._config.keyboard && event.key === ESCAPE_KEY) {
          this.hide();
        }
      });
    } // Static


    static jQueryInterface(config) {
      return this.each(function () {
        const data = Offcanvas.getOrCreateInstance(this, config);

        if (typeof config !== 'string') {
          return;
        }

        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config](this);
      });
    }

  }
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default['default'].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    const target = getElementFromSelector(this);

    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    if (isDisabled(this)) {
      return;
    }

    EventHandler__default['default'].one(target, EVENT_HIDDEN, () => {
      // focus on trigger when it is closed
      if (isVisible(this)) {
        this.focus();
      }
    }); // avoid conflict when clicking a toggler of an offcanvas, while another is open

    const allReadyOpen = SelectorEngine__default['default'].findOne(OPEN_SELECTOR);

    if (allReadyOpen && allReadyOpen !== target) {
      Offcanvas.getInstance(allReadyOpen).hide();
    }

    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  });
  EventHandler__default['default'].on(window, EVENT_LOAD_DATA_API, () => SelectorEngine__default['default'].find(OPEN_SELECTOR).forEach(el => Offcanvas.getOrCreateInstance(el).show()));
  enableDismissTrigger(Offcanvas);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  defineJQueryPlugin(Offcanvas);
  return Offcanvas;
});
/*!
  * Bootstrap tab.js v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('./dom/event-handler.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['./dom/event-handler', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Tab = factory(global.EventHandler, global.SelectorEngine, global.Base));
})(this, function (EventHandler, SelectorEngine, BaseComponent) {
  'use strict';

  function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
      'default': e
    };
  }

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const getSelector = element => {
    let selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = `#${hrefAttr.split('#')[1]}`;
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  const getElementFromSelector = element => {
    const selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  const isDisabled = element => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */


  const reflow = element => {
    // eslint-disable-next-line no-unused-expressions
    element.offsetHeight;
  };

  const getjQuery = () => {
    const {
      jQuery
    } = window;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  const DOMContentLoadedCallbacks = [];

  const onDOMContentLoaded = callback => {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', () => {
          DOMContentLoadedCallbacks.forEach(callback => callback());
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  const defineJQueryPlugin = plugin => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): tab.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  const NAME = 'tab';
  const DATA_KEY = 'bs.tab';
  const EVENT_KEY = `.${DATA_KEY}`;
  const DATA_API_KEY = '.data-api';
  const EVENT_HIDE = `hide${EVENT_KEY}`;
  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  const EVENT_SHOW = `show${EVENT_KEY}`;
  const EVENT_SHOWN = `shown${EVENT_KEY}`;
  const EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;
  const CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';
  const CLASS_NAME_ACTIVE = 'active';
  const CLASS_NAME_FADE = 'fade';
  const CLASS_NAME_SHOW = 'show';
  const SELECTOR_DROPDOWN = '.dropdown';
  const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
  const SELECTOR_ACTIVE = '.active';
  const SELECTOR_ACTIVE_UL = ':scope > li > .active';
  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
  const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
  const SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active';
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  class Tab extends BaseComponent__default['default'] {
    // Getters
    static get NAME() {
      return NAME;
    } // Public


    show() {
      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) {
        return;
      }

      let previous;
      const target = getElementFromSelector(this._element);

      const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);

      if (listElement) {
        const itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
        previous = SelectorEngine__default['default'].find(itemSelector, listElement);
        previous = previous[previous.length - 1];
      }

      const hideEvent = previous ? EventHandler__default['default'].trigger(previous, EVENT_HIDE, {
        relatedTarget: this._element
      }) : null;
      const showEvent = EventHandler__default['default'].trigger(this._element, EVENT_SHOW, {
        relatedTarget: previous
      });

      if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {
        return;
      }

      this._activate(this._element, listElement);

      const complete = () => {
        EventHandler__default['default'].trigger(previous, EVENT_HIDDEN, {
          relatedTarget: this._element
        });
        EventHandler__default['default'].trigger(this._element, EVENT_SHOWN, {
          relatedTarget: previous
        });
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    } // Private


    _activate(element, container, callback) {
      const activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? SelectorEngine__default['default'].find(SELECTOR_ACTIVE_UL, container) : SelectorEngine__default['default'].children(container, SELECTOR_ACTIVE);
      const active = activeElements[0];
      const isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE);

      const complete = () => this._transitionComplete(element, active, callback);

      if (active && isTransitioning) {
        active.classList.remove(CLASS_NAME_SHOW);

        this._queueCallback(complete, element, true);
      } else {
        complete();
      }
    }

    _transitionComplete(element, active, callback) {
      if (active) {
        active.classList.remove(CLASS_NAME_ACTIVE);
        const dropdownChild = SelectorEngine__default['default'].findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);

        if (dropdownChild) {
          dropdownChild.classList.remove(CLASS_NAME_ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      element.classList.add(CLASS_NAME_ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      reflow(element);

      if (element.classList.contains(CLASS_NAME_FADE)) {
        element.classList.add(CLASS_NAME_SHOW);
      }

      let parent = element.parentNode;

      if (parent && parent.nodeName === 'LI') {
        parent = parent.parentNode;
      }

      if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {
        const dropdownElement = element.closest(SELECTOR_DROPDOWN);

        if (dropdownElement) {
          SelectorEngine__default['default'].find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach(dropdown => dropdown.classList.add(CLASS_NAME_ACTIVE));
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    } // Static


    static jQueryInterface(config) {
      return this.each(function () {
        const data = Tab.getOrCreateInstance(this);

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError(`No method named "${config}"`);
          }

          data[config]();
        }
      });
    }

  }
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default['default'].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    if (isDisabled(this)) {
      return;
    }

    const data = Tab.getOrCreateInstance(this);
    data.show();
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Tab to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Tab);
  return Tab;
});
/*!
  * Bootstrap dropdown.js v5.1.0 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@popperjs/core'), require('./dom/event-handler.js'), require('./dom/manipulator.js'), require('./dom/selector-engine.js'), require('./base-component.js')) : typeof define === 'function' && define.amd ? define(['@popperjs/core', './dom/event-handler', './dom/manipulator', './dom/selector-engine', './base-component'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Dropdown = factory(global.Popper, global.EventHandler, global.Manipulator, global.SelectorEngine, global.Base));
})(this, function (Popper, EventHandler, Manipulator, SelectorEngine, BaseComponent) {
  'use strict';

  function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
      'default': e
    };
  }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);

    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () {
              return e[k];
            }
          });
        }
      });
    }

    n['default'] = e;
    return Object.freeze(n);
  }

  var Popper__namespace = /*#__PURE__*/_interopNamespace(Popper);

  var EventHandler__default = /*#__PURE__*/_interopDefaultLegacy(EventHandler);

  var Manipulator__default = /*#__PURE__*/_interopDefaultLegacy(Manipulator);

  var SelectorEngine__default = /*#__PURE__*/_interopDefaultLegacy(SelectorEngine);

  var BaseComponent__default = /*#__PURE__*/_interopDefaultLegacy(BaseComponent);
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  const toType = obj => {
    if (obj === null || obj === undefined) {
      return `${obj}`;
    }

    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  const getSelector = element => {
    let selector = element.getAttribute('data-bs-target');

    if (!selector || selector === '#') {
      let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273

      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
        return null;
      } // Just in case some CMS puts out a full URL with the anchor appended


      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
        hrefAttr = `#${hrefAttr.split('#')[1]}`;
      }

      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
    }

    return selector;
  };

  const getElementFromSelector = element => {
    const selector = getSelector(element);
    return selector ? document.querySelector(selector) : null;
  };

  const isElement = obj => {
    if (!obj || typeof obj !== 'object') {
      return false;
    }

    if (typeof obj.jquery !== 'undefined') {
      obj = obj[0];
    }

    return typeof obj.nodeType !== 'undefined';
  };

  const getElement = obj => {
    if (isElement(obj)) {
      // it's a jQuery object or a node element
      return obj.jquery ? obj[0] : obj;
    }

    if (typeof obj === 'string' && obj.length > 0) {
      return document.querySelector(obj);
    }

    return null;
  };

  const typeCheckConfig = (componentName, config, configTypes) => {
    Object.keys(configTypes).forEach(property => {
      const expectedTypes = configTypes[property];
      const value = config[property];
      const valueType = value && isElement(value) ? 'element' : toType(value);

      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    });
  };

  const isVisible = element => {
    if (!isElement(element) || element.getClientRects().length === 0) {
      return false;
    }

    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
  };

  const isDisabled = element => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }

    if (element.classList.contains('disabled')) {
      return true;
    }

    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }

    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };

  const noop = () => {};

  const getjQuery = () => {
    const {
      jQuery
    } = window;

    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return jQuery;
    }

    return null;
  };

  const DOMContentLoadedCallbacks = [];

  const onDOMContentLoaded = callback => {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', () => {
          DOMContentLoadedCallbacks.forEach(callback => callback());
        });
      }

      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };

  const isRTL = () => document.documentElement.dir === 'rtl';

  const defineJQueryPlugin = plugin => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      /* istanbul ignore if */

      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;

        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  /**
   * Return the previous/next element of a list.
   *
   * @param {array} list    The list of elements
   * @param activeElement   The active element
   * @param shouldGetNext   Choose to get next or previous element
   * @param isCycleAllowed
   * @return {Element|elem} The proper element
   */


  const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
    let index = list.indexOf(activeElement); // if the element does not exist in the list return an element depending on the direction and if cycle is allowed

    if (index === -1) {
      return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];
    }

    const listLength = list.length;
    index += shouldGetNext ? 1 : -1;

    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }

    return list[Math.max(0, Math.min(index, listLength - 1))];
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v5.1.0): dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  const NAME = 'dropdown';
  const DATA_KEY = 'bs.dropdown';
  const EVENT_KEY = `.${DATA_KEY}`;
  const DATA_API_KEY = '.data-api';
  const ESCAPE_KEY = 'Escape';
  const SPACE_KEY = 'Space';
  const TAB_KEY = 'Tab';
  const ARROW_UP_KEY = 'ArrowUp';
  const ARROW_DOWN_KEY = 'ArrowDown';
  const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

  const REGEXP_KEYDOWN = new RegExp(`${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY}`);
  const EVENT_HIDE = `hide${EVENT_KEY}`;
  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  const EVENT_SHOW = `show${EVENT_KEY}`;
  const EVENT_SHOWN = `shown${EVENT_KEY}`;
  const EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;
  const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY}${DATA_API_KEY}`;
  const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY}${DATA_API_KEY}`;
  const CLASS_NAME_SHOW = 'show';
  const CLASS_NAME_DROPUP = 'dropup';
  const CLASS_NAME_DROPEND = 'dropend';
  const CLASS_NAME_DROPSTART = 'dropstart';
  const CLASS_NAME_NAVBAR = 'navbar';
  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="dropdown"]';
  const SELECTOR_MENU = '.dropdown-menu';
  const SELECTOR_NAVBAR_NAV = '.navbar-nav';
  const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
  const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
  const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
  const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
  const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
  const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
  const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
  const Default = {
    offset: [0, 2],
    boundary: 'clippingParents',
    reference: 'toggle',
    display: 'dynamic',
    popperConfig: null,
    autoClose: true
  };
  const DefaultType = {
    offset: '(array|string|function)',
    boundary: '(string|element)',
    reference: '(string|element|object)',
    display: 'string',
    popperConfig: '(null|object|function)',
    autoClose: '(boolean|string)'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  class Dropdown extends BaseComponent__default['default'] {
    constructor(element, config) {
      super(element);
      this._popper = null;
      this._config = this._getConfig(config);
      this._menu = this._getMenuElement();
      this._inNavbar = this._detectNavbar();
    } // Getters


    static get Default() {
      return Default;
    }

    static get DefaultType() {
      return DefaultType;
    }

    static get NAME() {
      return NAME;
    } // Public


    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }

    show() {
      if (isDisabled(this._element) || this._isShown(this._menu)) {
        return;
      }

      const relatedTarget = {
        relatedTarget: this._element
      };
      const showEvent = EventHandler__default['default'].trigger(this._element, EVENT_SHOW, relatedTarget);

      if (showEvent.defaultPrevented) {
        return;
      }

      const parent = Dropdown.getParentFromElement(this._element); // Totally disable Popper for Dropdowns in Navbar

      if (this._inNavbar) {
        Manipulator__default['default'].setDataAttribute(this._menu, 'popper', 'none');
      } else {
        this._createPopper(parent);
      } // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


      if ('ontouchstart' in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {
        [].concat(...document.body.children).forEach(elem => EventHandler__default['default'].on(elem, 'mouseover', noop));
      }

      this._element.focus();

      this._element.setAttribute('aria-expanded', true);

      this._menu.classList.add(CLASS_NAME_SHOW);

      this._element.classList.add(CLASS_NAME_SHOW);

      EventHandler__default['default'].trigger(this._element, EVENT_SHOWN, relatedTarget);
    }

    hide() {
      if (isDisabled(this._element) || !this._isShown(this._menu)) {
        return;
      }

      const relatedTarget = {
        relatedTarget: this._element
      };

      this._completeHide(relatedTarget);
    }

    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }

      super.dispose();
    }

    update() {
      this._inNavbar = this._detectNavbar();

      if (this._popper) {
        this._popper.update();
      }
    } // Private


    _completeHide(relatedTarget) {
      const hideEvent = EventHandler__default['default'].trigger(this._element, EVENT_HIDE, relatedTarget);

      if (hideEvent.defaultPrevented) {
        return;
      } // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support


      if ('ontouchstart' in document.documentElement) {
        [].concat(...document.body.children).forEach(elem => EventHandler__default['default'].off(elem, 'mouseover', noop));
      }

      if (this._popper) {
        this._popper.destroy();
      }

      this._menu.classList.remove(CLASS_NAME_SHOW);

      this._element.classList.remove(CLASS_NAME_SHOW);

      this._element.setAttribute('aria-expanded', 'false');

      Manipulator__default['default'].removeDataAttribute(this._menu, 'popper');
      EventHandler__default['default'].trigger(this._element, EVENT_HIDDEN, relatedTarget);
    }

    _getConfig(config) {
      config = { ...this.constructor.Default,
        ...Manipulator__default['default'].getDataAttributes(this._element),
        ...config
      };
      typeCheckConfig(NAME, config, this.constructor.DefaultType);

      if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
        // Popper virtual elements require a getBoundingClientRect method
        throw new TypeError(`${NAME.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      }

      return config;
    }

    _createPopper(parent) {
      if (typeof Popper__namespace === 'undefined') {
        throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
      }

      let referenceElement = this._element;

      if (this._config.reference === 'parent') {
        referenceElement = parent;
      } else if (isElement(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (typeof this._config.reference === 'object') {
        referenceElement = this._config.reference;
      }

      const popperConfig = this._getPopperConfig();

      const isDisplayStatic = popperConfig.modifiers.find(modifier => modifier.name === 'applyStyles' && modifier.enabled === false);
      this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);

      if (isDisplayStatic) {
        Manipulator__default['default'].setDataAttribute(this._menu, 'popper', 'static');
      }
    }

    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW);
    }

    _getMenuElement() {
      return SelectorEngine__default['default'].next(this._element, SELECTOR_MENU)[0];
    }

    _getPlacement() {
      const parentDropdown = this._element.parentNode;

      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }

      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      } // We need to trim the value because custom properties can also include spaces


      const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';

      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }

      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }

    _detectNavbar() {
      return this._element.closest(`.${CLASS_NAME_NAVBAR}`) !== null;
    }

    _getOffset() {
      const {
        offset
      } = this._config;

      if (typeof offset === 'string') {
        return offset.split(',').map(val => Number.parseInt(val, 10));
      }

      if (typeof offset === 'function') {
        return popperData => offset(popperData, this._element);
      }

      return offset;
    }

    _getPopperConfig() {
      const defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [{
          name: 'preventOverflow',
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: 'offset',
          options: {
            offset: this._getOffset()
          }
        }]
      }; // Disable Popper if we have a static display

      if (this._config.display === 'static') {
        defaultBsPopperConfig.modifiers = [{
          name: 'applyStyles',
          enabled: false
        }];
      }

      return { ...defaultBsPopperConfig,
        ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)
      };
    }

    _selectMenuItem({
      key,
      target
    }) {
      const items = SelectorEngine__default['default'].find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);

      if (!items.length) {
        return;
      } // if target isn't included in items (e.g. when expanding the dropdown)
      // allow cycling to get the last item in case key equals ARROW_UP_KEY


      getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();
    } // Static


    static jQueryInterface(config) {
      return this.each(function () {
        const data = Dropdown.getOrCreateInstance(this, config);

        if (typeof config !== 'string') {
          return;
        }

        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config]();
      });
    }

    static clearMenus(event) {
      if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY)) {
        return;
      }

      const toggles = SelectorEngine__default['default'].find(SELECTOR_DATA_TOGGLE);

      for (let i = 0, len = toggles.length; i < len; i++) {
        const context = Dropdown.getInstance(toggles[i]);

        if (!context || context._config.autoClose === false) {
          continue;
        }

        if (!context._isShown()) {
          continue;
        }

        const relatedTarget = {
          relatedTarget: context._element
        };

        if (event) {
          const composedPath = event.composedPath();
          const isMenuTarget = composedPath.includes(context._menu);

          if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
            continue;
          } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu


          if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY || /input|select|option|textarea|form/i.test(event.target.tagName))) {
            continue;
          }

          if (event.type === 'click') {
            relatedTarget.clickEvent = event;
          }
        }

        context._completeHide(relatedTarget);
      }
    }

    static getParentFromElement(element) {
      return getElementFromSelector(element) || element.parentNode;
    }

    static dataApiKeydownHandler(event) {
      // If not input/textarea:
      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
      // If input/textarea:
      //  - If space key => not a dropdown command
      //  - If key is other than escape
      //    - If key is not up or down => not a dropdown command
      //    - If trigger inside the menu => not a dropdown command
      if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {
        return;
      }

      const isActive = this.classList.contains(CLASS_NAME_SHOW);

      if (!isActive && event.key === ESCAPE_KEY) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();

      if (isDisabled(this)) {
        return;
      }

      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE) ? this : SelectorEngine__default['default'].prev(this, SELECTOR_DATA_TOGGLE)[0];
      const instance = Dropdown.getOrCreateInstance(getToggleButton);

      if (event.key === ESCAPE_KEY) {
        instance.hide();
        return;
      }

      if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {
        if (!isActive) {
          instance.show();
        }

        instance._selectMenuItem(event);

        return;
      }

      if (!isActive || event.key === SPACE_KEY) {
        Dropdown.clearMenus();
      }
    }

  }
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  EventHandler__default['default'].on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE, Dropdown.dataApiKeydownHandler);
  EventHandler__default['default'].on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler__default['default'].on(document, EVENT_CLICK_DATA_API, Dropdown.clearMenus);
  EventHandler__default['default'].on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler__default['default'].on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   * add .Dropdown to jQuery only if jQuery is present
   */

  defineJQueryPlugin(Dropdown);
  return Dropdown;
});
!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t() : "function" == typeof define && define.amd ? define(t) : t();
}(0, function () {
  "use strict";

  function e(e) {
    var t = !0,
        n = !1,
        o = null,
        d = {
      text: !0,
      search: !0,
      url: !0,
      tel: !0,
      email: !0,
      password: !0,
      number: !0,
      date: !0,
      month: !0,
      week: !0,
      time: !0,
      datetime: !0,
      "datetime-local": !0
    };

    function i(e) {
      return !!(e && e !== document && "HTML" !== e.nodeName && "BODY" !== e.nodeName && "classList" in e && "contains" in e.classList);
    }

    function s(e) {
      e.classList.contains("focus-visible") || (e.classList.add("focus-visible"), e.setAttribute("data-focus-visible-added", ""));
    }

    function u(e) {
      t = !1;
    }

    function a() {
      document.addEventListener("mousemove", c), document.addEventListener("mousedown", c), document.addEventListener("mouseup", c), document.addEventListener("pointermove", c), document.addEventListener("pointerdown", c), document.addEventListener("pointerup", c), document.addEventListener("touchmove", c), document.addEventListener("touchstart", c), document.addEventListener("touchend", c);
    }

    function c(e) {
      e.target.nodeName && "html" === e.target.nodeName.toLowerCase() || (t = !1, document.removeEventListener("mousemove", c), document.removeEventListener("mousedown", c), document.removeEventListener("mouseup", c), document.removeEventListener("pointermove", c), document.removeEventListener("pointerdown", c), document.removeEventListener("pointerup", c), document.removeEventListener("touchmove", c), document.removeEventListener("touchstart", c), document.removeEventListener("touchend", c));
    }

    document.addEventListener("keydown", function (n) {
      n.metaKey || n.altKey || n.ctrlKey || (i(e.activeElement) && s(e.activeElement), t = !0);
    }, !0), document.addEventListener("mousedown", u, !0), document.addEventListener("pointerdown", u, !0), document.addEventListener("touchstart", u, !0), document.addEventListener("visibilitychange", function (e) {
      "hidden" === document.visibilityState && (n && (t = !0), a());
    }, !0), a(), e.addEventListener("focus", function (e) {
      var n, o, u;
      i(e.target) && (t || (n = e.target, o = n.type, "INPUT" === (u = n.tagName) && d[o] && !n.readOnly || "TEXTAREA" === u && !n.readOnly || n.isContentEditable)) && s(e.target);
    }, !0), e.addEventListener("blur", function (e) {
      var t;
      i(e.target) && (e.target.classList.contains("focus-visible") || e.target.hasAttribute("data-focus-visible-added")) && (n = !0, window.clearTimeout(o), o = window.setTimeout(function () {
        n = !1;
      }, 100), (t = e.target).hasAttribute("data-focus-visible-added") && (t.classList.remove("focus-visible"), t.removeAttribute("data-focus-visible-added")));
    }, !0), e.nodeType === Node.DOCUMENT_FRAGMENT_NODE && e.host ? e.host.setAttribute("data-js-focus-visible", "") : e.nodeType === Node.DOCUMENT_NODE && (document.documentElement.classList.add("js-focus-visible"), document.documentElement.setAttribute("data-js-focus-visible", ""));
  }

  if ("undefined" != typeof window && "undefined" != typeof document) {
    var t;
    window.applyFocusVisiblePolyfill = e;

    try {
      t = new CustomEvent("focus-visible-polyfill-ready");
    } catch (e) {
      (t = document.createEvent("CustomEvent")).initCustomEvent("focus-visible-polyfill-ready", !1, !1, {});
    }

    window.dispatchEvent(t);
  }

  "undefined" != typeof document && e(document);
});
/*!
  hey, [be]Lazy.js - v1.8.2 - 2016.10.25
  A fast, small and dependency free lazy load script (https://github.com/dinbror/blazy)
  (c) Bjoern Klinggaard - @bklinggaard - http://dinbror.dk/blazy
*/
(function (q, m) {
  "function" === typeof define && define.amd ? define(m) : "object" === typeof exports ? module.exports = m() : q.Blazy = m();
})(this, function () {
  function q(b) {
    var c = b._util;
    c.elements = E(b.options);
    c.count = c.elements.length;
    c.destroyed && (c.destroyed = !1, b.options.container && l(b.options.container, function (a) {
      n(a, "scroll", c.validateT);
    }), n(window, "resize", c.saveViewportOffsetT), n(window, "resize", c.validateT), n(window, "scroll", c.validateT));
    m(b);
  }

  function m(b) {
    for (var c = b._util, a = 0; a < c.count; a++) {
      var d = c.elements[a],
          e;

      a: {
        var g = d;
        e = b.options;
        var p = g.getBoundingClientRect();

        if (e.container && y && (g = g.closest(e.containerClass))) {
          g = g.getBoundingClientRect();
          e = r(g, f) ? r(p, {
            top: g.top - e.offset,
            right: g.right + e.offset,
            bottom: g.bottom + e.offset,
            left: g.left - e.offset
          }) : !1;
          break a;
        }

        e = r(p, f);
      }

      if (e || t(d, b.options.successClass)) b.load(d), c.elements.splice(a, 1), c.count--, a--;
    }

    0 === c.count && b.destroy();
  }

  function r(b, c) {
    return b.right >= c.left && b.bottom >= c.top && b.left <= c.right && b.top <= c.bottom;
  }

  function z(b, c, a) {
    if (!t(b, a.successClass) && (c || a.loadInvisible || 0 < b.offsetWidth && 0 < b.offsetHeight)) if (c = b.getAttribute(u) || b.getAttribute(a.src)) {
      c = c.split(a.separator);
      var d = c[A && 1 < c.length ? 1 : 0],
          e = b.getAttribute(a.srcset),
          g = "img" === b.nodeName.toLowerCase(),
          p = (c = b.parentNode) && "picture" === c.nodeName.toLowerCase();

      if (g || void 0 === b.src) {
        var h = new Image(),
            w = function () {
          a.error && a.error(b, "invalid");
          v(b, a.errorClass);
          k(h, "error", w);
          k(h, "load", f);
        },
            f = function () {
          g ? p || B(b, d, e) : b.style.backgroundImage = 'url("' + d + '")';
          x(b, a);
          k(h, "load", f);
          k(h, "error", w);
        };

        p && (h = b, l(c.getElementsByTagName("source"), function (b) {
          var c = a.srcset,
              e = b.getAttribute(c);
          e && (b.setAttribute("srcset", e), b.removeAttribute(c));
        }));
        n(h, "error", w);
        n(h, "load", f);
        B(h, d, e);
      } else b.src = d, x(b, a);
    } else "video" === b.nodeName.toLowerCase() ? (l(b.getElementsByTagName("source"), function (b) {
      var c = a.src,
          e = b.getAttribute(c);
      e && (b.setAttribute("src", e), b.removeAttribute(c));
    }), b.load(), x(b, a)) : (a.error && a.error(b, "missing"), v(b, a.errorClass));
  }

  function x(b, c) {
    v(b, c.successClass);
    c.success && c.success(b);
    b.removeAttribute(c.src);
    b.removeAttribute(c.srcset);
    l(c.breakpoints, function (a) {
      b.removeAttribute(a.src);
    });
  }

  function B(b, c, a) {
    a && b.setAttribute("srcset", a);
    b.src = c;
  }

  function t(b, c) {
    return -1 !== (" " + b.className + " ").indexOf(" " + c + " ");
  }

  function v(b, c) {
    t(b, c) || (b.className += " " + c);
  }

  function E(b) {
    var c = [];
    b = b.root.querySelectorAll(b.selector);

    for (var a = b.length; a--; c.unshift(b[a]));

    return c;
  }

  function C(b) {
    f.bottom = (window.innerHeight || document.documentElement.clientHeight) + b;
    f.right = (window.innerWidth || document.documentElement.clientWidth) + b;
  }

  function n(b, c, a) {
    b.attachEvent ? b.attachEvent && b.attachEvent("on" + c, a) : b.addEventListener(c, a, {
      capture: !1,
      passive: !0
    });
  }

  function k(b, c, a) {
    b.detachEvent ? b.detachEvent && b.detachEvent("on" + c, a) : b.removeEventListener(c, a, {
      capture: !1,
      passive: !0
    });
  }

  function l(b, c) {
    if (b && c) for (var a = b.length, d = 0; d < a && !1 !== c(b[d], d); d++);
  }

  function D(b, c, a) {
    var d = 0;
    return function () {
      var e = +new Date();
      e - d < c || (d = e, b.apply(a, arguments));
    };
  }

  var u, f, A, y;
  return function (b) {
    if (!document.querySelectorAll) {
      var c = document.createStyleSheet();

      document.querySelectorAll = function (a, b, d, h, f) {
        f = document.all;
        b = [];
        a = a.replace(/\[for\b/gi, "[htmlFor").split(",");

        for (d = a.length; d--;) {
          c.addRule(a[d], "k:v");

          for (h = f.length; h--;) f[h].currentStyle.k && b.push(f[h]);

          c.removeRule(0);
        }

        return b;
      };
    }

    var a = this,
        d = a._util = {};
    d.elements = [];
    d.destroyed = !0;
    a.options = b || {};
    a.options.error = a.options.error || !1;
    a.options.offset = a.options.offset || 100;
    a.options.root = a.options.root || document;
    a.options.success = a.options.success || !1;
    a.options.selector = a.options.selector || ".b-lazy";
    a.options.separator = a.options.separator || "|";
    a.options.containerClass = a.options.container;
    a.options.container = a.options.containerClass ? document.querySelectorAll(a.options.containerClass) : !1;
    a.options.errorClass = a.options.errorClass || "b-error";
    a.options.breakpoints = a.options.breakpoints || !1;
    a.options.loadInvisible = a.options.loadInvisible || !1;
    a.options.successClass = a.options.successClass || "b-loaded";
    a.options.validateDelay = a.options.validateDelay || 25;
    a.options.saveViewportOffsetDelay = a.options.saveViewportOffsetDelay || 50;
    a.options.srcset = a.options.srcset || "data-srcset";
    a.options.src = u = a.options.src || "data-src";
    y = Element.prototype.closest;
    A = 1 < window.devicePixelRatio;
    f = {};
    f.top = 0 - a.options.offset;
    f.left = 0 - a.options.offset;

    a.revalidate = function () {
      q(a);
    };

    a.load = function (a, b) {
      var c = this.options;
      void 0 === a.length ? z(a, b, c) : l(a, function (a) {
        z(a, b, c);
      });
    };

    a.destroy = function () {
      var a = this._util;
      this.options.container && l(this.options.container, function (b) {
        k(b, "scroll", a.validateT);
      });
      k(window, "scroll", a.validateT);
      k(window, "resize", a.validateT);
      k(window, "resize", a.saveViewportOffsetT);
      a.count = 0;
      a.elements.length = 0;
      a.destroyed = !0;
    };

    d.validateT = D(function () {
      m(a);
    }, a.options.validateDelay, a);
    d.saveViewportOffsetT = D(function () {
      C(a.options.offset);
    }, a.options.saveViewportOffsetDelay, a);
    C(a.options.offset);
    l(a.options.breakpoints, function (a) {
      if (a.width >= window.screen.width) return u = a.src, !1;
    });
    setTimeout(function () {
      q(a);
    });
  };
});
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).IMask = {});
}(this, function (t) {
  "use strict";

  var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
      n = function (t) {
    return t && t.Math == Math && t;
  },
      u = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof e && e) || function () {
    return this;
  }() || Function("return this")(),
      r = {},
      i = function (t) {
    try {
      return !!t();
    } catch (t) {
      return !0;
    }
  },
      a = !i(function () {
    return 7 != Object.defineProperty({}, 1, {
      get: function () {
        return 7;
      }
    })[1];
  }),
      s = {},
      o = {}.propertyIsEnumerable,
      l = Object.getOwnPropertyDescriptor,
      h = l && !o.call({
    1: 2
  }, 1);

  s.f = h ? function (t) {
    var e = l(this, t);
    return !!e && e.enumerable;
  } : o;

  var c = function (t, e) {
    return {
      enumerable: !(1 & t),
      configurable: !(2 & t),
      writable: !(4 & t),
      value: e
    };
  },
      f = {}.toString,
      p = function (t) {
    return f.call(t).slice(8, -1);
  },
      d = "".split,
      v = i(function () {
    return !Object("z").propertyIsEnumerable(0);
  }) ? function (t) {
    return "String" == p(t) ? d.call(t, "") : Object(t);
  } : Object,
      k = function (t) {
    if (null == t) throw TypeError("Can't call method on " + t);
    return t;
  },
      g = v,
      y = k,
      m = function (t) {
    return g(y(t));
  },
      _ = function (t) {
    return "object" == typeof t ? null !== t : "function" == typeof t;
  },
      A = _,
      b = function (t, e) {
    if (!A(t)) return t;
    var n, u;
    if (e && "function" == typeof (n = t.toString) && !A(u = n.call(t))) return u;
    if ("function" == typeof (n = t.valueOf) && !A(u = n.call(t))) return u;
    if (!e && "function" == typeof (n = t.toString) && !A(u = n.call(t))) return u;
    throw TypeError("Can't convert object to primitive value");
  },
      C = k,
      E = function (t) {
    return Object(C(t));
  },
      F = E,
      S = {}.hasOwnProperty,
      D = Object.hasOwn || function (t, e) {
    return S.call(F(t), e);
  },
      B = _,
      w = u.document,
      M = B(w) && B(w.createElement),
      x = function (t) {
    return M ? w.createElement(t) : {};
  },
      P = !a && !i(function () {
    return 7 != Object.defineProperty(x("div"), "a", {
      get: function () {
        return 7;
      }
    }).a;
  }),
      O = a,
      T = s,
      I = c,
      j = m,
      V = b,
      R = D,
      L = P,
      N = Object.getOwnPropertyDescriptor;

  r.f = O ? N : function (t, e) {
    if (t = j(t), e = V(e, !0), L) try {
      return N(t, e);
    } catch (t) {}
    if (R(t, e)) return I(!T.f.call(t, e), t[e]);
  };

  var U = {},
      z = _,
      H = function (t) {
    if (!z(t)) throw TypeError(String(t) + " is not an object");
    return t;
  },
      Y = a,
      Z = P,
      K = H,
      G = b,
      W = Object.defineProperty;

  U.f = Y ? W : function (t, e, n) {
    if (K(t), e = G(e, !0), K(n), Z) try {
      return W(t, e, n);
    } catch (t) {}
    if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
    return "value" in n && (t[e] = n.value), t;
  };

  var $ = U,
      q = c,
      X = a ? function (t, e, n) {
    return $.f(t, e, q(1, n));
  } : function (t, e, n) {
    return t[e] = n, t;
  },
      J = {
    exports: {}
  },
      Q = u,
      tt = X,
      et = function (t, e) {
    try {
      tt(Q, t, e);
    } catch (n) {
      Q[t] = e;
    }

    return e;
  },
      nt = et,
      ut = "__core-js_shared__",
      rt = u[ut] || nt(ut, {}),
      it = rt,
      at = Function.toString;

  "function" != typeof it.inspectSource && (it.inspectSource = function (t) {
    return at.call(t);
  });
  var st = it.inspectSource,
      ot = st,
      lt = u.WeakMap,
      ht = "function" == typeof lt && /native code/.test(ot(lt)),
      ct = {
    exports: {}
  },
      ft = rt;
  (ct.exports = function (t, e) {
    return ft[t] || (ft[t] = void 0 !== e ? e : {});
  })("versions", []).push({
    version: "3.15.2",
    mode: "global",
    copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
  });

  var pt,
      dt,
      vt,
      kt = 0,
      gt = Math.random(),
      yt = ct.exports,
      mt = function (t) {
    return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++kt + gt).toString(36);
  },
      _t = yt("keys"),
      At = {},
      bt = ht,
      Ct = _,
      Et = X,
      Ft = D,
      St = rt,
      Dt = function (t) {
    return _t[t] || (_t[t] = mt(t));
  },
      Bt = At,
      wt = "Object already initialized",
      Mt = u.WeakMap;

  if (bt || St.state) {
    var xt = St.state || (St.state = new Mt()),
        Pt = xt.get,
        Ot = xt.has,
        Tt = xt.set;
    pt = function (t, e) {
      if (Ot.call(xt, t)) throw new TypeError(wt);
      return e.facade = t, Tt.call(xt, t, e), e;
    }, dt = function (t) {
      return Pt.call(xt, t) || {};
    }, vt = function (t) {
      return Ot.call(xt, t);
    };
  } else {
    var It = Dt("state");
    Bt[It] = !0, pt = function (t, e) {
      if (Ft(t, It)) throw new TypeError(wt);
      return e.facade = t, Et(t, It, e), e;
    }, dt = function (t) {
      return Ft(t, It) ? t[It] : {};
    }, vt = function (t) {
      return Ft(t, It);
    };
  }

  var jt = {
    set: pt,
    get: dt,
    has: vt,
    enforce: function (t) {
      return vt(t) ? dt(t) : pt(t, {});
    },
    getterFor: function (t) {
      return function (e) {
        var n;
        if (!Ct(e) || (n = dt(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
        return n;
      };
    }
  },
      Vt = u,
      Rt = X,
      Lt = D,
      Nt = et,
      Ut = st,
      zt = jt.get,
      Ht = jt.enforce,
      Yt = String(String).split("String");
  (J.exports = function (t, e, n, u) {
    var r,
        i = !!u && !!u.unsafe,
        a = !!u && !!u.enumerable,
        s = !!u && !!u.noTargetGet;
    "function" == typeof n && ("string" != typeof e || Lt(n, "name") || Rt(n, "name", e), (r = Ht(n)).source || (r.source = Yt.join("string" == typeof e ? e : ""))), t !== Vt ? (i ? !s && t[e] && (a = !0) : delete t[e], a ? t[e] = n : Rt(t, e, n)) : a ? t[e] = n : Nt(e, n);
  })(Function.prototype, "toString", function () {
    return "function" == typeof this && zt(this).source || Ut(this);
  });

  var Zt = u,
      Kt = u,
      Gt = function (t) {
    return "function" == typeof t ? t : void 0;
  },
      Wt = function (t, e) {
    return arguments.length < 2 ? Gt(Zt[t]) || Gt(Kt[t]) : Zt[t] && Zt[t][e] || Kt[t] && Kt[t][e];
  },
      $t = {},
      qt = Math.ceil,
      Xt = Math.floor,
      Jt = function (t) {
    return isNaN(t = +t) ? 0 : (t > 0 ? Xt : qt)(t);
  },
      Qt = Jt,
      te = Math.min,
      ee = function (t) {
    return t > 0 ? te(Qt(t), 9007199254740991) : 0;
  },
      ne = Jt,
      ue = Math.max,
      re = Math.min,
      ie = m,
      ae = ee,
      se = function (t, e) {
    var n = ne(t);
    return n < 0 ? ue(n + e, 0) : re(n, e);
  },
      oe = function (t) {
    return function (e, n, u) {
      var r,
          i = ie(e),
          a = ae(i.length),
          s = se(u, a);

      if (t && n != n) {
        for (; a > s;) if ((r = i[s++]) != r) return !0;
      } else for (; a > s; s++) if ((t || s in i) && i[s] === n) return t || s || 0;

      return !t && -1;
    };
  },
      le = {
    includes: oe(!0),
    indexOf: oe(!1)
  },
      he = D,
      ce = m,
      fe = le.indexOf,
      pe = At,
      de = function (t, e) {
    var n,
        u = ce(t),
        r = 0,
        i = [];

    for (n in u) !he(pe, n) && he(u, n) && i.push(n);

    for (; e.length > r;) he(u, n = e[r++]) && (~fe(i, n) || i.push(n));

    return i;
  },
      ve = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
      ke = de,
      ge = ve.concat("length", "prototype");

  $t.f = Object.getOwnPropertyNames || function (t) {
    return ke(t, ge);
  };

  var ye = {};
  ye.f = Object.getOwnPropertySymbols;

  var me = $t,
      _e = ye,
      Ae = H,
      be = Wt("Reflect", "ownKeys") || function (t) {
    var e = me.f(Ae(t)),
        n = _e.f;
    return n ? e.concat(n(t)) : e;
  },
      Ce = D,
      Ee = be,
      Fe = r,
      Se = U,
      De = i,
      Be = /#|\.prototype\./,
      we = function (t, e) {
    var n = xe[Me(t)];
    return n == Oe || n != Pe && ("function" == typeof e ? De(e) : !!e);
  },
      Me = we.normalize = function (t) {
    return String(t).replace(Be, ".").toLowerCase();
  },
      xe = we.data = {},
      Pe = we.NATIVE = "N",
      Oe = we.POLYFILL = "P",
      Te = we,
      Ie = u,
      je = r.f,
      Ve = X,
      Re = J.exports,
      Le = et,
      Ne = function (t, e) {
    for (var n = Ee(e), u = Se.f, r = Fe.f, i = 0; i < n.length; i++) {
      var a = n[i];
      Ce(t, a) || u(t, a, r(e, a));
    }
  },
      Ue = Te,
      ze = function (t, e) {
    var n,
        u,
        r,
        i,
        a,
        s = t.target,
        o = t.global,
        l = t.stat;
    if (n = o ? Ie : l ? Ie[s] || Le(s, {}) : (Ie[s] || {}).prototype) for (u in e) {
      if (i = e[u], r = t.noTargetGet ? (a = je(n, u)) && a.value : n[u], !Ue(o ? u : s + (l ? "." : "#") + u, t.forced) && void 0 !== r) {
        if (typeof i == typeof r) continue;
        Ne(i, r);
      }

      (t.sham || r && r.sham) && Ve(i, "sham", !0), Re(n, u, i, t);
    }
  },
      He = de,
      Ye = ve,
      Ze = Object.keys || function (t) {
    return He(t, Ye);
  },
      Ke = a,
      Ge = i,
      We = Ze,
      $e = ye,
      qe = s,
      Xe = E,
      Je = v,
      Qe = Object.assign,
      tn = Object.defineProperty,
      en = !Qe || Ge(function () {
    if (Ke && 1 !== Qe({
      b: 1
    }, Qe(tn({}, "a", {
      enumerable: !0,
      get: function () {
        tn(this, "b", {
          value: 3,
          enumerable: !1
        });
      }
    }), {
      b: 2
    })).b) return !0;
    var t = {},
        e = {},
        n = Symbol(),
        u = "abcdefghijklmnopqrst";
    return t[n] = 7, u.split("").forEach(function (t) {
      e[t] = t;
    }), 7 != Qe({}, t)[n] || We(Qe({}, e)).join("") != u;
  }) ? function (t, e) {
    for (var n = Xe(t), u = arguments.length, r = 1, i = $e.f, a = qe.f; u > r;) for (var s, o = Je(arguments[r++]), l = i ? We(o).concat(i(o)) : We(o), h = l.length, c = 0; h > c;) s = l[c++], Ke && !a.call(o, s) || (n[s] = o[s]);

    return n;
  } : Qe;

  ze({
    target: "Object",
    stat: !0,
    forced: Object.assign !== en
  }, {
    assign: en
  });

  var nn = Jt,
      un = k,
      rn = function (t) {
    var e = String(un(this)),
        n = "",
        u = nn(t);
    if (u < 0 || u == 1 / 0) throw RangeError("Wrong number of repetitions");

    for (; u > 0; (u >>>= 1) && (e += e)) 1 & u && (n += e);

    return n;
  };

  ze({
    target: "String",
    proto: !0
  }, {
    repeat: rn
  });

  var an = ee,
      sn = rn,
      on = k,
      ln = Math.ceil,
      hn = function (t) {
    return function (e, n, u) {
      var r,
          i,
          a = String(on(e)),
          s = a.length,
          o = void 0 === u ? " " : String(u),
          l = an(n);
      return l <= s || "" == o ? a : (r = l - s, (i = sn.call(o, ln(r / o.length))).length > r && (i = i.slice(0, r)), t ? a + i : i + a);
    };
  },
      cn = {
    start: hn(!1),
    end: hn(!0)
  },
      fn = Wt("navigator", "userAgent") || "",
      pn = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(fn),
      dn = cn.start;

  ze({
    target: "String",
    proto: !0,
    forced: pn
  }, {
    padStart: function (t) {
      return dn(this, t, arguments.length > 1 ? arguments[1] : void 0);
    }
  });
  var vn = cn.end;

  function kn(t) {
    return (kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
      return typeof t;
    } : function (t) {
      return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    })(t);
  }

  function gn(t, e) {
    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
  }

  function yn(t, e) {
    for (var n = 0; n < e.length; n++) {
      var u = e[n];
      u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(t, u.key, u);
    }
  }

  function mn(t, e, n) {
    return e && yn(t.prototype, e), n && yn(t, n), t;
  }

  function _n(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), e && bn(t, e);
  }

  function An(t) {
    return (An = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    })(t);
  }

  function bn(t, e) {
    return (bn = Object.setPrototypeOf || function (t, e) {
      return t.__proto__ = e, t;
    })(t, e);
  }

  function Cn(t, e) {
    if (null == t) return {};

    var n,
        u,
        r = function (t, e) {
      if (null == t) return {};
      var n,
          u,
          r = {},
          i = Object.keys(t);

      for (u = 0; u < i.length; u++) n = i[u], e.indexOf(n) >= 0 || (r[n] = t[n]);

      return r;
    }(t, e);

    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(t);

      for (u = 0; u < i.length; u++) n = i[u], e.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(t, n) && (r[n] = t[n]);
    }

    return r;
  }

  function En(t, e) {
    return !e || "object" != typeof e && "function" != typeof e ? function (t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t;
    }(t) : e;
  }

  function Fn(t) {
    var e = function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;

      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
      } catch (t) {
        return !1;
      }
    }();

    return function () {
      var n,
          u = An(t);

      if (e) {
        var r = An(this).constructor;
        n = Reflect.construct(u, arguments, r);
      } else n = u.apply(this, arguments);

      return En(this, n);
    };
  }

  function Sn(t, e) {
    for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = An(t)););

    return t;
  }

  function Dn(t, e, n) {
    return (Dn = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) {
      var u = Sn(t, e);

      if (u) {
        var r = Object.getOwnPropertyDescriptor(u, e);
        return r.get ? r.get.call(n) : r.value;
      }
    })(t, e, n || t);
  }

  function Bn(t, e, n, u) {
    return (Bn = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function (t, e, n, u) {
      var r,
          i = Sn(t, e);

      if (i) {
        if ((r = Object.getOwnPropertyDescriptor(i, e)).set) return r.set.call(u, n), !0;
        if (!r.writable) return !1;
      }

      if (r = Object.getOwnPropertyDescriptor(u, e)) {
        if (!r.writable) return !1;
        r.value = n, Object.defineProperty(u, e, r);
      } else !function (t, e, n) {
        e in t ? Object.defineProperty(t, e, {
          value: n,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : t[e] = n;
      }(u, e, n);

      return !0;
    })(t, e, n, u);
  }

  function wn(t, e, n, u, r) {
    if (!Bn(t, e, n, u || t) && r) throw new Error("failed to set property");
    return n;
  }

  function Mn(t, e) {
    return function (t) {
      if (Array.isArray(t)) return t;
    }(t) || function (t, e) {
      var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
      if (null == n) return;
      var u,
          r,
          i = [],
          a = !0,
          s = !1;

      try {
        for (n = n.call(t); !(a = (u = n.next()).done) && (i.push(u.value), !e || i.length !== e); a = !0);
      } catch (t) {
        s = !0, r = t;
      } finally {
        try {
          a || null == n.return || n.return();
        } finally {
          if (s) throw r;
        }
      }

      return i;
    }(t, e) || function (t, e) {
      if (!t) return;
      if ("string" == typeof t) return xn(t, e);
      var n = Object.prototype.toString.call(t).slice(8, -1);
      "Object" === n && t.constructor && (n = t.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(t);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return xn(t, e);
    }(t, e) || function () {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }

  function xn(t, e) {
    (null == e || e > t.length) && (e = t.length);

    for (var n = 0, u = new Array(e); n < e; n++) u[n] = t[n];

    return u;
  }

  function Pn(t) {
    return "string" == typeof t || t instanceof String;
  }

  ze({
    target: "String",
    proto: !0,
    forced: pn
  }, {
    padEnd: function (t) {
      return vn(this, t, arguments.length > 1 ? arguments[1] : void 0);
    }
  }), ze({
    global: !0
  }, {
    globalThis: u
  });
  var On = "NONE",
      Tn = "LEFT",
      In = "FORCE_LEFT",
      jn = "RIGHT",
      Vn = "FORCE_RIGHT";

  function Rn(t) {
    switch (t) {
      case Tn:
        return In;

      case jn:
        return Vn;

      default:
        return t;
    }
  }

  function Ln(t) {
    return t.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  }

  function Nn(t, e) {
    if (e === t) return !0;
    var n,
        u = Array.isArray(e),
        r = Array.isArray(t);

    if (u && r) {
      if (e.length != t.length) return !1;

      for (n = 0; n < e.length; n++) if (!Nn(e[n], t[n])) return !1;

      return !0;
    }

    if (u != r) return !1;

    if (e && t && "object" === kn(e) && "object" === kn(t)) {
      var i = e instanceof Date,
          a = t instanceof Date;
      if (i && a) return e.getTime() == t.getTime();
      if (i != a) return !1;
      var s = e instanceof RegExp,
          o = t instanceof RegExp;
      if (s && o) return e.toString() == t.toString();
      if (s != o) return !1;
      var l = Object.keys(e);

      for (n = 0; n < l.length; n++) if (!Object.prototype.hasOwnProperty.call(t, l[n])) return !1;

      for (n = 0; n < l.length; n++) if (!Nn(t[l[n]], e[l[n]])) return !1;

      return !0;
    }

    return !(!e || !t || "function" != typeof e || "function" != typeof t) && e.toString() === t.toString();
  }

  var Un = function () {
    function t(e, n, u, r) {
      for (gn(this, t), this.value = e, this.cursorPos = n, this.oldValue = u, this.oldSelection = r; this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos);) --this.oldSelection.start;
    }

    return mn(t, [{
      key: "startChangePos",
      get: function () {
        return Math.min(this.cursorPos, this.oldSelection.start);
      }
    }, {
      key: "insertedCount",
      get: function () {
        return this.cursorPos - this.startChangePos;
      }
    }, {
      key: "inserted",
      get: function () {
        return this.value.substr(this.startChangePos, this.insertedCount);
      }
    }, {
      key: "removedCount",
      get: function () {
        return Math.max(this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length, 0);
      }
    }, {
      key: "removed",
      get: function () {
        return this.oldValue.substr(this.startChangePos, this.removedCount);
      }
    }, {
      key: "head",
      get: function () {
        return this.value.substring(0, this.startChangePos);
      }
    }, {
      key: "tail",
      get: function () {
        return this.value.substring(this.startChangePos + this.insertedCount);
      }
    }, {
      key: "removeDirection",
      get: function () {
        return !this.removedCount || this.insertedCount ? On : this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos ? jn : Tn;
      }
    }]), t;
  }(),
      zn = function () {
    function t(e) {
      gn(this, t), Object.assign(this, {
        inserted: "",
        rawInserted: "",
        skip: !1,
        tailShift: 0
      }, e);
    }

    return mn(t, [{
      key: "aggregate",
      value: function (t) {
        return this.rawInserted += t.rawInserted, this.skip = this.skip || t.skip, this.inserted += t.inserted, this.tailShift += t.tailShift, this;
      }
    }, {
      key: "offset",
      get: function () {
        return this.tailShift + this.inserted.length;
      }
    }]), t;
  }(),
      Hn = function () {
    function t() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
          n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
          u = arguments.length > 2 ? arguments[2] : void 0;
      gn(this, t), this.value = e, this.from = n, this.stop = u;
    }

    return mn(t, [{
      key: "toString",
      value: function () {
        return this.value;
      }
    }, {
      key: "extend",
      value: function (t) {
        this.value += String(t);
      }
    }, {
      key: "appendTo",
      value: function (t) {
        return t.append(this.toString(), {
          tail: !0
        }).aggregate(t._appendPlaceholder());
      }
    }, {
      key: "state",
      get: function () {
        return {
          value: this.value,
          from: this.from,
          stop: this.stop
        };
      },
      set: function (t) {
        Object.assign(this, t);
      }
    }, {
      key: "shiftBefore",
      value: function (t) {
        if (this.from >= t || !this.value.length) return "";
        var e = this.value[0];
        return this.value = this.value.slice(1), e;
      }
    }]), t;
  }();

  function Yn(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return new Yn.InputMask(t, e);
  }

  var Zn = function () {
    function t(e) {
      gn(this, t), this._value = "", this._update(Object.assign({}, t.DEFAULTS, e)), this.isInitialized = !0;
    }

    return mn(t, [{
      key: "updateOptions",
      value: function (t) {
        Object.keys(t).length && this.withValueRefresh(this._update.bind(this, t));
      }
    }, {
      key: "_update",
      value: function (t) {
        Object.assign(this, t);
      }
    }, {
      key: "state",
      get: function () {
        return {
          _value: this.value
        };
      },
      set: function (t) {
        this._value = t._value;
      }
    }, {
      key: "reset",
      value: function () {
        this._value = "";
      }
    }, {
      key: "value",
      get: function () {
        return this._value;
      },
      set: function (t) {
        this.resolve(t);
      }
    }, {
      key: "resolve",
      value: function (t) {
        return this.reset(), this.append(t, {
          input: !0
        }, ""), this.doCommit(), this.value;
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this.value;
      },
      set: function (t) {
        this.reset(), this.append(t, {}, ""), this.doCommit();
      }
    }, {
      key: "typedValue",
      get: function () {
        return this.doParse(this.value);
      },
      set: function (t) {
        this.value = this.doFormat(t);
      }
    }, {
      key: "rawInputValue",
      get: function () {
        return this.extractInput(0, this.value.length, {
          raw: !0
        });
      },
      set: function (t) {
        this.reset(), this.append(t, {
          raw: !0
        }, ""), this.doCommit();
      }
    }, {
      key: "isComplete",
      get: function () {
        return !0;
      }
    }, {
      key: "nearestInputPos",
      value: function (t, e) {
        return t;
      }
    }, {
      key: "extractInput",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
        return this.value.slice(t, e);
      }
    }, {
      key: "extractTail",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
        return new Hn(this.extractInput(t, e), t);
      }
    }, {
      key: "appendTail",
      value: function (t) {
        return Pn(t) && (t = new Hn(String(t))), t.appendTo(this);
      }
    }, {
      key: "_appendCharRaw",
      value: function (t) {
        return t ? (this._value += t, new zn({
          inserted: t,
          rawInserted: t
        })) : new zn();
      }
    }, {
      key: "_appendChar",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = arguments.length > 2 ? arguments[2] : void 0,
            u = this.state,
            r = this._appendCharRaw(this.doPrepare(t, e), e);

        if (r.inserted) {
          var i,
              a = !1 !== this.doValidate(e);

          if (a && null != n) {
            var s = this.state;
            this.overwrite && (i = n.state, n.shiftBefore(this.value.length));
            var o = this.appendTail(n);
            (a = o.rawInserted === n.toString()) && o.inserted && (this.state = s);
          }

          a || (r = new zn(), this.state = u, n && i && (n.state = i));
        }

        return r;
      }
    }, {
      key: "_appendPlaceholder",
      value: function () {
        return new zn();
      }
    }, {
      key: "append",
      value: function (t, e, n) {
        if (!Pn(t)) throw new Error("value should be string");
        var u = new zn(),
            r = Pn(n) ? new Hn(String(n)) : n;
        e && e.tail && (e._beforeTailState = this.state);

        for (var i = 0; i < t.length; ++i) u.aggregate(this._appendChar(t[i], e, r));

        return null != r && (u.tailShift += this.appendTail(r).tailShift), u;
      }
    }, {
      key: "remove",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
        return this._value = this.value.slice(0, t) + this.value.slice(e), new zn();
      }
    }, {
      key: "withValueRefresh",
      value: function (t) {
        if (this._refreshing || !this.isInitialized) return t();
        this._refreshing = !0;
        var e = this.rawInputValue,
            n = this.value,
            u = t();
        return this.rawInputValue = e, this.value && this.value !== n && 0 === n.indexOf(this.value) && this.append(n.slice(this.value.length), {}, ""), delete this._refreshing, u;
      }
    }, {
      key: "runIsolated",
      value: function (t) {
        if (this._isolated || !this.isInitialized) return t(this);
        this._isolated = !0;
        var e = this.state,
            n = t(this);
        return this.state = e, delete this._isolated, n;
      }
    }, {
      key: "doPrepare",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return this.prepare ? this.prepare(t, this, e) : t;
      }
    }, {
      key: "doValidate",
      value: function (t) {
        return (!this.validate || this.validate(this.value, this, t)) && (!this.parent || this.parent.doValidate(t));
      }
    }, {
      key: "doCommit",
      value: function () {
        this.commit && this.commit(this.value, this);
      }
    }, {
      key: "doFormat",
      value: function (t) {
        return this.format ? this.format(t, this) : t;
      }
    }, {
      key: "doParse",
      value: function (t) {
        return this.parse ? this.parse(t, this) : t;
      }
    }, {
      key: "splice",
      value: function (t, e, n, u) {
        var r = t + e,
            i = this.extractTail(r),
            a = this.nearestInputPos(t, u);
        return new zn({
          tailShift: a - t
        }).aggregate(this.remove(a)).aggregate(this.append(n, {
          input: !0
        }, i));
      }
    }]), t;
  }();

  function Kn(t) {
    if (null == t) throw new Error("mask property should be defined");
    return t instanceof RegExp ? Yn.MaskedRegExp : Pn(t) ? Yn.MaskedPattern : t instanceof Date || t === Date ? Yn.MaskedDate : t instanceof Number || "number" == typeof t || t === Number ? Yn.MaskedNumber : Array.isArray(t) || t === Array ? Yn.MaskedDynamic : Yn.Masked && t.prototype instanceof Yn.Masked ? t : t instanceof Function ? Yn.MaskedFunction : t instanceof Yn.Masked ? t.constructor : (console.warn("Mask not found for mask", t), Yn.Masked);
  }

  function Gn(t) {
    if (Yn.Masked && t instanceof Yn.Masked) return t;
    var e = (t = Object.assign({}, t)).mask;
    if (Yn.Masked && e instanceof Yn.Masked) return e;
    var n = Kn(e);
    if (!n) throw new Error("Masked class is not found for provided mask, appropriate module needs to be import manually before creating mask.");
    return new n(t);
  }

  Zn.DEFAULTS = {
    format: function (t) {
      return t;
    },
    parse: function (t) {
      return t;
    }
  }, Yn.Masked = Zn, Yn.createMask = Gn;

  var Wn = ["mask"],
      $n = {
    0: /\d/,
    a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    "*": /./
  },
      qn = function () {
    function t(e) {
      gn(this, t);
      var n = e.mask,
          u = Cn(e, Wn);
      this.masked = Gn({
        mask: n
      }), Object.assign(this, u);
    }

    return mn(t, [{
      key: "reset",
      value: function () {
        this._isFilled = !1, this.masked.reset();
      }
    }, {
      key: "remove",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length;
        return 0 === t && e >= 1 ? (this._isFilled = !1, this.masked.remove(t, e)) : new zn();
      }
    }, {
      key: "value",
      get: function () {
        return this.masked.value || (this._isFilled && !this.isOptional ? this.placeholderChar : "");
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this.masked.unmaskedValue;
      }
    }, {
      key: "isComplete",
      get: function () {
        return Boolean(this.masked.value) || this.isOptional;
      }
    }, {
      key: "_appendChar",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (this._isFilled) return new zn();

        var n = this.masked.state,
            u = this.masked._appendChar(t, e);

        return u.inserted && !1 === this.doValidate(e) && (u.inserted = u.rawInserted = "", this.masked.state = n), u.inserted || this.isOptional || this.lazy || e.input || (u.inserted = this.placeholderChar), u.skip = !u.inserted && !this.isOptional, this._isFilled = Boolean(u.inserted), u;
      }
    }, {
      key: "append",
      value: function () {
        var t;
        return (t = this.masked).append.apply(t, arguments);
      }
    }, {
      key: "_appendPlaceholder",
      value: function () {
        var t = new zn();
        return this._isFilled || this.isOptional || (this._isFilled = !0, t.inserted = this.placeholderChar), t;
      }
    }, {
      key: "extractTail",
      value: function () {
        var t;
        return (t = this.masked).extractTail.apply(t, arguments);
      }
    }, {
      key: "appendTail",
      value: function () {
        var t;
        return (t = this.masked).appendTail.apply(t, arguments);
      }
    }, {
      key: "extractInput",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            n = arguments.length > 2 ? arguments[2] : void 0;
        return this.masked.extractInput(t, e, n);
      }
    }, {
      key: "nearestInputPos",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : On,
            n = 0,
            u = this.value.length,
            r = Math.min(Math.max(t, n), u);

        switch (e) {
          case Tn:
          case In:
            return this.isComplete ? r : n;

          case jn:
          case Vn:
            return this.isComplete ? r : u;

          case On:
          default:
            return r;
        }
      }
    }, {
      key: "doValidate",
      value: function () {
        var t, e;
        return (t = this.masked).doValidate.apply(t, arguments) && (!this.parent || (e = this.parent).doValidate.apply(e, arguments));
      }
    }, {
      key: "doCommit",
      value: function () {
        this.masked.doCommit();
      }
    }, {
      key: "state",
      get: function () {
        return {
          masked: this.masked.state,
          _isFilled: this._isFilled
        };
      },
      set: function (t) {
        this.masked.state = t.masked, this._isFilled = t._isFilled;
      }
    }]), t;
  }(),
      Xn = function () {
    function t(e) {
      gn(this, t), Object.assign(this, e), this._value = "";
    }

    return mn(t, [{
      key: "value",
      get: function () {
        return this._value;
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this.isUnmasking ? this.value : "";
      }
    }, {
      key: "reset",
      value: function () {
        this._isRawInput = !1, this._value = "";
      }
    }, {
      key: "remove",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._value.length;
        return this._value = this._value.slice(0, t) + this._value.slice(e), this._value || (this._isRawInput = !1), new zn();
      }
    }, {
      key: "nearestInputPos",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : On,
            n = 0,
            u = this._value.length;

        switch (e) {
          case Tn:
          case In:
            return n;

          case On:
          case jn:
          case Vn:
          default:
            return u;
        }
      }
    }, {
      key: "extractInput",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._value.length,
            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return n.raw && this._isRawInput && this._value.slice(t, e) || "";
      }
    }, {
      key: "isComplete",
      get: function () {
        return !0;
      }
    }, {
      key: "_appendChar",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = new zn();
        if (this._value) return n;
        var u = this.char === t[0],
            r = u && (this.isUnmasking || e.input || e.raw) && !e.tail;
        return r && (n.rawInserted = this.char), this._value = n.inserted = this.char, this._isRawInput = r && (e.raw || e.input), n;
      }
    }, {
      key: "_appendPlaceholder",
      value: function () {
        var t = new zn();
        return this._value || (this._value = t.inserted = this.char), t;
      }
    }, {
      key: "extractTail",
      value: function () {
        return arguments.length > 1 && void 0 !== arguments[1] || this.value.length, new Hn("");
      }
    }, {
      key: "appendTail",
      value: function (t) {
        return Pn(t) && (t = new Hn(String(t))), t.appendTo(this);
      }
    }, {
      key: "append",
      value: function (t, e, n) {
        var u = this._appendChar(t, e);

        return null != n && (u.tailShift += this.appendTail(n).tailShift), u;
      }
    }, {
      key: "doCommit",
      value: function () {}
    }, {
      key: "state",
      get: function () {
        return {
          _value: this._value,
          _isRawInput: this._isRawInput
        };
      },
      set: function (t) {
        Object.assign(this, t);
      }
    }]), t;
  }(),
      Jn = ["chunks"],
      Qn = function () {
    function t() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
          n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      gn(this, t), this.chunks = e, this.from = n;
    }

    return mn(t, [{
      key: "toString",
      value: function () {
        return this.chunks.map(String).join("");
      }
    }, {
      key: "extend",
      value: function (e) {
        if (String(e)) {
          Pn(e) && (e = new Hn(String(e)));
          var n = this.chunks[this.chunks.length - 1],
              u = n && (n.stop === e.stop || null == e.stop) && e.from === n.from + n.toString().length;
          if (e instanceof Hn) u ? n.extend(e.toString()) : this.chunks.push(e);else if (e instanceof t) {
            if (null == e.stop) for (var r; e.chunks.length && null == e.chunks[0].stop;) (r = e.chunks.shift()).from += e.from, this.extend(r);
            e.toString() && (e.stop = e.blockIndex, this.chunks.push(e));
          }
        }
      }
    }, {
      key: "appendTo",
      value: function (e) {
        if (!(e instanceof Yn.MaskedPattern)) return new Hn(this.toString()).appendTo(e);

        for (var n = new zn(), u = 0; u < this.chunks.length && !n.skip; ++u) {
          var r = this.chunks[u],
              i = e._mapPosToBlock(e.value.length),
              a = r.stop,
              s = void 0;

          if (null != a && (!i || i.index <= a) && ((r instanceof t || e._stops.indexOf(a) >= 0) && n.aggregate(e._appendPlaceholder(a)), s = r instanceof t && e._blocks[a]), s) {
            var o = s.appendTail(r);
            o.skip = !1, n.aggregate(o), e._value += o.inserted;
            var l = r.toString().slice(o.rawInserted.length);
            l && n.aggregate(e.append(l, {
              tail: !0
            }));
          } else n.aggregate(e.append(r.toString(), {
            tail: !0
          }));
        }

        return n;
      }
    }, {
      key: "state",
      get: function () {
        return {
          chunks: this.chunks.map(function (t) {
            return t.state;
          }),
          from: this.from,
          stop: this.stop,
          blockIndex: this.blockIndex
        };
      },
      set: function (e) {
        var n = e.chunks,
            u = Cn(e, Jn);
        Object.assign(this, u), this.chunks = n.map(function (e) {
          var n = "chunks" in e ? new t() : new Hn();
          return n.state = e, n;
        });
      }
    }, {
      key: "shiftBefore",
      value: function (t) {
        if (this.from >= t || !this.chunks.length) return "";

        for (var e = t - this.from, n = 0; n < this.chunks.length;) {
          var u = this.chunks[n],
              r = u.shiftBefore(e);

          if (u.toString()) {
            if (!r) break;
            ++n;
          } else this.chunks.splice(n, 1);

          if (r) return r;
        }

        return "";
      }
    }]), t;
  }(),
      tu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      return gn(this, n), e.apply(this, arguments);
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        t.mask && (t.validate = function (e) {
          return e.search(t.mask) >= 0;
        }), Dn(An(n.prototype), "_update", this).call(this, t);
      }
    }]), n;
  }(Zn);

  Yn.MaskedRegExp = tu;

  var eu = ["_blocks"],
      nu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      return gn(this, n), t.definitions = Object.assign({}, $n, t.definitions), e.call(this, Object.assign({}, n.DEFAULTS, t));
    }

    return mn(n, [{
      key: "_update",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        t.definitions = Object.assign({}, this.definitions, t.definitions), Dn(An(n.prototype), "_update", this).call(this, t), this._rebuildMask();
      }
    }, {
      key: "_rebuildMask",
      value: function () {
        var t = this,
            e = this.definitions;
        this._blocks = [], this._stops = [], this._maskedBlocks = {};
        var u = this.mask;
        if (u && e) for (var r = !1, i = !1, a = 0; a < u.length; ++a) {
          if (this.blocks) if ("continue" === function () {
            var e = u.slice(a),
                n = Object.keys(t.blocks).filter(function (t) {
              return 0 === e.indexOf(t);
            });
            n.sort(function (t, e) {
              return e.length - t.length;
            });
            var r = n[0];

            if (r) {
              var i = Gn(Object.assign({
                parent: t,
                lazy: t.lazy,
                placeholderChar: t.placeholderChar,
                overwrite: t.overwrite
              }, t.blocks[r]));
              return i && (t._blocks.push(i), t._maskedBlocks[r] || (t._maskedBlocks[r] = []), t._maskedBlocks[r].push(t._blocks.length - 1)), a += r.length - 1, "continue";
            }
          }()) continue;
          var s = u[a],
              o = (s in e);
          if (s !== n.STOP_CHAR) {
            if ("{" !== s && "}" !== s) {
              if ("[" !== s && "]" !== s) {
                if (s === n.ESCAPE_CHAR) {
                  if (++a, !(s = u[a])) break;
                  o = !1;
                }

                var l = o ? new qn({
                  parent: this,
                  lazy: this.lazy,
                  placeholderChar: this.placeholderChar,
                  mask: e[s],
                  isOptional: i
                }) : new Xn({
                  char: s,
                  isUnmasking: r
                });

                this._blocks.push(l);
              } else i = !i;
            } else r = !r;
          } else this._stops.push(this._blocks.length);
        }
      }
    }, {
      key: "state",
      get: function () {
        return Object.assign({}, Dn(An(n.prototype), "state", this), {
          _blocks: this._blocks.map(function (t) {
            return t.state;
          })
        });
      },
      set: function (t) {
        var e = t._blocks,
            u = Cn(t, eu);
        this._blocks.forEach(function (t, n) {
          return t.state = e[n];
        }), wn(An(n.prototype), "state", u, this, !0);
      }
    }, {
      key: "reset",
      value: function () {
        Dn(An(n.prototype), "reset", this).call(this), this._blocks.forEach(function (t) {
          return t.reset();
        });
      }
    }, {
      key: "isComplete",
      get: function () {
        return this._blocks.every(function (t) {
          return t.isComplete;
        });
      }
    }, {
      key: "doCommit",
      value: function () {
        this._blocks.forEach(function (t) {
          return t.doCommit();
        }), Dn(An(n.prototype), "doCommit", this).call(this);
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this._blocks.reduce(function (t, e) {
          return t + e.unmaskedValue;
        }, "");
      },
      set: function (t) {
        wn(An(n.prototype), "unmaskedValue", t, this, !0);
      }
    }, {
      key: "value",
      get: function () {
        return this._blocks.reduce(function (t, e) {
          return t + e.value;
        }, "");
      },
      set: function (t) {
        wn(An(n.prototype), "value", t, this, !0);
      }
    }, {
      key: "appendTail",
      value: function (t) {
        return Dn(An(n.prototype), "appendTail", this).call(this, t).aggregate(this._appendPlaceholder());
      }
    }, {
      key: "_appendCharRaw",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = this._mapPosToBlock(this.value.length),
            u = new zn();

        if (!n) return u;

        for (var r = n.index;; ++r) {
          var i = this._blocks[r];
          if (!i) break;

          var a = i._appendChar(t, e),
              s = a.skip;

          if (u.aggregate(a), s || a.rawInserted) break;
        }

        return u;
      }
    }, {
      key: "extractTail",
      value: function () {
        var t = this,
            e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            u = new Qn();
        return e === n || this._forEachBlocksInRange(e, n, function (e, n, r, i) {
          var a = e.extractTail(r, i);
          a.stop = t._findStopBefore(n), a.from = t._blockStartPos(n), a instanceof Qn && (a.blockIndex = n), u.extend(a);
        }), u;
      }
    }, {
      key: "extractInput",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (t === e) return "";
        var u = "";
        return this._forEachBlocksInRange(t, e, function (t, e, r, i) {
          u += t.extractInput(r, i, n);
        }), u;
      }
    }, {
      key: "_findStopBefore",
      value: function (t) {
        for (var e, n = 0; n < this._stops.length; ++n) {
          var u = this._stops[n];
          if (!(u <= t)) break;
          e = u;
        }

        return e;
      }
    }, {
      key: "_appendPlaceholder",
      value: function (t) {
        var e = this,
            n = new zn();
        if (this.lazy && null == t) return n;

        var u = this._mapPosToBlock(this.value.length);

        if (!u) return n;
        var r = u.index,
            i = null != t ? t : this._blocks.length;
        return this._blocks.slice(r, i).forEach(function (u) {
          if (!u.lazy || null != t) {
            var r = null != u._blocks ? [u._blocks.length] : [],
                i = u._appendPlaceholder.apply(u, r);

            e._value += i.inserted, n.aggregate(i);
          }
        }), n;
      }
    }, {
      key: "_mapPosToBlock",
      value: function (t) {
        for (var e = "", n = 0; n < this._blocks.length; ++n) {
          var u = this._blocks[n],
              r = e.length;
          if (t <= (e += u.value).length) return {
            index: n,
            offset: t - r
          };
        }
      }
    }, {
      key: "_blockStartPos",
      value: function (t) {
        return this._blocks.slice(0, t).reduce(function (t, e) {
          return t + e.value.length;
        }, 0);
      }
    }, {
      key: "_forEachBlocksInRange",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            n = arguments.length > 2 ? arguments[2] : void 0,
            u = this._mapPosToBlock(t);

        if (u) {
          var r = this._mapPosToBlock(e),
              i = r && u.index === r.index,
              a = u.offset,
              s = r && i ? r.offset : this._blocks[u.index].value.length;

          if (n(this._blocks[u.index], u.index, a, s), r && !i) {
            for (var o = u.index + 1; o < r.index; ++o) n(this._blocks[o], o, 0, this._blocks[o].value.length);

            n(this._blocks[r.index], r.index, 0, r.offset);
          }
        }
      }
    }, {
      key: "remove",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            u = Dn(An(n.prototype), "remove", this).call(this, t, e);
        return this._forEachBlocksInRange(t, e, function (t, e, n, r) {
          u.aggregate(t.remove(n, r));
        }), u;
      }
    }, {
      key: "nearestInputPos",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : On,
            n = this._mapPosToBlock(t) || {
          index: 0,
          offset: 0
        },
            u = n.offset,
            r = n.index,
            i = this._blocks[r];
        if (!i) return t;
        var a = u;
        0 !== a && a < i.value.length && (a = i.nearestInputPos(u, Rn(e)));
        var s = a === i.value.length,
            o = 0 === a;
        if (!o && !s) return this._blockStartPos(r) + a;
        var l = s ? r + 1 : r;

        if (e === On) {
          if (l > 0) {
            var h = l - 1,
                c = this._blocks[h],
                f = c.nearestInputPos(0, On);
            if (!c.value.length || f !== c.value.length) return this._blockStartPos(l);
          }

          for (var p = l, d = p; d < this._blocks.length; ++d) {
            var v = this._blocks[d],
                k = v.nearestInputPos(0, On);
            if (!v.value.length || k !== v.value.length) return this._blockStartPos(d) + k;
          }

          for (var g = l - 1; g >= 0; --g) {
            var y = this._blocks[g],
                m = y.nearestInputPos(0, On);
            if (!y.value.length || m !== y.value.length) return this._blockStartPos(g) + y.value.length;
          }

          return t;
        }

        if (e === Tn || e === In) {
          for (var _, A = l; A < this._blocks.length; ++A) if (this._blocks[A].value) {
            _ = A;
            break;
          }

          if (null != _) {
            var b = this._blocks[_],
                C = b.nearestInputPos(0, jn);
            if (0 === C && b.unmaskedValue.length) return this._blockStartPos(_) + C;
          }

          for (var E, F = -1, S = l - 1; S >= 0; --S) {
            var D = this._blocks[S],
                B = D.nearestInputPos(D.value.length, In);

            if (D.value && 0 === B || (E = S), 0 !== B) {
              if (B !== D.value.length) return this._blockStartPos(S) + B;
              F = S;
              break;
            }
          }

          if (e === Tn) for (var w = F + 1; w <= Math.min(l, this._blocks.length - 1); ++w) {
            var M = this._blocks[w],
                x = M.nearestInputPos(0, On),
                P = this._blockStartPos(w) + x;
            if (P > t) break;
            if (x !== M.value.length) return P;
          }
          if (F >= 0) return this._blockStartPos(F) + this._blocks[F].value.length;
          if (e === In || this.lazy && !this.extractInput() && !uu(this._blocks[l])) return 0;
          if (null != E) return this._blockStartPos(E);

          for (var O = l; O < this._blocks.length; ++O) {
            var T = this._blocks[O],
                I = T.nearestInputPos(0, On);
            if (!T.value.length || I !== T.value.length) return this._blockStartPos(O) + I;
          }

          return 0;
        }

        if (e === jn || e === Vn) {
          for (var j, V, R = l; R < this._blocks.length; ++R) {
            var L = this._blocks[R],
                N = L.nearestInputPos(0, On);

            if (N !== L.value.length) {
              V = this._blockStartPos(R) + N, j = R;
              break;
            }
          }

          if (null != j && null != V) {
            for (var U = j; U < this._blocks.length; ++U) {
              var z = this._blocks[U],
                  H = z.nearestInputPos(0, Vn);
              if (H !== z.value.length) return this._blockStartPos(U) + H;
            }

            return e === Vn ? this.value.length : V;
          }

          for (var Y = Math.min(l, this._blocks.length - 1); Y >= 0; --Y) {
            var Z = this._blocks[Y],
                K = Z.nearestInputPos(Z.value.length, Tn);

            if (0 !== K) {
              var G = this._blockStartPos(Y) + K;
              if (G >= t) return G;
              break;
            }
          }
        }

        return t;
      }
    }, {
      key: "maskedBlock",
      value: function (t) {
        return this.maskedBlocks(t)[0];
      }
    }, {
      key: "maskedBlocks",
      value: function (t) {
        var e = this,
            n = this._maskedBlocks[t];
        return n ? n.map(function (t) {
          return e._blocks[t];
        }) : [];
      }
    }]), n;
  }(Zn);

  function uu(t) {
    if (!t) return !1;
    var e = t.value;
    return !e || t.nearestInputPos(0, On) !== e.length;
  }

  nu.DEFAULTS = {
    lazy: !0,
    placeholderChar: "_"
  }, nu.STOP_CHAR = "`", nu.ESCAPE_CHAR = "\\", nu.InputDefinition = qn, nu.FixedDefinition = Xn, Yn.MaskedPattern = nu;

  var ru = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      return gn(this, n), e.apply(this, arguments);
    }

    return mn(n, [{
      key: "_matchFrom",
      get: function () {
        return this.maxLength - String(this.from).length;
      }
    }, {
      key: "_update",
      value: function (t) {
        t = Object.assign({
          to: this.to || 0,
          from: this.from || 0
        }, t);
        var e = String(t.to).length;
        null != t.maxLength && (e = Math.max(e, t.maxLength)), t.maxLength = e;

        for (var u = String(t.from).padStart(e, "0"), r = String(t.to).padStart(e, "0"), i = 0; i < r.length && r[i] === u[i];) ++i;

        t.mask = r.slice(0, i).replace(/0/g, "\\0") + "0".repeat(e - i), Dn(An(n.prototype), "_update", this).call(this, t);
      }
    }, {
      key: "isComplete",
      get: function () {
        return Dn(An(n.prototype), "isComplete", this) && Boolean(this.value);
      }
    }, {
      key: "boundaries",
      value: function (t) {
        var e = "",
            n = "",
            u = Mn(t.match(/^(\D*)(\d*)(\D*)/) || [], 3),
            r = u[1],
            i = u[2];
        return i && (e = "0".repeat(r.length) + i, n = "9".repeat(r.length) + i), [e = e.padEnd(this.maxLength, "0"), n = n.padEnd(this.maxLength, "9")];
      }
    }, {
      key: "doPrepare",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (t = Dn(An(n.prototype), "doPrepare", this).call(this, t, e).replace(/\D/g, ""), !this.autofix) return t;

        for (var u = String(this.from).padStart(this.maxLength, "0"), r = String(this.to).padStart(this.maxLength, "0"), i = this.value, a = "", s = 0; s < t.length; ++s) {
          var o = i + a + t[s],
              l = this.boundaries(o),
              h = Mn(l, 2),
              c = h[0],
              f = h[1];
          Number(f) < this.from ? a += u[o.length - 1] : Number(c) > this.to ? a += r[o.length - 1] : a += t[s];
        }

        return a;
      }
    }, {
      key: "doValidate",
      value: function () {
        var t,
            e = this.value,
            u = e.search(/[^0]/);
        if (-1 === u && e.length <= this._matchFrom) return !0;

        for (var r = this.boundaries(e), i = Mn(r, 2), a = i[0], s = i[1], o = arguments.length, l = new Array(o), h = 0; h < o; h++) l[h] = arguments[h];

        return this.from <= Number(s) && Number(a) <= this.to && (t = Dn(An(n.prototype), "doValidate", this)).call.apply(t, [this].concat(l));
      }
    }]), n;
  }(nu);

  Yn.MaskedRange = ru;

  var iu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n(t) {
      return gn(this, n), e.call(this, Object.assign({}, n.DEFAULTS, t));
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        t.mask === Date && delete t.mask, t.pattern && (t.mask = t.pattern);
        var e = t.blocks;
        t.blocks = Object.assign({}, n.GET_DEFAULT_BLOCKS()), t.min && (t.blocks.Y.from = t.min.getFullYear()), t.max && (t.blocks.Y.to = t.max.getFullYear()), t.min && t.max && t.blocks.Y.from === t.blocks.Y.to && (t.blocks.m.from = t.min.getMonth() + 1, t.blocks.m.to = t.max.getMonth() + 1, t.blocks.m.from === t.blocks.m.to && (t.blocks.d.from = t.min.getDate(), t.blocks.d.to = t.max.getDate())), Object.assign(t.blocks, e), Object.keys(t.blocks).forEach(function (e) {
          var n = t.blocks[e];
          "autofix" in n || (n.autofix = t.autofix);
        }), Dn(An(n.prototype), "_update", this).call(this, t);
      }
    }, {
      key: "doValidate",
      value: function () {
        for (var t, e = this.date, u = arguments.length, r = new Array(u), i = 0; i < u; i++) r[i] = arguments[i];

        return (t = Dn(An(n.prototype), "doValidate", this)).call.apply(t, [this].concat(r)) && (!this.isComplete || this.isDateExist(this.value) && null != e && (null == this.min || this.min <= e) && (null == this.max || e <= this.max));
      }
    }, {
      key: "isDateExist",
      value: function (t) {
        return this.format(this.parse(t, this), this).indexOf(t) >= 0;
      }
    }, {
      key: "date",
      get: function () {
        return this.typedValue;
      },
      set: function (t) {
        this.typedValue = t;
      }
    }, {
      key: "typedValue",
      get: function () {
        return this.isComplete ? Dn(An(n.prototype), "typedValue", this) : null;
      },
      set: function (t) {
        wn(An(n.prototype), "typedValue", t, this, !0);
      }
    }]), n;
  }(nu);

  iu.DEFAULTS = {
    pattern: "d{.}`m{.}`Y",
    format: function (t) {
      return [String(t.getDate()).padStart(2, "0"), String(t.getMonth() + 1).padStart(2, "0"), t.getFullYear()].join(".");
    },
    parse: function (t) {
      var e = Mn(t.split("."), 3),
          n = e[0],
          u = e[1],
          r = e[2];
      return new Date(r, u - 1, n);
    }
  }, iu.GET_DEFAULT_BLOCKS = function () {
    return {
      d: {
        mask: ru,
        from: 1,
        to: 31,
        maxLength: 2
      },
      m: {
        mask: ru,
        from: 1,
        to: 12,
        maxLength: 2
      },
      Y: {
        mask: ru,
        from: 1900,
        to: 9999
      }
    };
  }, Yn.MaskedDate = iu;

  var au = function () {
    function t() {
      gn(this, t);
    }

    return mn(t, [{
      key: "selectionStart",
      get: function () {
        var t;

        try {
          t = this._unsafeSelectionStart;
        } catch (t) {}

        return null != t ? t : this.value.length;
      }
    }, {
      key: "selectionEnd",
      get: function () {
        var t;

        try {
          t = this._unsafeSelectionEnd;
        } catch (t) {}

        return null != t ? t : this.value.length;
      }
    }, {
      key: "select",
      value: function (t, e) {
        if (null != t && null != e && (t !== this.selectionStart || e !== this.selectionEnd)) try {
          this._unsafeSelect(t, e);
        } catch (t) {}
      }
    }, {
      key: "_unsafeSelect",
      value: function (t, e) {}
    }, {
      key: "isActive",
      get: function () {
        return !1;
      }
    }, {
      key: "bindEvents",
      value: function (t) {}
    }, {
      key: "unbindEvents",
      value: function () {}
    }]), t;
  }();

  Yn.MaskElement = au;

  var su = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n(t) {
      var u;
      return gn(this, n), (u = e.call(this)).input = t, u._handlers = {}, u;
    }

    return mn(n, [{
      key: "rootElement",
      get: function () {
        return this.input.getRootNode ? this.input.getRootNode() : document;
      }
    }, {
      key: "isActive",
      get: function () {
        return this.input === this.rootElement.activeElement;
      }
    }, {
      key: "_unsafeSelectionStart",
      get: function () {
        return this.input.selectionStart;
      }
    }, {
      key: "_unsafeSelectionEnd",
      get: function () {
        return this.input.selectionEnd;
      }
    }, {
      key: "_unsafeSelect",
      value: function (t, e) {
        this.input.setSelectionRange(t, e);
      }
    }, {
      key: "value",
      get: function () {
        return this.input.value;
      },
      set: function (t) {
        this.input.value = t;
      }
    }, {
      key: "bindEvents",
      value: function (t) {
        var e = this;
        Object.keys(t).forEach(function (u) {
          return e._toggleEventHandler(n.EVENTS_MAP[u], t[u]);
        });
      }
    }, {
      key: "unbindEvents",
      value: function () {
        var t = this;
        Object.keys(this._handlers).forEach(function (e) {
          return t._toggleEventHandler(e);
        });
      }
    }, {
      key: "_toggleEventHandler",
      value: function (t, e) {
        this._handlers[t] && (this.input.removeEventListener(t, this._handlers[t]), delete this._handlers[t]), e && (this.input.addEventListener(t, e), this._handlers[t] = e);
      }
    }]), n;
  }(au);

  su.EVENTS_MAP = {
    selectionChange: "keydown",
    input: "input",
    drop: "drop",
    click: "click",
    focus: "focus",
    commit: "blur"
  }, Yn.HTMLMaskElement = su;

  var ou = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      return gn(this, n), e.apply(this, arguments);
    }

    return mn(n, [{
      key: "_unsafeSelectionStart",
      get: function () {
        var t = this.rootElement,
            e = t.getSelection && t.getSelection();
        return e && e.anchorOffset;
      }
    }, {
      key: "_unsafeSelectionEnd",
      get: function () {
        var t = this.rootElement,
            e = t.getSelection && t.getSelection();
        return e && this._unsafeSelectionStart + String(e).length;
      }
    }, {
      key: "_unsafeSelect",
      value: function (t, e) {
        if (this.rootElement.createRange) {
          var n = this.rootElement.createRange();
          n.setStart(this.input.firstChild || this.input, t), n.setEnd(this.input.lastChild || this.input, e);
          var u = this.rootElement,
              r = u.getSelection && u.getSelection();
          r && (r.removeAllRanges(), r.addRange(n));
        }
      }
    }, {
      key: "value",
      get: function () {
        return this.input.textContent;
      },
      set: function (t) {
        this.input.textContent = t;
      }
    }]), n;
  }(su);

  Yn.HTMLContenteditableMaskElement = ou;

  var lu = ["mask"],
      hu = function () {
    function t(e, n) {
      gn(this, t), this.el = e instanceof au ? e : e.isContentEditable && "INPUT" !== e.tagName && "TEXTAREA" !== e.tagName ? new ou(e) : new su(e), this.masked = Gn(n), this._listeners = {}, this._value = "", this._unmaskedValue = "", this._saveSelection = this._saveSelection.bind(this), this._onInput = this._onInput.bind(this), this._onChange = this._onChange.bind(this), this._onDrop = this._onDrop.bind(this), this._onFocus = this._onFocus.bind(this), this._onClick = this._onClick.bind(this), this.alignCursor = this.alignCursor.bind(this), this.alignCursorFriendly = this.alignCursorFriendly.bind(this), this._bindEvents(), this.updateValue(), this._onChange();
    }

    return mn(t, [{
      key: "mask",
      get: function () {
        return this.masked.mask;
      },
      set: function (t) {
        if (!this.maskEquals(t)) if (t instanceof Yn.Masked || this.masked.constructor !== Kn(t)) {
          var e = Gn({
            mask: t
          });
          e.unmaskedValue = this.masked.unmaskedValue, this.masked = e;
        } else this.masked.updateOptions({
          mask: t
        });
      }
    }, {
      key: "maskEquals",
      value: function (t) {
        return null == t || t === this.masked.mask || t === Date && this.masked instanceof iu;
      }
    }, {
      key: "value",
      get: function () {
        return this._value;
      },
      set: function (t) {
        this.masked.value = t, this.updateControl(), this.alignCursor();
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this._unmaskedValue;
      },
      set: function (t) {
        this.masked.unmaskedValue = t, this.updateControl(), this.alignCursor();
      }
    }, {
      key: "typedValue",
      get: function () {
        return this.masked.typedValue;
      },
      set: function (t) {
        this.masked.typedValue = t, this.updateControl(), this.alignCursor();
      }
    }, {
      key: "_bindEvents",
      value: function () {
        this.el.bindEvents({
          selectionChange: this._saveSelection,
          input: this._onInput,
          drop: this._onDrop,
          click: this._onClick,
          focus: this._onFocus,
          commit: this._onChange
        });
      }
    }, {
      key: "_unbindEvents",
      value: function () {
        this.el && this.el.unbindEvents();
      }
    }, {
      key: "_fireEvent",
      value: function (t) {
        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), u = 1; u < e; u++) n[u - 1] = arguments[u];

        var r = this._listeners[t];
        r && r.forEach(function (t) {
          return t.apply(void 0, n);
        });
      }
    }, {
      key: "selectionStart",
      get: function () {
        return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
      }
    }, {
      key: "cursorPos",
      get: function () {
        return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
      },
      set: function (t) {
        this.el && this.el.isActive && (this.el.select(t, t), this._saveSelection());
      }
    }, {
      key: "_saveSelection",
      value: function () {
        this.value !== this.el.value && console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."), this._selection = {
          start: this.selectionStart,
          end: this.cursorPos
        };
      }
    }, {
      key: "updateValue",
      value: function () {
        this.masked.value = this.el.value, this._value = this.masked.value;
      }
    }, {
      key: "updateControl",
      value: function () {
        var t = this.masked.unmaskedValue,
            e = this.masked.value,
            n = this.unmaskedValue !== t || this.value !== e;
        this._unmaskedValue = t, this._value = e, this.el.value !== e && (this.el.value = e), n && this._fireChangeEvents();
      }
    }, {
      key: "updateOptions",
      value: function (t) {
        var e = t.mask,
            n = Cn(t, lu),
            u = !this.maskEquals(e),
            r = !Nn(this.masked, n);
        u && (this.mask = e), r && this.masked.updateOptions(n), (u || r) && this.updateControl();
      }
    }, {
      key: "updateCursor",
      value: function (t) {
        null != t && (this.cursorPos = t, this._delayUpdateCursor(t));
      }
    }, {
      key: "_delayUpdateCursor",
      value: function (t) {
        var e = this;
        this._abortUpdateCursor(), this._changingCursorPos = t, this._cursorChanging = setTimeout(function () {
          e.el && (e.cursorPos = e._changingCursorPos, e._abortUpdateCursor());
        }, 10);
      }
    }, {
      key: "_fireChangeEvents",
      value: function () {
        this._fireEvent("accept", this._inputEvent), this.masked.isComplete && this._fireEvent("complete", this._inputEvent);
      }
    }, {
      key: "_abortUpdateCursor",
      value: function () {
        this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging);
      }
    }, {
      key: "alignCursor",
      value: function () {
        this.cursorPos = this.masked.nearestInputPos(this.cursorPos, Tn);
      }
    }, {
      key: "alignCursorFriendly",
      value: function () {
        this.selectionStart === this.cursorPos && this.alignCursor();
      }
    }, {
      key: "on",
      value: function (t, e) {
        return this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push(e), this;
      }
    }, {
      key: "off",
      value: function (t, e) {
        if (!this._listeners[t]) return this;
        if (!e) return delete this._listeners[t], this;

        var n = this._listeners[t].indexOf(e);

        return n >= 0 && this._listeners[t].splice(n, 1), this;
      }
    }, {
      key: "_onInput",
      value: function (t) {
        if (this._inputEvent = t, this._abortUpdateCursor(), !this._selection) return this.updateValue();
        var e = new Un(this.el.value, this.cursorPos, this.value, this._selection),
            n = this.masked.rawInputValue,
            u = this.masked.splice(e.startChangePos, e.removed.length, e.inserted, e.removeDirection).offset,
            r = n === this.masked.rawInputValue ? e.removeDirection : On,
            i = this.masked.nearestInputPos(e.startChangePos + u, r);
        this.updateControl(), this.updateCursor(i), delete this._inputEvent;
      }
    }, {
      key: "_onChange",
      value: function () {
        this.value !== this.el.value && this.updateValue(), this.masked.doCommit(), this.updateControl(), this._saveSelection();
      }
    }, {
      key: "_onDrop",
      value: function (t) {
        t.preventDefault(), t.stopPropagation();
      }
    }, {
      key: "_onFocus",
      value: function (t) {
        this.alignCursorFriendly();
      }
    }, {
      key: "_onClick",
      value: function (t) {
        this.alignCursorFriendly();
      }
    }, {
      key: "destroy",
      value: function () {
        this._unbindEvents(), this._listeners.length = 0, delete this.el;
      }
    }]), t;
  }();

  Yn.InputMask = hu;

  var cu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      return gn(this, n), e.apply(this, arguments);
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        t.enum && (t.mask = "*".repeat(t.enum[0].length)), Dn(An(n.prototype), "_update", this).call(this, t);
      }
    }, {
      key: "doValidate",
      value: function () {
        for (var t, e = this, u = arguments.length, r = new Array(u), i = 0; i < u; i++) r[i] = arguments[i];

        return this.enum.some(function (t) {
          return t.indexOf(e.unmaskedValue) >= 0;
        }) && (t = Dn(An(n.prototype), "doValidate", this)).call.apply(t, [this].concat(r));
      }
    }]), n;
  }(nu);

  Yn.MaskedEnum = cu;

  var fu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n(t) {
      return gn(this, n), e.call(this, Object.assign({}, n.DEFAULTS, t));
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        Dn(An(n.prototype), "_update", this).call(this, t), this._updateRegExps();
      }
    }, {
      key: "_updateRegExps",
      value: function () {
        var t = "^" + (this.allowNegative ? "[+|\\-]?" : ""),
            e = (this.scale ? "(" + Ln(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$";
        this._numberRegExpInput = new RegExp(t + "(0|([1-9]+\\d*))?" + e), this._numberRegExp = new RegExp(t + "\\d*" + e), this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(Ln).join("") + "]", "g"), this._thousandsSeparatorRegExp = new RegExp(Ln(this.thousandsSeparator), "g");
      }
    }, {
      key: "_removeThousandsSeparators",
      value: function (t) {
        return t.replace(this._thousandsSeparatorRegExp, "");
      }
    }, {
      key: "_insertThousandsSeparators",
      value: function (t) {
        var e = t.split(this.radix);
        return e[0] = e[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator), e.join(this.radix);
      }
    }, {
      key: "doPrepare",
      value: function (t) {
        for (var e, u = arguments.length, r = new Array(u > 1 ? u - 1 : 0), i = 1; i < u; i++) r[i - 1] = arguments[i];

        return (e = Dn(An(n.prototype), "doPrepare", this)).call.apply(e, [this, this._removeThousandsSeparators(t.replace(this._mapToRadixRegExp, this.radix))].concat(r));
      }
    }, {
      key: "_separatorsCount",
      value: function (t) {
        for (var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = 0, u = 0; u < t; ++u) this._value.indexOf(this.thousandsSeparator, u) === u && (++n, e && (t += this.thousandsSeparator.length));

        return n;
      }
    }, {
      key: "_separatorsCountFromSlice",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._value;
        return this._separatorsCount(this._removeThousandsSeparators(t).length, !0);
      }
    }, {
      key: "extractInput",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            u = arguments.length > 2 ? arguments[2] : void 0,
            r = this._adjustRangeWithSeparators(t, e),
            i = Mn(r, 2);

        return t = i[0], e = i[1], this._removeThousandsSeparators(Dn(An(n.prototype), "extractInput", this).call(this, t, e, u));
      }
    }, {
      key: "_appendCharRaw",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!this.thousandsSeparator) return Dn(An(n.prototype), "_appendCharRaw", this).call(this, t, e);

        var u = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value,
            r = this._separatorsCountFromSlice(u);

        this._value = this._removeThousandsSeparators(this.value);
        var i = Dn(An(n.prototype), "_appendCharRaw", this).call(this, t, e);
        this._value = this._insertThousandsSeparators(this._value);

        var a = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value,
            s = this._separatorsCountFromSlice(a);

        return i.tailShift += (s - r) * this.thousandsSeparator.length, i.skip = !i.rawInserted && t === this.thousandsSeparator, i;
      }
    }, {
      key: "_findSeparatorAround",
      value: function (t) {
        if (this.thousandsSeparator) {
          var e = t - this.thousandsSeparator.length + 1,
              n = this.value.indexOf(this.thousandsSeparator, e);
          if (n <= t) return n;
        }

        return -1;
      }
    }, {
      key: "_adjustRangeWithSeparators",
      value: function (t, e) {
        var n = this._findSeparatorAround(t);

        n >= 0 && (t = n);

        var u = this._findSeparatorAround(e);

        return u >= 0 && (e = u + this.thousandsSeparator.length), [t, e];
      }
    }, {
      key: "remove",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.value.length,
            n = this._adjustRangeWithSeparators(t, e),
            u = Mn(n, 2);

        t = u[0], e = u[1];

        var r = this.value.slice(0, t),
            i = this.value.slice(e),
            a = this._separatorsCount(r.length);

        this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(r + i));

        var s = this._separatorsCountFromSlice(r);

        return new zn({
          tailShift: (s - a) * this.thousandsSeparator.length
        });
      }
    }, {
      key: "nearestInputPos",
      value: function (t, e) {
        if (!this.thousandsSeparator) return t;

        switch (e) {
          case On:
          case Tn:
          case In:
            var n = this._findSeparatorAround(t - 1);

            if (n >= 0) {
              var u = n + this.thousandsSeparator.length;
              if (t < u || this.value.length <= u || e === In) return n;
            }

            break;

          case jn:
          case Vn:
            var r = this._findSeparatorAround(t);

            if (r >= 0) return r + this.thousandsSeparator.length;
        }

        return t;
      }
    }, {
      key: "doValidate",
      value: function (t) {
        var e = (t.input ? this._numberRegExpInput : this._numberRegExp).test(this._removeThousandsSeparators(this.value));

        if (e) {
          var u = this.number;
          e = e && !isNaN(u) && (null == this.min || this.min >= 0 || this.min <= this.number) && (null == this.max || this.max <= 0 || this.number <= this.max);
        }

        return e && Dn(An(n.prototype), "doValidate", this).call(this, t);
      }
    }, {
      key: "doCommit",
      value: function () {
        if (this.value) {
          var t = this.number,
              e = t;
          null != this.min && (e = Math.max(e, this.min)), null != this.max && (e = Math.min(e, this.max)), e !== t && (this.unmaskedValue = String(e));
          var u = this.value;
          this.normalizeZeros && (u = this._normalizeZeros(u)), this.padFractionalZeros && (u = this._padFractionalZeros(u)), this._value = u;
        }

        Dn(An(n.prototype), "doCommit", this).call(this);
      }
    }, {
      key: "_normalizeZeros",
      value: function (t) {
        var e = this._removeThousandsSeparators(t).split(this.radix);

        return e[0] = e[0].replace(/^(\D*)(0*)(\d*)/, function (t, e, n, u) {
          return e + u;
        }), t.length && !/\d$/.test(e[0]) && (e[0] = e[0] + "0"), e.length > 1 && (e[1] = e[1].replace(/0*$/, ""), e[1].length || (e.length = 1)), this._insertThousandsSeparators(e.join(this.radix));
      }
    }, {
      key: "_padFractionalZeros",
      value: function (t) {
        if (!t) return t;
        var e = t.split(this.radix);
        return e.length < 2 && e.push(""), e[1] = e[1].padEnd(this.scale, "0"), e.join(this.radix);
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, ".");
      },
      set: function (t) {
        wn(An(n.prototype), "unmaskedValue", t.replace(".", this.radix), this, !0);
      }
    }, {
      key: "typedValue",
      get: function () {
        return Number(this.unmaskedValue);
      },
      set: function (t) {
        wn(An(n.prototype), "unmaskedValue", String(t), this, !0);
      }
    }, {
      key: "number",
      get: function () {
        return this.typedValue;
      },
      set: function (t) {
        this.typedValue = t;
      }
    }, {
      key: "allowNegative",
      get: function () {
        return this.signed || null != this.min && this.min < 0 || null != this.max && this.max < 0;
      }
    }]), n;
  }(Zn);

  fu.DEFAULTS = {
    radix: ",",
    thousandsSeparator: "",
    mapToRadix: ["."],
    scale: 2,
    signed: !1,
    normalizeZeros: !0,
    padFractionalZeros: !1
  }, Yn.MaskedNumber = fu;

  var pu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n() {
      return gn(this, n), e.apply(this, arguments);
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        t.mask && (t.validate = t.mask), Dn(An(n.prototype), "_update", this).call(this, t);
      }
    }]), n;
  }(Zn);

  Yn.MaskedFunction = pu;

  var du = ["compiledMasks", "currentMaskRef", "currentMask"],
      vu = function (t) {
    _n(n, t);

    var e = Fn(n);

    function n(t) {
      var u;
      return gn(this, n), (u = e.call(this, Object.assign({}, n.DEFAULTS, t))).currentMask = null, u;
    }

    return mn(n, [{
      key: "_update",
      value: function (t) {
        Dn(An(n.prototype), "_update", this).call(this, t), "mask" in t && (this.compiledMasks = Array.isArray(t.mask) ? t.mask.map(function (t) {
          return Gn(t);
        }) : []);
      }
    }, {
      key: "_appendCharRaw",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = this._applyDispatch(t, e);

        return this.currentMask && n.aggregate(this.currentMask._appendChar(t, e)), n;
      }
    }, {
      key: "_applyDispatch",
      value: function () {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
            e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = e.tail && null != e._beforeTailState ? e._beforeTailState._value : this.value,
            u = this.rawInputValue,
            r = e.tail && null != e._beforeTailState ? e._beforeTailState._rawInputValue : u,
            i = u.slice(r.length),
            a = this.currentMask,
            s = new zn(),
            o = a && a.state;
        if (this.currentMask = this.doDispatch(t, Object.assign({}, e)), this.currentMask) if (this.currentMask !== a) {
          if (this.currentMask.reset(), r) {
            var l = this.currentMask.append(r, {
              raw: !0
            });
            s.tailShift = l.inserted.length - n.length;
          }

          i && (s.tailShift += this.currentMask.append(i, {
            raw: !0,
            tail: !0
          }).tailShift);
        } else this.currentMask.state = o;
        return s;
      }
    }, {
      key: "_appendPlaceholder",
      value: function () {
        var t = this._applyDispatch.apply(this, arguments);

        return this.currentMask && t.aggregate(this.currentMask._appendPlaceholder()), t;
      }
    }, {
      key: "doDispatch",
      value: function (t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return this.dispatch(t, this, e);
      }
    }, {
      key: "doValidate",
      value: function () {
        for (var t, e, u = arguments.length, r = new Array(u), i = 0; i < u; i++) r[i] = arguments[i];

        return (t = Dn(An(n.prototype), "doValidate", this)).call.apply(t, [this].concat(r)) && (!this.currentMask || (e = this.currentMask).doValidate.apply(e, r));
      }
    }, {
      key: "reset",
      value: function () {
        this.currentMask && this.currentMask.reset(), this.compiledMasks.forEach(function (t) {
          return t.reset();
        });
      }
    }, {
      key: "value",
      get: function () {
        return this.currentMask ? this.currentMask.value : "";
      },
      set: function (t) {
        wn(An(n.prototype), "value", t, this, !0);
      }
    }, {
      key: "unmaskedValue",
      get: function () {
        return this.currentMask ? this.currentMask.unmaskedValue : "";
      },
      set: function (t) {
        wn(An(n.prototype), "unmaskedValue", t, this, !0);
      }
    }, {
      key: "typedValue",
      get: function () {
        return this.currentMask ? this.currentMask.typedValue : "";
      },
      set: function (t) {
        var e = String(t);
        this.currentMask && (this.currentMask.typedValue = t, e = this.currentMask.unmaskedValue), this.unmaskedValue = e;
      }
    }, {
      key: "isComplete",
      get: function () {
        return !!this.currentMask && this.currentMask.isComplete;
      }
    }, {
      key: "remove",
      value: function () {
        var t,
            e = new zn();
        this.currentMask && e.aggregate((t = this.currentMask).remove.apply(t, arguments)).aggregate(this._applyDispatch());
        return e;
      }
    }, {
      key: "state",
      get: function () {
        return Object.assign({}, Dn(An(n.prototype), "state", this), {
          _rawInputValue: this.rawInputValue,
          compiledMasks: this.compiledMasks.map(function (t) {
            return t.state;
          }),
          currentMaskRef: this.currentMask,
          currentMask: this.currentMask && this.currentMask.state
        });
      },
      set: function (t) {
        var e = t.compiledMasks,
            u = t.currentMaskRef,
            r = t.currentMask,
            i = Cn(t, du);
        this.compiledMasks.forEach(function (t, n) {
          return t.state = e[n];
        }), null != u && (this.currentMask = u, this.currentMask.state = r), wn(An(n.prototype), "state", i, this, !0);
      }
    }, {
      key: "extractInput",
      value: function () {
        var t;
        return this.currentMask ? (t = this.currentMask).extractInput.apply(t, arguments) : "";
      }
    }, {
      key: "extractTail",
      value: function () {
        for (var t, e, u = arguments.length, r = new Array(u), i = 0; i < u; i++) r[i] = arguments[i];

        return this.currentMask ? (t = this.currentMask).extractTail.apply(t, r) : (e = Dn(An(n.prototype), "extractTail", this)).call.apply(e, [this].concat(r));
      }
    }, {
      key: "doCommit",
      value: function () {
        this.currentMask && this.currentMask.doCommit(), Dn(An(n.prototype), "doCommit", this).call(this);
      }
    }, {
      key: "nearestInputPos",
      value: function () {
        for (var t, e, u = arguments.length, r = new Array(u), i = 0; i < u; i++) r[i] = arguments[i];

        return this.currentMask ? (t = this.currentMask).nearestInputPos.apply(t, r) : (e = Dn(An(n.prototype), "nearestInputPos", this)).call.apply(e, [this].concat(r));
      }
    }, {
      key: "overwrite",
      get: function () {
        return this.currentMask ? this.currentMask.overwrite : Dn(An(n.prototype), "overwrite", this);
      },
      set: function (t) {
        console.warn('"overwrite" option is not available in dynamic mask, use this option in siblings');
      }
    }]), n;
  }(Zn);

  vu.DEFAULTS = {
    dispatch: function (t, e, n) {
      if (e.compiledMasks.length) {
        var u = e.rawInputValue,
            r = e.compiledMasks.map(function (e, r) {
          return e.reset(), e.append(u, {
            raw: !0
          }), e.append(t, n), {
            weight: e.rawInputValue.length,
            index: r
          };
        });
        return r.sort(function (t, e) {
          return e.weight - t.weight;
        }), e.compiledMasks[r[0].index];
      }
    }
  }, Yn.MaskedDynamic = vu;
  var ku = {
    MASKED: "value",
    UNMASKED: "unmaskedValue",
    TYPED: "typedValue"
  };

  function gu(t) {
    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ku.MASKED,
        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ku.MASKED,
        u = Gn(t);
    return function (t) {
      return u.runIsolated(function (u) {
        return u[e] = t, u[n];
      });
    };
  }

  function yu(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), u = 1; u < e; u++) n[u - 1] = arguments[u];

    return gu.apply(void 0, n)(t);
  }

  Yn.PIPE_TYPE = ku, Yn.createPipe = gu, Yn.pipe = yu;

  try {
    globalThis.IMask = Yn;
  } catch (t) {}

  t.HTMLContenteditableMaskElement = ou, t.HTMLMaskElement = su, t.InputMask = hu, t.MaskElement = au, t.Masked = Zn, t.MaskedDate = iu, t.MaskedDynamic = vu, t.MaskedEnum = cu, t.MaskedFunction = pu, t.MaskedNumber = fu, t.MaskedPattern = nu, t.MaskedRange = ru, t.MaskedRegExp = tu, t.PIPE_TYPE = ku, t.createMask = Gn, t.createPipe = gu, t.default = Yn, t.pipe = yu, Object.defineProperty(t, "__esModule", {
    value: !0
  });
});
/*!
 * Flickity PACKAGED v2.2.2
 * Touch, responsive, flickable carousels
 *
 * Licensed GPLv3 for open source use
 * or Flickity Commercial License for commercial use
 *
 * https://flickity.metafizzy.co
 * Copyright 2015-2021 Metafizzy
 */
(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("jquery-bridget/jquery-bridget", ["jquery"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("jquery"));
  } else {
    e.jQueryBridget = i(e, e.jQuery);
  }
})(window, function t(e, r) {
  "use strict";

  var o = Array.prototype.slice;
  var i = e.console;
  var u = typeof i == "undefined" ? function () {} : function (t) {
    i.error(t);
  };

  function n(h, s, c) {
    c = c || r || e.jQuery;

    if (!c) {
      return;
    }

    if (!s.prototype.option) {
      s.prototype.option = function (t) {
        if (!c.isPlainObject(t)) {
          return;
        }

        this.options = c.extend(true, this.options, t);
      };
    }

    c.fn[h] = function (t) {
      if (typeof t == "string") {
        var e = o.call(arguments, 1);
        return i(this, t, e);
      }

      n(this, t);
      return this;
    };

    function i(t, r, o) {
      var a;
      var l = "$()." + h + '("' + r + '")';
      t.each(function (t, e) {
        var i = c.data(e, h);

        if (!i) {
          u(h + " not initialized. Cannot call methods, i.e. " + l);
          return;
        }

        var n = i[r];

        if (!n || r.charAt(0) == "_") {
          u(l + " is not a valid method");
          return;
        }

        var s = n.apply(i, o);
        a = a === undefined ? s : a;
      });
      return a !== undefined ? a : t;
    }

    function n(t, n) {
      t.each(function (t, e) {
        var i = c.data(e, h);

        if (i) {
          i.option(n);

          i._init();
        } else {
          i = new s(e, n);
          c.data(e, h, i);
        }
      });
    }

    a(c);
  }

  function a(t) {
    if (!t || t && t.bridget) {
      return;
    }

    t.bridget = n;
  }

  a(r || e.jQuery);
  return n;
});

(function (t, e) {
  if (typeof define == "function" && define.amd) {
    define("ev-emitter/ev-emitter", e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e();
  } else {
    t.EvEmitter = e();
  }
})(typeof window != "undefined" ? window : this, function () {
  function t() {}

  var e = t.prototype;

  e.on = function (t, e) {
    if (!t || !e) {
      return;
    }

    var i = this._events = this._events || {};
    var n = i[t] = i[t] || [];

    if (n.indexOf(e) == -1) {
      n.push(e);
    }

    return this;
  };

  e.once = function (t, e) {
    if (!t || !e) {
      return;
    }

    this.on(t, e);
    var i = this._onceEvents = this._onceEvents || {};
    var n = i[t] = i[t] || {};
    n[e] = true;
    return this;
  };

  e.off = function (t, e) {
    var i = this._events && this._events[t];

    if (!i || !i.length) {
      return;
    }

    var n = i.indexOf(e);

    if (n != -1) {
      i.splice(n, 1);
    }

    return this;
  };

  e.emitEvent = function (t, e) {
    var i = this._events && this._events[t];

    if (!i || !i.length) {
      return;
    }

    i = i.slice(0);
    e = e || [];
    var n = this._onceEvents && this._onceEvents[t];

    for (var s = 0; s < i.length; s++) {
      var r = i[s];
      var o = n && n[r];

      if (o) {
        this.off(t, r);
        delete n[r];
      }

      r.apply(this, e);
    }

    return this;
  };

  e.allOff = function () {
    delete this._events;
    delete this._onceEvents;
  };

  return t;
});
/*!
 * getSize v2.0.3
 * measure size of elements
 * MIT license
 */


(function (t, e) {
  if (typeof define == "function" && define.amd) {
    define("get-size/get-size", e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e();
  } else {
    t.getSize = e();
  }
})(window, function t() {
  "use strict";

  function m(t) {
    var e = parseFloat(t);
    var i = t.indexOf("%") == -1 && !isNaN(e);
    return i && e;
  }

  function e() {}

  var i = typeof console == "undefined" ? e : function (t) {
    console.error(t);
  };
  var y = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"];
  var b = y.length;

  function E() {
    var t = {
      width: 0,
      height: 0,
      innerWidth: 0,
      innerHeight: 0,
      outerWidth: 0,
      outerHeight: 0
    };

    for (var e = 0; e < b; e++) {
      var i = y[e];
      t[i] = 0;
    }

    return t;
  }

  function S(t) {
    var e = getComputedStyle(t);

    if (!e) {
      i("Style returned " + e + ". Are you running this code in a hidden iframe on Firefox? " + "See https://bit.ly/getsizebug1");
    }

    return e;
  }

  var n = false;
  var C;

  function x() {
    if (n) {
      return;
    }

    n = true;
    var t = document.createElement("div");
    t.style.width = "200px";
    t.style.padding = "1px 2px 3px 4px";
    t.style.borderStyle = "solid";
    t.style.borderWidth = "1px 2px 3px 4px";
    t.style.boxSizing = "border-box";
    var e = document.body || document.documentElement;
    e.appendChild(t);
    var i = S(t);
    C = Math.round(m(i.width)) == 200;
    s.isBoxSizeOuter = C;
    e.removeChild(t);
  }

  function s(t) {
    x();

    if (typeof t == "string") {
      t = document.querySelector(t);
    }

    if (!t || typeof t != "object" || !t.nodeType) {
      return;
    }

    var e = S(t);

    if (e.display == "none") {
      return E();
    }

    var i = {};
    i.width = t.offsetWidth;
    i.height = t.offsetHeight;
    var n = i.isBorderBox = e.boxSizing == "border-box";

    for (var s = 0; s < b; s++) {
      var r = y[s];
      var o = e[r];
      var a = parseFloat(o);
      i[r] = !isNaN(a) ? a : 0;
    }

    var l = i.paddingLeft + i.paddingRight;
    var h = i.paddingTop + i.paddingBottom;
    var c = i.marginLeft + i.marginRight;
    var u = i.marginTop + i.marginBottom;
    var d = i.borderLeftWidth + i.borderRightWidth;
    var f = i.borderTopWidth + i.borderBottomWidth;
    var p = n && C;
    var v = m(e.width);

    if (v !== false) {
      i.width = v + (p ? 0 : l + d);
    }

    var g = m(e.height);

    if (g !== false) {
      i.height = g + (p ? 0 : h + f);
    }

    i.innerWidth = i.width - (l + d);
    i.innerHeight = i.height - (h + f);
    i.outerWidth = i.width + c;
    i.outerHeight = i.height + u;
    return i;
  }

  return s;
});

(function (t, e) {
  "use strict";

  if (typeof define == "function" && define.amd) {
    define("desandro-matches-selector/matches-selector", e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e();
  } else {
    t.matchesSelector = e();
  }
})(window, function t() {
  "use strict";

  var n = function () {
    var t = window.Element.prototype;

    if (t.matches) {
      return "matches";
    }

    if (t.matchesSelector) {
      return "matchesSelector";
    }

    var e = ["webkit", "moz", "ms", "o"];

    for (var i = 0; i < e.length; i++) {
      var n = e[i];
      var s = n + "MatchesSelector";

      if (t[s]) {
        return s;
      }
    }
  }();

  return function t(e, i) {
    return e[n](i);
  };
});

(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("desandro-matches-selector"));
  } else {
    e.fizzyUIUtils = i(e, e.matchesSelector);
  }
})(window, function t(h, r) {
  var c = {};

  c.extend = function (t, e) {
    for (var i in e) {
      t[i] = e[i];
    }

    return t;
  };

  c.modulo = function (t, e) {
    return (t % e + e) % e;
  };

  var i = Array.prototype.slice;

  c.makeArray = function (t) {
    if (Array.isArray(t)) {
      return t;
    }

    if (t === null || t === undefined) {
      return [];
    }

    var e = typeof t == "object" && typeof t.length == "number";

    if (e) {
      return i.call(t);
    }

    return [t];
  };

  c.removeFrom = function (t, e) {
    var i = t.indexOf(e);

    if (i != -1) {
      t.splice(i, 1);
    }
  };

  c.getParent = function (t, e) {
    while (t.parentNode && t != document.body) {
      t = t.parentNode;

      if (r(t, e)) {
        return t;
      }
    }
  };

  c.getQueryElement = function (t) {
    if (typeof t == "string") {
      return document.querySelector(t);
    }

    return t;
  };

  c.handleEvent = function (t) {
    var e = "on" + t.type;

    if (this[e]) {
      this[e](t);
    }
  };

  c.filterFindElements = function (t, n) {
    t = c.makeArray(t);
    var s = [];
    t.forEach(function (t) {
      if (!(t instanceof HTMLElement)) {
        return;
      }

      if (!n) {
        s.push(t);
        return;
      }

      if (r(t, n)) {
        s.push(t);
      }

      var e = t.querySelectorAll(n);

      for (var i = 0; i < e.length; i++) {
        s.push(e[i]);
      }
    });
    return s;
  };

  c.debounceMethod = function (t, e, n) {
    n = n || 100;
    var s = t.prototype[e];
    var r = e + "Timeout";

    t.prototype[e] = function () {
      var t = this[r];
      clearTimeout(t);
      var e = arguments;
      var i = this;
      this[r] = setTimeout(function () {
        s.apply(i, e);
        delete i[r];
      }, n);
    };
  };

  c.docReady = function (t) {
    var e = document.readyState;

    if (e == "complete" || e == "interactive") {
      setTimeout(t);
    } else {
      document.addEventListener("DOMContentLoaded", t);
    }
  };

  c.toDashed = function (t) {
    return t.replace(/(.)([A-Z])/g, function (t, e, i) {
      return e + "-" + i;
    }).toLowerCase();
  };

  var u = h.console;

  c.htmlInit = function (a, l) {
    c.docReady(function () {
      var t = c.toDashed(l);
      var s = "data-" + t;
      var e = document.querySelectorAll("[" + s + "]");
      var i = document.querySelectorAll(".js-" + t);
      var n = c.makeArray(e).concat(c.makeArray(i));
      var r = s + "-options";
      var o = h.jQuery;
      n.forEach(function (e) {
        var t = e.getAttribute(s) || e.getAttribute(r);
        var i;

        try {
          i = t && JSON.parse(t);
        } catch (t) {
          if (u) {
            u.error("Error parsing " + s + " on " + e.className + ": " + t);
          }

          return;
        }

        var n = new a(e, i);

        if (o) {
          o.data(e, l, n);
        }
      });
    });
  };

  return c;
});

(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/cell", ["get-size/get-size"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("get-size"));
  } else {
    e.Flickity = e.Flickity || {};
    e.Flickity.Cell = i(e, e.getSize);
  }
})(window, function t(e, i) {
  function n(t, e) {
    this.element = t;
    this.parent = e;
    this.create();
  }

  var s = n.prototype;

  s.create = function () {
    this.element.style.position = "absolute";
    this.element.setAttribute("aria-hidden", "true");
    this.x = 0;
    this.shift = 0;
  };

  s.destroy = function () {
    this.unselect();
    this.element.style.position = "";
    var t = this.parent.originSide;
    this.element.style[t] = "";
    this.element.removeAttribute("aria-hidden");
  };

  s.getSize = function () {
    this.size = i(this.element);
  };

  s.setPosition = function (t) {
    this.x = t;
    this.updateTarget();
    this.renderPosition(t);
  };

  s.updateTarget = s.setDefaultTarget = function () {
    var t = this.parent.originSide == "left" ? "marginLeft" : "marginRight";
    this.target = this.x + this.size[t] + this.size.width * this.parent.cellAlign;
  };

  s.renderPosition = function (t) {
    var e = this.parent.originSide;
    this.element.style[e] = this.parent.getPositionValue(t);
  };

  s.select = function () {
    this.element.classList.add("is-selected");
    this.element.removeAttribute("aria-hidden");
  };

  s.unselect = function () {
    this.element.classList.remove("is-selected");
    this.element.setAttribute("aria-hidden", "true");
  };

  s.wrapShift = function (t) {
    this.shift = t;
    this.renderPosition(this.x + this.parent.slideableWidth * t);
  };

  s.remove = function () {
    this.element.parentNode.removeChild(this.element);
  };

  return n;
});

(function (t, e) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/slide", e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e();
  } else {
    t.Flickity = t.Flickity || {};
    t.Flickity.Slide = e();
  }
})(window, function t() {
  "use strict";

  function e(t) {
    this.parent = t;
    this.isOriginLeft = t.originSide == "left";
    this.cells = [];
    this.outerWidth = 0;
    this.height = 0;
  }

  var i = e.prototype;

  i.addCell = function (t) {
    this.cells.push(t);
    this.outerWidth += t.size.outerWidth;
    this.height = Math.max(t.size.outerHeight, this.height);

    if (this.cells.length == 1) {
      this.x = t.x;
      var e = this.isOriginLeft ? "marginLeft" : "marginRight";
      this.firstMargin = t.size[e];
    }
  };

  i.updateTarget = function () {
    var t = this.isOriginLeft ? "marginRight" : "marginLeft";
    var e = this.getLastCell();
    var i = e ? e.size[t] : 0;
    var n = this.outerWidth - (this.firstMargin + i);
    this.target = this.x + this.firstMargin + n * this.parent.cellAlign;
  };

  i.getLastCell = function () {
    return this.cells[this.cells.length - 1];
  };

  i.select = function () {
    this.cells.forEach(function (t) {
      t.select();
    });
  };

  i.unselect = function () {
    this.cells.forEach(function (t) {
      t.unselect();
    });
  };

  i.getCellElements = function () {
    return this.cells.map(function (t) {
      return t.element;
    });
  };

  return e;
});

(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/animate", ["fizzy-ui-utils/utils"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("fizzy-ui-utils"));
  } else {
    e.Flickity = e.Flickity || {};
    e.Flickity.animatePrototype = i(e, e.fizzyUIUtils);
  }
})(window, function t(e, i) {
  var n = {};

  n.startAnimation = function () {
    if (this.isAnimating) {
      return;
    }

    this.isAnimating = true;
    this.restingFrames = 0;
    this.animate();
  };

  n.animate = function () {
    this.applyDragForce();
    this.applySelectedAttraction();
    var t = this.x;
    this.integratePhysics();
    this.positionSlider();
    this.settle(t);

    if (this.isAnimating) {
      var e = this;
      requestAnimationFrame(function t() {
        e.animate();
      });
    }
  };

  n.positionSlider = function () {
    var t = this.x;

    if (this.options.wrapAround && this.cells.length > 1) {
      t = i.modulo(t, this.slideableWidth);
      t -= this.slideableWidth;
      this.shiftWrapCells(t);
    }

    this.setTranslateX(t, this.isAnimating);
    this.dispatchScrollEvent();
  };

  n.setTranslateX = function (t, e) {
    t += this.cursorPosition;
    t = this.options.rightToLeft ? -t : t;
    var i = this.getPositionValue(t);
    this.slider.style.transform = e ? "translate3d(" + i + ",0,0)" : "translateX(" + i + ")";
  };

  n.dispatchScrollEvent = function () {
    var t = this.slides[0];

    if (!t) {
      return;
    }

    var e = -this.x - t.target;
    var i = e / this.slidesWidth;
    this.dispatchEvent("scroll", null, [i, e]);
  };

  n.positionSliderAtSelected = function () {
    if (!this.cells.length) {
      return;
    }

    this.x = -this.selectedSlide.target;
    this.velocity = 0;
    this.positionSlider();
  };

  n.getPositionValue = function (t) {
    if (this.options.percentPosition) {
      return Math.round(t / this.size.innerWidth * 1e4) * .01 + "%";
    } else {
      return Math.round(t) + "px";
    }
  };

  n.settle = function (t) {
    var e = !this.isPointerDown && Math.round(this.x * 100) == Math.round(t * 100);

    if (e) {
      this.restingFrames++;
    }

    if (this.restingFrames > 2) {
      this.isAnimating = false;
      delete this.isFreeScrolling;
      this.positionSlider();
      this.dispatchEvent("settle", null, [this.selectedIndex]);
    }
  };

  n.shiftWrapCells = function (t) {
    var e = this.cursorPosition + t;

    this._shiftCells(this.beforeShiftCells, e, -1);

    var i = this.size.innerWidth - (t + this.slideableWidth + this.cursorPosition);

    this._shiftCells(this.afterShiftCells, i, 1);
  };

  n._shiftCells = function (t, e, i) {
    for (var n = 0; n < t.length; n++) {
      var s = t[n];
      var r = e > 0 ? i : 0;
      s.wrapShift(r);
      e -= s.size.outerWidth;
    }
  };

  n._unshiftCells = function (t) {
    if (!t || !t.length) {
      return;
    }

    for (var e = 0; e < t.length; e++) {
      t[e].wrapShift(0);
    }
  };

  n.integratePhysics = function () {
    this.x += this.velocity;
    this.velocity *= this.getFrictionFactor();
  };

  n.applyForce = function (t) {
    this.velocity += t;
  };

  n.getFrictionFactor = function () {
    return 1 - this.options[this.isFreeScrolling ? "freeScrollFriction" : "friction"];
  };

  n.getRestingPosition = function () {
    return this.x + this.velocity / (1 - this.getFrictionFactor());
  };

  n.applyDragForce = function () {
    if (!this.isDraggable || !this.isPointerDown) {
      return;
    }

    var t = this.dragX - this.x;
    var e = t - this.velocity;
    this.applyForce(e);
  };

  n.applySelectedAttraction = function () {
    var t = this.isDraggable && this.isPointerDown;

    if (t || this.isFreeScrolling || !this.slides.length) {
      return;
    }

    var e = this.selectedSlide.target * -1 - this.x;
    var i = e * this.options.selectedAttraction;
    this.applyForce(i);
  };

  return n;
});

(function (o, a) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/flickity", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./cell", "./slide", "./animate"], function (t, e, i, n, s, r) {
      return a(o, t, e, i, n, s, r);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = a(o, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./cell"), require("./slide"), require("./animate"));
  } else {
    var t = o.Flickity;
    o.Flickity = a(o, o.EvEmitter, o.getSize, o.fizzyUIUtils, t.Cell, t.Slide, t.animatePrototype);
  }
})(window, function t(n, e, i, a, s, o, r) {
  var l = n.jQuery;
  var h = n.getComputedStyle;
  var c = n.console;

  function u(t, e) {
    t = a.makeArray(t);

    while (t.length) {
      e.appendChild(t.shift());
    }
  }

  var d = 0;
  var f = {};

  function p(t, e) {
    var i = a.getQueryElement(t);

    if (!i) {
      if (c) {
        c.error("Bad element for Flickity: " + (i || t));
      }

      return;
    }

    this.element = i;

    if (this.element.flickityGUID) {
      var n = f[this.element.flickityGUID];
      if (n) n.option(e);
      return n;
    }

    if (l) {
      this.$element = l(this.element);
    }

    this.options = a.extend({}, this.constructor.defaults);
    this.option(e);

    this._create();
  }

  p.defaults = {
    accessibility: true,
    cellAlign: "center",
    freeScrollFriction: .075,
    friction: .28,
    namespaceJQueryEvents: true,
    percentPosition: true,
    resize: true,
    selectedAttraction: .025,
    setGallerySize: true
  };
  p.createMethods = [];
  var v = p.prototype;
  a.extend(v, e.prototype);

  v._create = function () {
    var t = this.guid = ++d;
    this.element.flickityGUID = t;
    f[t] = this;
    this.selectedIndex = 0;
    this.restingFrames = 0;
    this.x = 0;
    this.velocity = 0;
    this.originSide = this.options.rightToLeft ? "right" : "left";
    this.viewport = document.createElement("div");
    this.viewport.className = "flickity-viewport";

    this._createSlider();

    if (this.options.resize || this.options.watchCSS) {
      n.addEventListener("resize", this);
    }

    for (var e in this.options.on) {
      var i = this.options.on[e];
      this.on(e, i);
    }

    p.createMethods.forEach(function (t) {
      this[t]();
    }, this);

    if (this.options.watchCSS) {
      this.watchCSS();
    } else {
      this.activate();
    }
  };

  v.option = function (t) {
    a.extend(this.options, t);
  };

  v.activate = function () {
    if (this.isActive) {
      return;
    }

    this.isActive = true;
    this.element.classList.add("flickity-enabled");

    if (this.options.rightToLeft) {
      this.element.classList.add("flickity-rtl");
    }

    this.getSize();

    var t = this._filterFindCellElements(this.element.children);

    u(t, this.slider);
    this.viewport.appendChild(this.slider);
    this.element.appendChild(this.viewport);
    this.reloadCells();

    if (this.options.accessibility) {
      this.element.tabIndex = 0;
      this.element.addEventListener("keydown", this);
    }

    this.emitEvent("activate");
    this.selectInitialIndex();
    this.isInitActivated = true;
    this.dispatchEvent("ready");
  };

  v._createSlider = function () {
    var t = document.createElement("div");
    t.className = "flickity-slider";
    t.style[this.originSide] = 0;
    this.slider = t;
  };

  v._filterFindCellElements = function (t) {
    return a.filterFindElements(t, this.options.cellSelector);
  };

  v.reloadCells = function () {
    this.cells = this._makeCells(this.slider.children);
    this.positionCells();

    this._getWrapShiftCells();

    this.setGallerySize();
  };

  v._makeCells = function (t) {
    var e = this._filterFindCellElements(t);

    var i = e.map(function (t) {
      return new s(t, this);
    }, this);
    return i;
  };

  v.getLastCell = function () {
    return this.cells[this.cells.length - 1];
  };

  v.getLastSlide = function () {
    return this.slides[this.slides.length - 1];
  };

  v.positionCells = function () {
    this._sizeCells(this.cells);

    this._positionCells(0);
  };

  v._positionCells = function (t) {
    t = t || 0;
    this.maxCellHeight = t ? this.maxCellHeight || 0 : 0;
    var e = 0;

    if (t > 0) {
      var i = this.cells[t - 1];
      e = i.x + i.size.outerWidth;
    }

    var n = this.cells.length;

    for (var s = t; s < n; s++) {
      var r = this.cells[s];
      r.setPosition(e);
      e += r.size.outerWidth;
      this.maxCellHeight = Math.max(r.size.outerHeight, this.maxCellHeight);
    }

    this.slideableWidth = e;
    this.updateSlides();

    this._containSlides();

    this.slidesWidth = n ? this.getLastSlide().target - this.slides[0].target : 0;
  };

  v._sizeCells = function (t) {
    t.forEach(function (t) {
      t.getSize();
    });
  };

  v.updateSlides = function () {
    this.slides = [];

    if (!this.cells.length) {
      return;
    }

    var n = new o(this);
    this.slides.push(n);
    var t = this.originSide == "left";
    var s = t ? "marginRight" : "marginLeft";

    var r = this._getCanCellFit();

    this.cells.forEach(function (t, e) {
      if (!n.cells.length) {
        n.addCell(t);
        return;
      }

      var i = n.outerWidth - n.firstMargin + (t.size.outerWidth - t.size[s]);

      if (r.call(this, e, i)) {
        n.addCell(t);
      } else {
        n.updateTarget();
        n = new o(this);
        this.slides.push(n);
        n.addCell(t);
      }
    }, this);
    n.updateTarget();
    this.updateSelectedSlide();
  };

  v._getCanCellFit = function () {
    var t = this.options.groupCells;

    if (!t) {
      return function () {
        return false;
      };
    } else if (typeof t == "number") {
      var e = parseInt(t, 10);
      return function (t) {
        return t % e !== 0;
      };
    }

    var i = typeof t == "string" && t.match(/^(\d+)%$/);
    var n = i ? parseInt(i[1], 10) / 100 : 1;
    return function (t, e) {
      return e <= (this.size.innerWidth + 1) * n;
    };
  };

  v._init = v.reposition = function () {
    this.positionCells();
    this.positionSliderAtSelected();
  };

  v.getSize = function () {
    this.size = i(this.element);
    this.setCellAlign();
    this.cursorPosition = this.size.innerWidth * this.cellAlign;
  };

  var g = {
    center: {
      left: .5,
      right: .5
    },
    left: {
      left: 0,
      right: 1
    },
    right: {
      right: 0,
      left: 1
    }
  };

  v.setCellAlign = function () {
    var t = g[this.options.cellAlign];
    this.cellAlign = t ? t[this.originSide] : this.options.cellAlign;
  };

  v.setGallerySize = function () {
    if (this.options.setGallerySize) {
      var t = this.options.adaptiveHeight && this.selectedSlide ? this.selectedSlide.height : this.maxCellHeight;
      this.viewport.style.height = t + "px";
    }
  };

  v._getWrapShiftCells = function () {
    if (!this.options.wrapAround) {
      return;
    }

    this._unshiftCells(this.beforeShiftCells);

    this._unshiftCells(this.afterShiftCells);

    var t = this.cursorPosition;
    var e = this.cells.length - 1;
    this.beforeShiftCells = this._getGapCells(t, e, -1);
    t = this.size.innerWidth - this.cursorPosition;
    this.afterShiftCells = this._getGapCells(t, 0, 1);
  };

  v._getGapCells = function (t, e, i) {
    var n = [];

    while (t > 0) {
      var s = this.cells[e];

      if (!s) {
        break;
      }

      n.push(s);
      e += i;
      t -= s.size.outerWidth;
    }

    return n;
  };

  v._containSlides = function () {
    if (!this.options.contain || this.options.wrapAround || !this.cells.length) {
      return;
    }

    var t = this.options.rightToLeft;
    var e = t ? "marginRight" : "marginLeft";
    var i = t ? "marginLeft" : "marginRight";
    var n = this.slideableWidth - this.getLastCell().size[i];
    var s = n < this.size.innerWidth;
    var r = this.cursorPosition + this.cells[0].size[e];
    var o = n - this.size.innerWidth * (1 - this.cellAlign);
    this.slides.forEach(function (t) {
      if (s) {
        t.target = n * this.cellAlign;
      } else {
        t.target = Math.max(t.target, r);
        t.target = Math.min(t.target, o);
      }
    }, this);
  };

  v.dispatchEvent = function (t, e, i) {
    var n = e ? [e].concat(i) : i;
    this.emitEvent(t, n);

    if (l && this.$element) {
      t += this.options.namespaceJQueryEvents ? ".flickity" : "";
      var s = t;

      if (e) {
        var r = new l.Event(e);
        r.type = t;
        s = r;
      }

      this.$element.trigger(s, i);
    }
  };

  v.select = function (t, e, i) {
    if (!this.isActive) {
      return;
    }

    t = parseInt(t, 10);

    this._wrapSelect(t);

    if (this.options.wrapAround || e) {
      t = a.modulo(t, this.slides.length);
    }

    if (!this.slides[t]) {
      return;
    }

    var n = this.selectedIndex;
    this.selectedIndex = t;
    this.updateSelectedSlide();

    if (i) {
      this.positionSliderAtSelected();
    } else {
      this.startAnimation();
    }

    if (this.options.adaptiveHeight) {
      this.setGallerySize();
    }

    this.dispatchEvent("select", null, [t]);

    if (t != n) {
      this.dispatchEvent("change", null, [t]);
    }

    this.dispatchEvent("cellSelect");
  };

  v._wrapSelect = function (t) {
    var e = this.slides.length;
    var i = this.options.wrapAround && e > 1;

    if (!i) {
      return t;
    }

    var n = a.modulo(t, e);
    var s = Math.abs(n - this.selectedIndex);
    var r = Math.abs(n + e - this.selectedIndex);
    var o = Math.abs(n - e - this.selectedIndex);

    if (!this.isDragSelect && r < s) {
      t += e;
    } else if (!this.isDragSelect && o < s) {
      t -= e;
    }

    if (t < 0) {
      this.x -= this.slideableWidth;
    } else if (t >= e) {
      this.x += this.slideableWidth;
    }
  };

  v.previous = function (t, e) {
    this.select(this.selectedIndex - 1, t, e);
  };

  v.next = function (t, e) {
    this.select(this.selectedIndex + 1, t, e);
  };

  v.updateSelectedSlide = function () {
    var t = this.slides[this.selectedIndex];

    if (!t) {
      return;
    }

    this.unselectSelectedSlide();
    this.selectedSlide = t;
    t.select();
    this.selectedCells = t.cells;
    this.selectedElements = t.getCellElements();
    this.selectedCell = t.cells[0];
    this.selectedElement = this.selectedElements[0];
  };

  v.unselectSelectedSlide = function () {
    if (this.selectedSlide) {
      this.selectedSlide.unselect();
    }
  };

  v.selectInitialIndex = function () {
    var t = this.options.initialIndex;

    if (this.isInitActivated) {
      this.select(this.selectedIndex, false, true);
      return;
    }

    if (t && typeof t == "string") {
      var e = this.queryCell(t);

      if (e) {
        this.selectCell(t, false, true);
        return;
      }
    }

    var i = 0;

    if (t && this.slides[t]) {
      i = t;
    }

    this.select(i, false, true);
  };

  v.selectCell = function (t, e, i) {
    var n = this.queryCell(t);

    if (!n) {
      return;
    }

    var s = this.getCellSlideIndex(n);
    this.select(s, e, i);
  };

  v.getCellSlideIndex = function (t) {
    for (var e = 0; e < this.slides.length; e++) {
      var i = this.slides[e];
      var n = i.cells.indexOf(t);

      if (n != -1) {
        return e;
      }
    }
  };

  v.getCell = function (t) {
    for (var e = 0; e < this.cells.length; e++) {
      var i = this.cells[e];

      if (i.element == t) {
        return i;
      }
    }
  };

  v.getCells = function (t) {
    t = a.makeArray(t);
    var i = [];
    t.forEach(function (t) {
      var e = this.getCell(t);

      if (e) {
        i.push(e);
      }
    }, this);
    return i;
  };

  v.getCellElements = function () {
    return this.cells.map(function (t) {
      return t.element;
    });
  };

  v.getParentCell = function (t) {
    var e = this.getCell(t);

    if (e) {
      return e;
    }

    t = a.getParent(t, ".flickity-slider > *");
    return this.getCell(t);
  };

  v.getAdjacentCellElements = function (t, e) {
    if (!t) {
      return this.selectedSlide.getCellElements();
    }

    e = e === undefined ? this.selectedIndex : e;
    var i = this.slides.length;

    if (1 + t * 2 >= i) {
      return this.getCellElements();
    }

    var n = [];

    for (var s = e - t; s <= e + t; s++) {
      var r = this.options.wrapAround ? a.modulo(s, i) : s;
      var o = this.slides[r];

      if (o) {
        n = n.concat(o.getCellElements());
      }
    }

    return n;
  };

  v.queryCell = function (t) {
    if (typeof t == "number") {
      return this.cells[t];
    }

    if (typeof t == "string") {
      if (t.match(/^[#.]?[\d/]/)) {
        return;
      }

      t = this.element.querySelector(t);
    }

    return this.getCell(t);
  };

  v.uiChange = function () {
    this.emitEvent("uiChange");
  };

  v.childUIPointerDown = function (t) {
    if (t.type != "touchstart") {
      t.preventDefault();
    }

    this.focus();
  };

  v.onresize = function () {
    this.watchCSS();
    this.resize();
  };

  a.debounceMethod(p, "onresize", 150);

  v.resize = function () {
    if (!this.isActive) {
      return;
    }

    this.getSize();

    if (this.options.wrapAround) {
      this.x = a.modulo(this.x, this.slideableWidth);
    }

    this.positionCells();

    this._getWrapShiftCells();

    this.setGallerySize();
    this.emitEvent("resize");
    var t = this.selectedElements && this.selectedElements[0];
    this.selectCell(t, false, true);
  };

  v.watchCSS = function () {
    var t = this.options.watchCSS;

    if (!t) {
      return;
    }

    var e = h(this.element, ":after").content;

    if (e.indexOf("flickity") != -1) {
      this.activate();
    } else {
      this.deactivate();
    }
  };

  v.onkeydown = function (t) {
    var e = document.activeElement && document.activeElement != this.element;

    if (!this.options.accessibility || e) {
      return;
    }

    var i = p.keyboardHandlers[t.keyCode];

    if (i) {
      i.call(this);
    }
  };

  p.keyboardHandlers = {
    37: function () {
      var t = this.options.rightToLeft ? "next" : "previous";
      this.uiChange();
      this[t]();
    },
    39: function () {
      var t = this.options.rightToLeft ? "previous" : "next";
      this.uiChange();
      this[t]();
    }
  };

  v.focus = function () {
    var t = n.pageYOffset;
    this.element.focus({
      preventScroll: true
    });

    if (n.pageYOffset != t) {
      n.scrollTo(n.pageXOffset, t);
    }
  };

  v.deactivate = function () {
    if (!this.isActive) {
      return;
    }

    this.element.classList.remove("flickity-enabled");
    this.element.classList.remove("flickity-rtl");
    this.unselectSelectedSlide();
    this.cells.forEach(function (t) {
      t.destroy();
    });
    this.element.removeChild(this.viewport);
    u(this.slider.children, this.element);

    if (this.options.accessibility) {
      this.element.removeAttribute("tabIndex");
      this.element.removeEventListener("keydown", this);
    }

    this.isActive = false;
    this.emitEvent("deactivate");
  };

  v.destroy = function () {
    this.deactivate();
    n.removeEventListener("resize", this);
    this.allOff();
    this.emitEvent("destroy");

    if (l && this.$element) {
      l.removeData(this.element, "flickity");
    }

    delete this.element.flickityGUID;
    delete f[this.guid];
  };

  a.extend(v, r);

  p.data = function (t) {
    t = a.getQueryElement(t);
    var e = t && t.flickityGUID;
    return e && f[e];
  };

  a.htmlInit(p, "flickity");

  if (l && l.bridget) {
    l.bridget("flickity", p);
  }

  p.setJQuery = function (t) {
    l = t;
  };

  p.Cell = s;
  p.Slide = o;
  return p;
});
/*!
 * Unipointer v2.3.0
 * base class for doing one thing with pointer event
 * MIT license
 */


(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("unipointer/unipointer", ["ev-emitter/ev-emitter"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("ev-emitter"));
  } else {
    e.Unipointer = i(e, e.EvEmitter);
  }
})(window, function t(s, e) {
  function i() {}

  function n() {}

  var r = n.prototype = Object.create(e.prototype);

  r.bindStartEvent = function (t) {
    this._bindStartEvent(t, true);
  };

  r.unbindStartEvent = function (t) {
    this._bindStartEvent(t, false);
  };

  r._bindStartEvent = function (t, e) {
    e = e === undefined ? true : e;
    var i = e ? "addEventListener" : "removeEventListener";
    var n = "mousedown";

    if (s.PointerEvent) {
      n = "pointerdown";
    } else if ("ontouchstart" in s) {
      n = "touchstart";
    }

    t[i](n, this);
  };

  r.handleEvent = function (t) {
    var e = "on" + t.type;

    if (this[e]) {
      this[e](t);
    }
  };

  r.getTouch = function (t) {
    for (var e = 0; e < t.length; e++) {
      var i = t[e];

      if (i.identifier == this.pointerIdentifier) {
        return i;
      }
    }
  };

  r.onmousedown = function (t) {
    var e = t.button;

    if (e && e !== 0 && e !== 1) {
      return;
    }

    this._pointerDown(t, t);
  };

  r.ontouchstart = function (t) {
    this._pointerDown(t, t.changedTouches[0]);
  };

  r.onpointerdown = function (t) {
    this._pointerDown(t, t);
  };

  r._pointerDown = function (t, e) {
    if (t.button || this.isPointerDown) {
      return;
    }

    this.isPointerDown = true;
    this.pointerIdentifier = e.pointerId !== undefined ? e.pointerId : e.identifier;
    this.pointerDown(t, e);
  };

  r.pointerDown = function (t, e) {
    this._bindPostStartEvents(t);

    this.emitEvent("pointerDown", [t, e]);
  };

  var o = {
    mousedown: ["mousemove", "mouseup"],
    touchstart: ["touchmove", "touchend", "touchcancel"],
    pointerdown: ["pointermove", "pointerup", "pointercancel"]
  };

  r._bindPostStartEvents = function (t) {
    if (!t) {
      return;
    }

    var e = o[t.type];
    e.forEach(function (t) {
      s.addEventListener(t, this);
    }, this);
    this._boundPointerEvents = e;
  };

  r._unbindPostStartEvents = function () {
    if (!this._boundPointerEvents) {
      return;
    }

    this._boundPointerEvents.forEach(function (t) {
      s.removeEventListener(t, this);
    }, this);

    delete this._boundPointerEvents;
  };

  r.onmousemove = function (t) {
    this._pointerMove(t, t);
  };

  r.onpointermove = function (t) {
    if (t.pointerId == this.pointerIdentifier) {
      this._pointerMove(t, t);
    }
  };

  r.ontouchmove = function (t) {
    var e = this.getTouch(t.changedTouches);

    if (e) {
      this._pointerMove(t, e);
    }
  };

  r._pointerMove = function (t, e) {
    this.pointerMove(t, e);
  };

  r.pointerMove = function (t, e) {
    this.emitEvent("pointerMove", [t, e]);
  };

  r.onmouseup = function (t) {
    this._pointerUp(t, t);
  };

  r.onpointerup = function (t) {
    if (t.pointerId == this.pointerIdentifier) {
      this._pointerUp(t, t);
    }
  };

  r.ontouchend = function (t) {
    var e = this.getTouch(t.changedTouches);

    if (e) {
      this._pointerUp(t, e);
    }
  };

  r._pointerUp = function (t, e) {
    this._pointerDone();

    this.pointerUp(t, e);
  };

  r.pointerUp = function (t, e) {
    this.emitEvent("pointerUp", [t, e]);
  };

  r._pointerDone = function () {
    this._pointerReset();

    this._unbindPostStartEvents();

    this.pointerDone();
  };

  r._pointerReset = function () {
    this.isPointerDown = false;
    delete this.pointerIdentifier;
  };

  r.pointerDone = i;

  r.onpointercancel = function (t) {
    if (t.pointerId == this.pointerIdentifier) {
      this._pointerCancel(t, t);
    }
  };

  r.ontouchcancel = function (t) {
    var e = this.getTouch(t.changedTouches);

    if (e) {
      this._pointerCancel(t, e);
    }
  };

  r._pointerCancel = function (t, e) {
    this._pointerDone();

    this.pointerCancel(t, e);
  };

  r.pointerCancel = function (t, e) {
    this.emitEvent("pointerCancel", [t, e]);
  };

  n.getPointerPoint = function (t) {
    return {
      x: t.pageX,
      y: t.pageY
    };
  };

  return n;
});
/*!
 * Unidragger v2.3.1
 * Draggable base class
 * MIT license
 */


(function (e, i) {
  if (typeof define == "function" && define.amd) {
    define("unidragger/unidragger", ["unipointer/unipointer"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("unipointer"));
  } else {
    e.Unidragger = i(e, e.Unipointer);
  }
})(window, function t(r, e) {
  function i() {}

  var n = i.prototype = Object.create(e.prototype);

  n.bindHandles = function () {
    this._bindHandles(true);
  };

  n.unbindHandles = function () {
    this._bindHandles(false);
  };

  n._bindHandles = function (t) {
    t = t === undefined ? true : t;
    var e = t ? "addEventListener" : "removeEventListener";
    var i = t ? this._touchActionValue : "";

    for (var n = 0; n < this.handles.length; n++) {
      var s = this.handles[n];

      this._bindStartEvent(s, t);

      s[e]("click", this);

      if (r.PointerEvent) {
        s.style.touchAction = i;
      }
    }
  };

  n._touchActionValue = "none";

  n.pointerDown = function (t, e) {
    var i = this.okayPointerDown(t);

    if (!i) {
      return;
    }

    this.pointerDownPointer = {
      pageX: e.pageX,
      pageY: e.pageY
    };
    t.preventDefault();
    this.pointerDownBlur();

    this._bindPostStartEvents(t);

    this.emitEvent("pointerDown", [t, e]);
  };

  var s = {
    TEXTAREA: true,
    INPUT: true,
    SELECT: true,
    OPTION: true
  };
  var o = {
    radio: true,
    checkbox: true,
    button: true,
    submit: true,
    image: true,
    file: true
  };

  n.okayPointerDown = function (t) {
    var e = s[t.target.nodeName];
    var i = o[t.target.type];
    var n = !e || i;

    if (!n) {
      this._pointerReset();
    }

    return n;
  };

  n.pointerDownBlur = function () {
    var t = document.activeElement;
    var e = t && t.blur && t != document.body;

    if (e) {
      t.blur();
    }
  };

  n.pointerMove = function (t, e) {
    var i = this._dragPointerMove(t, e);

    this.emitEvent("pointerMove", [t, e, i]);

    this._dragMove(t, e, i);
  };

  n._dragPointerMove = function (t, e) {
    var i = {
      x: e.pageX - this.pointerDownPointer.pageX,
      y: e.pageY - this.pointerDownPointer.pageY
    };

    if (!this.isDragging && this.hasDragStarted(i)) {
      this._dragStart(t, e);
    }

    return i;
  };

  n.hasDragStarted = function (t) {
    return Math.abs(t.x) > 3 || Math.abs(t.y) > 3;
  };

  n.pointerUp = function (t, e) {
    this.emitEvent("pointerUp", [t, e]);

    this._dragPointerUp(t, e);
  };

  n._dragPointerUp = function (t, e) {
    if (this.isDragging) {
      this._dragEnd(t, e);
    } else {
      this._staticClick(t, e);
    }
  };

  n._dragStart = function (t, e) {
    this.isDragging = true;
    this.isPreventingClicks = true;
    this.dragStart(t, e);
  };

  n.dragStart = function (t, e) {
    this.emitEvent("dragStart", [t, e]);
  };

  n._dragMove = function (t, e, i) {
    if (!this.isDragging) {
      return;
    }

    this.dragMove(t, e, i);
  };

  n.dragMove = function (t, e, i) {
    t.preventDefault();
    this.emitEvent("dragMove", [t, e, i]);
  };

  n._dragEnd = function (t, e) {
    this.isDragging = false;
    setTimeout(function () {
      delete this.isPreventingClicks;
    }.bind(this));
    this.dragEnd(t, e);
  };

  n.dragEnd = function (t, e) {
    this.emitEvent("dragEnd", [t, e]);
  };

  n.onclick = function (t) {
    if (this.isPreventingClicks) {
      t.preventDefault();
    }
  };

  n._staticClick = function (t, e) {
    if (this.isIgnoringMouseUp && t.type == "mouseup") {
      return;
    }

    this.staticClick(t, e);

    if (t.type != "mouseup") {
      this.isIgnoringMouseUp = true;
      setTimeout(function () {
        delete this.isIgnoringMouseUp;
      }.bind(this), 400);
    }
  };

  n.staticClick = function (t, e) {
    this.emitEvent("staticClick", [t, e]);
  };

  i.getPointerPoint = e.getPointerPoint;
  return i;
});

(function (n, s) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/drag", ["./flickity", "unidragger/unidragger", "fizzy-ui-utils/utils"], function (t, e, i) {
      return s(n, t, e, i);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = s(n, require("./flickity"), require("unidragger"), require("fizzy-ui-utils"));
  } else {
    n.Flickity = s(n, n.Flickity, n.Unidragger, n.fizzyUIUtils);
  }
})(window, function t(n, e, i, a) {
  a.extend(e.defaults, {
    draggable: ">1",
    dragThreshold: 3
  });
  e.createMethods.push("_createDrag");
  var s = e.prototype;
  a.extend(s, i.prototype);
  s._touchActionValue = "pan-y";
  var r = ("createTouch" in document);
  var o = false;

  s._createDrag = function () {
    this.on("activate", this.onActivateDrag);
    this.on("uiChange", this._uiChangeDrag);
    this.on("deactivate", this.onDeactivateDrag);
    this.on("cellChange", this.updateDraggable);

    if (r && !o) {
      n.addEventListener("touchmove", function () {});
      o = true;
    }
  };

  s.onActivateDrag = function () {
    this.handles = [this.viewport];
    this.bindHandles();
    this.updateDraggable();
  };

  s.onDeactivateDrag = function () {
    this.unbindHandles();
    this.element.classList.remove("is-draggable");
  };

  s.updateDraggable = function () {
    if (this.options.draggable == ">1") {
      this.isDraggable = this.slides.length > 1;
    } else {
      this.isDraggable = this.options.draggable;
    }

    if (this.isDraggable) {
      this.element.classList.add("is-draggable");
    } else {
      this.element.classList.remove("is-draggable");
    }
  };

  s.bindDrag = function () {
    this.options.draggable = true;
    this.updateDraggable();
  };

  s.unbindDrag = function () {
    this.options.draggable = false;
    this.updateDraggable();
  };

  s._uiChangeDrag = function () {
    delete this.isFreeScrolling;
  };

  s.pointerDown = function (t, e) {
    if (!this.isDraggable) {
      this._pointerDownDefault(t, e);

      return;
    }

    var i = this.okayPointerDown(t);

    if (!i) {
      return;
    }

    this._pointerDownPreventDefault(t);

    this.pointerDownFocus(t);

    if (document.activeElement != this.element) {
      this.pointerDownBlur();
    }

    this.dragX = this.x;
    this.viewport.classList.add("is-pointer-down");
    this.pointerDownScroll = h();
    n.addEventListener("scroll", this);

    this._pointerDownDefault(t, e);
  };

  s._pointerDownDefault = function (t, e) {
    this.pointerDownPointer = {
      pageX: e.pageX,
      pageY: e.pageY
    };

    this._bindPostStartEvents(t);

    this.dispatchEvent("pointerDown", t, [e]);
  };

  var l = {
    INPUT: true,
    TEXTAREA: true,
    SELECT: true
  };

  s.pointerDownFocus = function (t) {
    var e = l[t.target.nodeName];

    if (!e) {
      this.focus();
    }
  };

  s._pointerDownPreventDefault = function (t) {
    var e = t.type == "touchstart";
    var i = t.pointerType == "touch";
    var n = l[t.target.nodeName];

    if (!e && !i && !n) {
      t.preventDefault();
    }
  };

  s.hasDragStarted = function (t) {
    return Math.abs(t.x) > this.options.dragThreshold;
  };

  s.pointerUp = function (t, e) {
    delete this.isTouchScrolling;
    this.viewport.classList.remove("is-pointer-down");
    this.dispatchEvent("pointerUp", t, [e]);

    this._dragPointerUp(t, e);
  };

  s.pointerDone = function () {
    n.removeEventListener("scroll", this);
    delete this.pointerDownScroll;
  };

  s.dragStart = function (t, e) {
    if (!this.isDraggable) {
      return;
    }

    this.dragStartPosition = this.x;
    this.startAnimation();
    n.removeEventListener("scroll", this);
    this.dispatchEvent("dragStart", t, [e]);
  };

  s.pointerMove = function (t, e) {
    var i = this._dragPointerMove(t, e);

    this.dispatchEvent("pointerMove", t, [e, i]);

    this._dragMove(t, e, i);
  };

  s.dragMove = function (t, e, i) {
    if (!this.isDraggable) {
      return;
    }

    t.preventDefault();
    this.previousDragX = this.dragX;
    var n = this.options.rightToLeft ? -1 : 1;

    if (this.options.wrapAround) {
      i.x %= this.slideableWidth;
    }

    var s = this.dragStartPosition + i.x * n;

    if (!this.options.wrapAround && this.slides.length) {
      var r = Math.max(-this.slides[0].target, this.dragStartPosition);
      s = s > r ? (s + r) * .5 : s;
      var o = Math.min(-this.getLastSlide().target, this.dragStartPosition);
      s = s < o ? (s + o) * .5 : s;
    }

    this.dragX = s;
    this.dragMoveTime = new Date();
    this.dispatchEvent("dragMove", t, [e, i]);
  };

  s.dragEnd = function (t, e) {
    if (!this.isDraggable) {
      return;
    }

    if (this.options.freeScroll) {
      this.isFreeScrolling = true;
    }

    var i = this.dragEndRestingSelect();

    if (this.options.freeScroll && !this.options.wrapAround) {
      var n = this.getRestingPosition();
      this.isFreeScrolling = -n > this.slides[0].target && -n < this.getLastSlide().target;
    } else if (!this.options.freeScroll && i == this.selectedIndex) {
      i += this.dragEndBoostSelect();
    }

    delete this.previousDragX;
    this.isDragSelect = this.options.wrapAround;
    this.select(i);
    delete this.isDragSelect;
    this.dispatchEvent("dragEnd", t, [e]);
  };

  s.dragEndRestingSelect = function () {
    var t = this.getRestingPosition();
    var e = Math.abs(this.getSlideDistance(-t, this.selectedIndex));

    var i = this._getClosestResting(t, e, 1);

    var n = this._getClosestResting(t, e, -1);

    var s = i.distance < n.distance ? i.index : n.index;
    return s;
  };

  s._getClosestResting = function (t, e, i) {
    var n = this.selectedIndex;
    var s = Infinity;
    var r = this.options.contain && !this.options.wrapAround ? function (t, e) {
      return t <= e;
    } : function (t, e) {
      return t < e;
    };

    while (r(e, s)) {
      n += i;
      s = e;
      e = this.getSlideDistance(-t, n);

      if (e === null) {
        break;
      }

      e = Math.abs(e);
    }

    return {
      distance: s,
      index: n - i
    };
  };

  s.getSlideDistance = function (t, e) {
    var i = this.slides.length;
    var n = this.options.wrapAround && i > 1;
    var s = n ? a.modulo(e, i) : e;
    var r = this.slides[s];

    if (!r) {
      return null;
    }

    var o = n ? this.slideableWidth * Math.floor(e / i) : 0;
    return t - (r.target + o);
  };

  s.dragEndBoostSelect = function () {
    if (this.previousDragX === undefined || !this.dragMoveTime || new Date() - this.dragMoveTime > 100) {
      return 0;
    }

    var t = this.getSlideDistance(-this.dragX, this.selectedIndex);
    var e = this.previousDragX - this.dragX;

    if (t > 0 && e > 0) {
      return 1;
    } else if (t < 0 && e < 0) {
      return -1;
    }

    return 0;
  };

  s.staticClick = function (t, e) {
    var i = this.getParentCell(t.target);
    var n = i && i.element;
    var s = i && this.cells.indexOf(i);
    this.dispatchEvent("staticClick", t, [e, n, s]);
  };

  s.onscroll = function () {
    var t = h();
    var e = this.pointerDownScroll.x - t.x;
    var i = this.pointerDownScroll.y - t.y;

    if (Math.abs(e) > 3 || Math.abs(i) > 3) {
      this._pointerDone();
    }
  };

  function h() {
    return {
      x: n.pageXOffset,
      y: n.pageYOffset
    };
  }

  return e;
});

(function (n, s) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/prev-next-button", ["./flickity", "unipointer/unipointer", "fizzy-ui-utils/utils"], function (t, e, i) {
      return s(n, t, e, i);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = s(n, require("./flickity"), require("unipointer"), require("fizzy-ui-utils"));
  } else {
    s(n, n.Flickity, n.Unipointer, n.fizzyUIUtils);
  }
})(window, function t(e, i, n, s) {
  "use strict";

  var r = "http://www.w3.org/2000/svg";

  function o(t, e) {
    this.direction = t;
    this.parent = e;

    this._create();
  }

  o.prototype = Object.create(n.prototype);

  o.prototype._create = function () {
    this.isEnabled = true;
    this.isPrevious = this.direction == -1;
    var t = this.parent.options.rightToLeft ? 1 : -1;
    this.isLeft = this.direction == t;
    var e = this.element = document.createElement("button");
    e.className = "flickity-button flickity-prev-next-button";
    e.className += this.isPrevious ? " previous" : " next";
    e.setAttribute("type", "button");
    this.disable();
    e.setAttribute("aria-label", this.isPrevious ? "Previous" : "Next");
    var i = this.createSVG();
    e.appendChild(i);
    this.parent.on("select", this.update.bind(this));
    this.on("pointerDown", this.parent.childUIPointerDown.bind(this.parent));
  };

  o.prototype.activate = function () {
    this.bindStartEvent(this.element);
    this.element.addEventListener("click", this);
    this.parent.element.appendChild(this.element);
  };

  o.prototype.deactivate = function () {
    this.parent.element.removeChild(this.element);
    this.unbindStartEvent(this.element);
    this.element.removeEventListener("click", this);
  };

  o.prototype.createSVG = function () {
    var t = document.createElementNS(r, "svg");
    t.setAttribute("class", "flickity-button-icon");
    t.setAttribute("viewBox", "0 0 100 100");
    var e = document.createElementNS(r, "path");
    var i = a(this.parent.options.arrowShape);
    e.setAttribute("d", i);
    e.setAttribute("class", "arrow");

    if (!this.isLeft) {
      e.setAttribute("transform", "translate(100, 100) rotate(180) ");
    }

    t.appendChild(e);
    return t;
  };

  function a(t) {
    if (typeof t == "string") {
      return t;
    }

    return "M " + t.x0 + ",50" + " L " + t.x1 + "," + (t.y1 + 50) + " L " + t.x2 + "," + (t.y2 + 50) + " L " + t.x3 + ",50 " + " L " + t.x2 + "," + (50 - t.y2) + " L " + t.x1 + "," + (50 - t.y1) + " Z";
  }

  o.prototype.handleEvent = s.handleEvent;

  o.prototype.onclick = function () {
    if (!this.isEnabled) {
      return;
    }

    this.parent.uiChange();
    var t = this.isPrevious ? "previous" : "next";
    this.parent[t]();
  };

  o.prototype.enable = function () {
    if (this.isEnabled) {
      return;
    }

    this.element.disabled = false;
    this.isEnabled = true;
  };

  o.prototype.disable = function () {
    if (!this.isEnabled) {
      return;
    }

    this.element.disabled = true;
    this.isEnabled = false;
  };

  o.prototype.update = function () {
    var t = this.parent.slides;

    if (this.parent.options.wrapAround && t.length > 1) {
      this.enable();
      return;
    }

    var e = t.length ? t.length - 1 : 0;
    var i = this.isPrevious ? 0 : e;
    var n = this.parent.selectedIndex == i ? "disable" : "enable";
    this[n]();
  };

  o.prototype.destroy = function () {
    this.deactivate();
    this.allOff();
  };

  s.extend(i.defaults, {
    prevNextButtons: true,
    arrowShape: {
      x0: 10,
      x1: 60,
      y1: 50,
      x2: 70,
      y2: 40,
      x3: 30
    }
  });
  i.createMethods.push("_createPrevNextButtons");
  var l = i.prototype;

  l._createPrevNextButtons = function () {
    if (!this.options.prevNextButtons) {
      return;
    }

    this.prevButton = new o(-1, this);
    this.nextButton = new o(1, this);
    this.on("activate", this.activatePrevNextButtons);
  };

  l.activatePrevNextButtons = function () {
    this.prevButton.activate();
    this.nextButton.activate();
    this.on("deactivate", this.deactivatePrevNextButtons);
  };

  l.deactivatePrevNextButtons = function () {
    this.prevButton.deactivate();
    this.nextButton.deactivate();
    this.off("deactivate", this.deactivatePrevNextButtons);
  };

  i.PrevNextButton = o;
  return i;
});

(function (n, s) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/page-dots", ["./flickity", "unipointer/unipointer", "fizzy-ui-utils/utils"], function (t, e, i) {
      return s(n, t, e, i);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = s(n, require("./flickity"), require("unipointer"), require("fizzy-ui-utils"));
  } else {
    s(n, n.Flickity, n.Unipointer, n.fizzyUIUtils);
  }
})(window, function t(e, i, n, s) {
  function r(t) {
    this.parent = t;

    this._create();
  }

  r.prototype = Object.create(n.prototype);

  r.prototype._create = function () {
    this.holder = document.createElement("ol");
    this.holder.className = "flickity-page-dots";
    this.dots = [];
    this.handleClick = this.onClick.bind(this);
    this.on("pointerDown", this.parent.childUIPointerDown.bind(this.parent));
  };

  r.prototype.activate = function () {
    this.setDots();
    this.holder.addEventListener("click", this.handleClick);
    this.bindStartEvent(this.holder);
    this.parent.element.appendChild(this.holder);
  };

  r.prototype.deactivate = function () {
    this.holder.removeEventListener("click", this.handleClick);
    this.unbindStartEvent(this.holder);
    this.parent.element.removeChild(this.holder);
  };

  r.prototype.setDots = function () {
    var t = this.parent.slides.length - this.dots.length;

    if (t > 0) {
      this.addDots(t);
    } else if (t < 0) {
      this.removeDots(-t);
    }
  };

  r.prototype.addDots = function (t) {
    var e = document.createDocumentFragment();
    var i = [];
    var n = this.dots.length;
    var s = n + t;

    for (var r = n; r < s; r++) {
      var o = document.createElement("li");
      o.className = "dot";
      o.setAttribute("aria-label", "Page dot " + (r + 1));
      e.appendChild(o);
      i.push(o);
    }

    this.holder.appendChild(e);
    this.dots = this.dots.concat(i);
  };

  r.prototype.removeDots = function (t) {
    var e = this.dots.splice(this.dots.length - t, t);
    e.forEach(function (t) {
      this.holder.removeChild(t);
    }, this);
  };

  r.prototype.updateSelected = function () {
    if (this.selectedDot) {
      this.selectedDot.className = "dot";
      this.selectedDot.removeAttribute("aria-current");
    }

    if (!this.dots.length) {
      return;
    }

    this.selectedDot = this.dots[this.parent.selectedIndex];
    this.selectedDot.className = "dot is-selected";
    this.selectedDot.setAttribute("aria-current", "step");
  };

  r.prototype.onTap = r.prototype.onClick = function (t) {
    var e = t.target;

    if (e.nodeName != "LI") {
      return;
    }

    this.parent.uiChange();
    var i = this.dots.indexOf(e);
    this.parent.select(i);
  };

  r.prototype.destroy = function () {
    this.deactivate();
    this.allOff();
  };

  i.PageDots = r;
  s.extend(i.defaults, {
    pageDots: true
  });
  i.createMethods.push("_createPageDots");
  var o = i.prototype;

  o._createPageDots = function () {
    if (!this.options.pageDots) {
      return;
    }

    this.pageDots = new r(this);
    this.on("activate", this.activatePageDots);
    this.on("select", this.updateSelectedPageDots);
    this.on("cellChange", this.updatePageDots);
    this.on("resize", this.updatePageDots);
    this.on("deactivate", this.deactivatePageDots);
  };

  o.activatePageDots = function () {
    this.pageDots.activate();
  };

  o.updateSelectedPageDots = function () {
    this.pageDots.updateSelected();
  };

  o.updatePageDots = function () {
    this.pageDots.setDots();
  };

  o.deactivatePageDots = function () {
    this.pageDots.deactivate();
  };

  i.PageDots = r;
  return i;
});

(function (t, n) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/player", ["ev-emitter/ev-emitter", "fizzy-ui-utils/utils", "./flickity"], function (t, e, i) {
      return n(t, e, i);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = n(require("ev-emitter"), require("fizzy-ui-utils"), require("./flickity"));
  } else {
    n(t.EvEmitter, t.fizzyUIUtils, t.Flickity);
  }
})(window, function t(e, i, n) {
  function s(t) {
    this.parent = t;
    this.state = "stopped";
    this.onVisibilityChange = this.visibilityChange.bind(this);
    this.onVisibilityPlay = this.visibilityPlay.bind(this);
  }

  s.prototype = Object.create(e.prototype);

  s.prototype.play = function () {
    if (this.state == "playing") {
      return;
    }

    var t = document.hidden;

    if (t) {
      document.addEventListener("visibilitychange", this.onVisibilityPlay);
      return;
    }

    this.state = "playing";
    document.addEventListener("visibilitychange", this.onVisibilityChange);
    this.tick();
  };

  s.prototype.tick = function () {
    if (this.state != "playing") {
      return;
    }

    var t = this.parent.options.autoPlay;
    t = typeof t == "number" ? t : 3e3;
    var e = this;
    this.clear();
    this.timeout = setTimeout(function () {
      e.parent.next(true);
      e.tick();
    }, t);
  };

  s.prototype.stop = function () {
    this.state = "stopped";
    this.clear();
    document.removeEventListener("visibilitychange", this.onVisibilityChange);
  };

  s.prototype.clear = function () {
    clearTimeout(this.timeout);
  };

  s.prototype.pause = function () {
    if (this.state == "playing") {
      this.state = "paused";
      this.clear();
    }
  };

  s.prototype.unpause = function () {
    if (this.state == "paused") {
      this.play();
    }
  };

  s.prototype.visibilityChange = function () {
    var t = document.hidden;
    this[t ? "pause" : "unpause"]();
  };

  s.prototype.visibilityPlay = function () {
    this.play();
    document.removeEventListener("visibilitychange", this.onVisibilityPlay);
  };

  i.extend(n.defaults, {
    pauseAutoPlayOnHover: true
  });
  n.createMethods.push("_createPlayer");
  var r = n.prototype;

  r._createPlayer = function () {
    this.player = new s(this);
    this.on("activate", this.activatePlayer);
    this.on("uiChange", this.stopPlayer);
    this.on("pointerDown", this.stopPlayer);
    this.on("deactivate", this.deactivatePlayer);
  };

  r.activatePlayer = function () {
    if (!this.options.autoPlay) {
      return;
    }

    this.player.play();
    this.element.addEventListener("mouseenter", this);
  };

  r.playPlayer = function () {
    this.player.play();
  };

  r.stopPlayer = function () {
    this.player.stop();
  };

  r.pausePlayer = function () {
    this.player.pause();
  };

  r.unpausePlayer = function () {
    this.player.unpause();
  };

  r.deactivatePlayer = function () {
    this.player.stop();
    this.element.removeEventListener("mouseenter", this);
  };

  r.onmouseenter = function () {
    if (!this.options.pauseAutoPlayOnHover) {
      return;
    }

    this.player.pause();
    this.element.addEventListener("mouseleave", this);
  };

  r.onmouseleave = function () {
    this.player.unpause();
    this.element.removeEventListener("mouseleave", this);
  };

  n.Player = s;
  return n;
});

(function (i, n) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/add-remove-cell", ["./flickity", "fizzy-ui-utils/utils"], function (t, e) {
      return n(i, t, e);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = n(i, require("./flickity"), require("fizzy-ui-utils"));
  } else {
    n(i, i.Flickity, i.fizzyUIUtils);
  }
})(window, function t(e, i, n) {
  function l(t) {
    var e = document.createDocumentFragment();
    t.forEach(function (t) {
      e.appendChild(t.element);
    });
    return e;
  }

  var s = i.prototype;

  s.insert = function (t, e) {
    var i = this._makeCells(t);

    if (!i || !i.length) {
      return;
    }

    var n = this.cells.length;
    e = e === undefined ? n : e;
    var s = l(i);
    var r = e == n;

    if (r) {
      this.slider.appendChild(s);
    } else {
      var o = this.cells[e].element;
      this.slider.insertBefore(s, o);
    }

    if (e === 0) {
      this.cells = i.concat(this.cells);
    } else if (r) {
      this.cells = this.cells.concat(i);
    } else {
      var a = this.cells.splice(e, n - e);
      this.cells = this.cells.concat(i).concat(a);
    }

    this._sizeCells(i);

    this.cellChange(e, true);
  };

  s.append = function (t) {
    this.insert(t, this.cells.length);
  };

  s.prepend = function (t) {
    this.insert(t, 0);
  };

  s.remove = function (t) {
    var e = this.getCells(t);

    if (!e || !e.length) {
      return;
    }

    var i = this.cells.length - 1;
    e.forEach(function (t) {
      t.remove();
      var e = this.cells.indexOf(t);
      i = Math.min(e, i);
      n.removeFrom(this.cells, t);
    }, this);
    this.cellChange(i, true);
  };

  s.cellSizeChange = function (t) {
    var e = this.getCell(t);

    if (!e) {
      return;
    }

    e.getSize();
    var i = this.cells.indexOf(e);
    this.cellChange(i);
  };

  s.cellChange = function (t, e) {
    var i = this.selectedElement;

    this._positionCells(t);

    this._getWrapShiftCells();

    this.setGallerySize();
    var n = this.getCell(i);

    if (n) {
      this.selectedIndex = this.getCellSlideIndex(n);
    }

    this.selectedIndex = Math.min(this.slides.length - 1, this.selectedIndex);
    this.emitEvent("cellChange", [t]);
    this.select(this.selectedIndex);

    if (e) {
      this.positionSliderAtSelected();
    }
  };

  return i;
});

(function (i, n) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/lazyload", ["./flickity", "fizzy-ui-utils/utils"], function (t, e) {
      return n(i, t, e);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = n(i, require("./flickity"), require("fizzy-ui-utils"));
  } else {
    n(i, i.Flickity, i.fizzyUIUtils);
  }
})(window, function t(e, i, o) {
  "use strict";

  i.createMethods.push("_createLazyload");
  var n = i.prototype;

  n._createLazyload = function () {
    this.on("select", this.lazyLoad);
  };

  n.lazyLoad = function () {
    var t = this.options.lazyLoad;

    if (!t) {
      return;
    }

    var e = typeof t == "number" ? t : 0;
    var i = this.getAdjacentCellElements(e);
    var n = [];
    i.forEach(function (t) {
      var e = s(t);
      n = n.concat(e);
    });
    n.forEach(function (t) {
      new r(t, this);
    }, this);
  };

  function s(t) {
    if (t.nodeName == "IMG") {
      var e = t.getAttribute("data-flickity-lazyload");
      var i = t.getAttribute("data-flickity-lazyload-src");
      var n = t.getAttribute("data-flickity-lazyload-srcset");

      if (e || i || n) {
        return [t];
      }
    }

    var s = "img[data-flickity-lazyload], " + "img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]";
    var r = t.querySelectorAll(s);
    return o.makeArray(r);
  }

  function r(t, e) {
    this.img = t;
    this.flickity = e;
    this.load();
  }

  r.prototype.handleEvent = o.handleEvent;

  r.prototype.load = function () {
    this.img.addEventListener("load", this);
    this.img.addEventListener("error", this);
    var t = this.img.getAttribute("data-flickity-lazyload") || this.img.getAttribute("data-flickity-lazyload-src");
    var e = this.img.getAttribute("data-flickity-lazyload-srcset");
    this.img.src = t;

    if (e) {
      this.img.setAttribute("srcset", e);
    }

    this.img.removeAttribute("data-flickity-lazyload");
    this.img.removeAttribute("data-flickity-lazyload-src");
    this.img.removeAttribute("data-flickity-lazyload-srcset");
  };

  r.prototype.onload = function (t) {
    this.complete(t, "flickity-lazyloaded");
  };

  r.prototype.onerror = function (t) {
    this.complete(t, "flickity-lazyerror");
  };

  r.prototype.complete = function (t, e) {
    this.img.removeEventListener("load", this);
    this.img.removeEventListener("error", this);
    var i = this.flickity.getParentCell(this.img);
    var n = i && i.element;
    this.flickity.cellSizeChange(n);
    this.img.classList.add(e);
    this.flickity.dispatchEvent("lazyLoad", t, n);
  };

  i.LazyLoader = r;
  return i;
});
/*!
 * Flickity v2.2.2
 * Touch, responsive, flickable carousels
 *
 * Licensed GPLv3 for open source use
 * or Flickity Commercial License for commercial use
 *
 * https://flickity.metafizzy.co
 * Copyright 2015-2021 Metafizzy
 */


(function (t, e) {
  if (typeof define == "function" && define.amd) {
    define("flickity/js/index", ["./flickity", "./drag", "./prev-next-button", "./page-dots", "./player", "./add-remove-cell", "./lazyload"], e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e(require("./flickity"), require("./drag"), require("./prev-next-button"), require("./page-dots"), require("./player"), require("./add-remove-cell"), require("./lazyload"));
  }
})(window, function t(e) {
  return e;
});
/*!
 * Flickity asNavFor v2.0.2
 * enable asNavFor for Flickity
 */


(function (t, e) {
  if (typeof define == "function" && define.amd) {
    define("flickity-as-nav-for/as-nav-for", ["flickity/js/index", "fizzy-ui-utils/utils"], e);
  } else if (typeof module == "object" && module.exports) {
    module.exports = e(require("flickity"), require("fizzy-ui-utils"));
  } else {
    t.Flickity = e(t.Flickity, t.fizzyUIUtils);
  }
})(window, function t(n, s) {
  n.createMethods.push("_createAsNavFor");
  var e = n.prototype;

  e._createAsNavFor = function () {
    this.on("activate", this.activateAsNavFor);
    this.on("deactivate", this.deactivateAsNavFor);
    this.on("destroy", this.destroyAsNavFor);
    var e = this.options.asNavFor;

    if (!e) {
      return;
    }

    var i = this;
    setTimeout(function t() {
      i.setNavCompanion(e);
    });
  };

  e.setNavCompanion = function (t) {
    t = s.getQueryElement(t);
    var e = n.data(t);

    if (!e || e == this) {
      return;
    }

    this.navCompanion = e;
    var i = this;

    this.onNavCompanionSelect = function () {
      i.navCompanionSelect();
    };

    e.on("select", this.onNavCompanionSelect);
    this.on("staticClick", this.onNavStaticClick);
    this.navCompanionSelect(true);
  };

  e.navCompanionSelect = function (t) {
    var e = this.navCompanion && this.navCompanion.selectedCells;

    if (!e) {
      return;
    }

    var i = e[0];
    var n = this.navCompanion.cells.indexOf(i);
    var s = n + e.length - 1;
    var r = Math.floor(a(n, s, this.navCompanion.cellAlign));
    this.selectCell(r, false, t);
    this.removeNavSelectedElements();

    if (r >= this.cells.length) {
      return;
    }

    var o = this.cells.slice(n, s + 1);
    this.navSelectedElements = o.map(function (t) {
      return t.element;
    });
    this.changeNavSelectedClass("add");
  };

  function a(t, e, i) {
    return (e - t) * i + t;
  }

  e.changeNavSelectedClass = function (e) {
    this.navSelectedElements.forEach(function (t) {
      t.classList[e]("is-nav-selected");
    });
  };

  e.activateAsNavFor = function () {
    this.navCompanionSelect(true);
  };

  e.removeNavSelectedElements = function () {
    if (!this.navSelectedElements) {
      return;
    }

    this.changeNavSelectedClass("remove");
    delete this.navSelectedElements;
  };

  e.onNavStaticClick = function (t, e, i, n) {
    if (typeof n == "number") {
      this.navCompanion.selectCell(n);
    }
  };

  e.deactivateAsNavFor = function () {
    this.removeNavSelectedElements();
  };

  e.destroyAsNavFor = function () {
    if (!this.navCompanion) {
      return;
    }

    this.navCompanion.off("select", this.onNavCompanionSelect);
    this.off("staticClick", this.onNavStaticClick);
    delete this.navCompanion;
  };

  return n;
});
/*!
 * imagesLoaded v4.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */


(function (e, i) {
  "use strict";

  if (typeof define == "function" && define.amd) {
    define("imagesloaded/imagesloaded", ["ev-emitter/ev-emitter"], function (t) {
      return i(e, t);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = i(e, require("ev-emitter"));
  } else {
    e.imagesLoaded = i(e, e.EvEmitter);
  }
})(typeof window !== "undefined" ? window : this, function t(e, i) {
  var s = e.jQuery;
  var r = e.console;

  function o(t, e) {
    for (var i in e) {
      t[i] = e[i];
    }

    return t;
  }

  var n = Array.prototype.slice;

  function a(t) {
    if (Array.isArray(t)) {
      return t;
    }

    var e = typeof t == "object" && typeof t.length == "number";

    if (e) {
      return n.call(t);
    }

    return [t];
  }

  function l(t, e, i) {
    if (!(this instanceof l)) {
      return new l(t, e, i);
    }

    var n = t;

    if (typeof t == "string") {
      n = document.querySelectorAll(t);
    }

    if (!n) {
      r.error("Bad element for imagesLoaded " + (n || t));
      return;
    }

    this.elements = a(n);
    this.options = o({}, this.options);

    if (typeof e == "function") {
      i = e;
    } else {
      o(this.options, e);
    }

    if (i) {
      this.on("always", i);
    }

    this.getImages();

    if (s) {
      this.jqDeferred = new s.Deferred();
    }

    setTimeout(this.check.bind(this));
  }

  l.prototype = Object.create(i.prototype);
  l.prototype.options = {};

  l.prototype.getImages = function () {
    this.images = [];
    this.elements.forEach(this.addElementImages, this);
  };

  l.prototype.addElementImages = function (t) {
    if (t.nodeName == "IMG") {
      this.addImage(t);
    }

    if (this.options.background === true) {
      this.addElementBackgroundImages(t);
    }

    var e = t.nodeType;

    if (!e || !h[e]) {
      return;
    }

    var i = t.querySelectorAll("img");

    for (var n = 0; n < i.length; n++) {
      var s = i[n];
      this.addImage(s);
    }

    if (typeof this.options.background == "string") {
      var r = t.querySelectorAll(this.options.background);

      for (n = 0; n < r.length; n++) {
        var o = r[n];
        this.addElementBackgroundImages(o);
      }
    }
  };

  var h = {
    1: true,
    9: true,
    11: true
  };

  l.prototype.addElementBackgroundImages = function (t) {
    var e = getComputedStyle(t);

    if (!e) {
      return;
    }

    var i = /url\((['"])?(.*?)\1\)/gi;
    var n = i.exec(e.backgroundImage);

    while (n !== null) {
      var s = n && n[2];

      if (s) {
        this.addBackground(s, t);
      }

      n = i.exec(e.backgroundImage);
    }
  };

  l.prototype.addImage = function (t) {
    var e = new c(t);
    this.images.push(e);
  };

  l.prototype.addBackground = function (t, e) {
    var i = new u(t, e);
    this.images.push(i);
  };

  l.prototype.check = function () {
    var n = this;
    this.progressedCount = 0;
    this.hasAnyBroken = false;

    if (!this.images.length) {
      this.complete();
      return;
    }

    function e(t, e, i) {
      setTimeout(function () {
        n.progress(t, e, i);
      });
    }

    this.images.forEach(function (t) {
      t.once("progress", e);
      t.check();
    });
  };

  l.prototype.progress = function (t, e, i) {
    this.progressedCount++;
    this.hasAnyBroken = this.hasAnyBroken || !t.isLoaded;
    this.emitEvent("progress", [this, t, e]);

    if (this.jqDeferred && this.jqDeferred.notify) {
      this.jqDeferred.notify(this, t);
    }

    if (this.progressedCount == this.images.length) {
      this.complete();
    }

    if (this.options.debug && r) {
      r.log("progress: " + i, t, e);
    }
  };

  l.prototype.complete = function () {
    var t = this.hasAnyBroken ? "fail" : "done";
    this.isComplete = true;
    this.emitEvent(t, [this]);
    this.emitEvent("always", [this]);

    if (this.jqDeferred) {
      var e = this.hasAnyBroken ? "reject" : "resolve";
      this.jqDeferred[e](this);
    }
  };

  function c(t) {
    this.img = t;
  }

  c.prototype = Object.create(i.prototype);

  c.prototype.check = function () {
    var t = this.getIsImageComplete();

    if (t) {
      this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
      return;
    }

    this.proxyImage = new Image();
    this.proxyImage.addEventListener("load", this);
    this.proxyImage.addEventListener("error", this);
    this.img.addEventListener("load", this);
    this.img.addEventListener("error", this);
    this.proxyImage.src = this.img.src;
  };

  c.prototype.getIsImageComplete = function () {
    return this.img.complete && this.img.naturalWidth;
  };

  c.prototype.confirm = function (t, e) {
    this.isLoaded = t;
    this.emitEvent("progress", [this, this.img, e]);
  };

  c.prototype.handleEvent = function (t) {
    var e = "on" + t.type;

    if (this[e]) {
      this[e](t);
    }
  };

  c.prototype.onload = function () {
    this.confirm(true, "onload");
    this.unbindEvents();
  };

  c.prototype.onerror = function () {
    this.confirm(false, "onerror");
    this.unbindEvents();
  };

  c.prototype.unbindEvents = function () {
    this.proxyImage.removeEventListener("load", this);
    this.proxyImage.removeEventListener("error", this);
    this.img.removeEventListener("load", this);
    this.img.removeEventListener("error", this);
  };

  function u(t, e) {
    this.url = t;
    this.element = e;
    this.img = new Image();
  }

  u.prototype = Object.create(c.prototype);

  u.prototype.check = function () {
    this.img.addEventListener("load", this);
    this.img.addEventListener("error", this);
    this.img.src = this.url;
    var t = this.getIsImageComplete();

    if (t) {
      this.confirm(this.img.naturalWidth !== 0, "naturalWidth");
      this.unbindEvents();
    }
  };

  u.prototype.unbindEvents = function () {
    this.img.removeEventListener("load", this);
    this.img.removeEventListener("error", this);
  };

  u.prototype.confirm = function (t, e) {
    this.isLoaded = t;
    this.emitEvent("progress", [this, this.element, e]);
  };

  l.makeJQueryPlugin = function (t) {
    t = t || e.jQuery;

    if (!t) {
      return;
    }

    s = t;

    s.fn.imagesLoaded = function (t, e) {
      var i = new l(this, t, e);
      return i.jqDeferred.promise(s(this));
    };
  };

  l.makeJQueryPlugin();
  return l;
});
/*!
 * Flickity imagesLoaded v2.0.0
 * enables imagesLoaded option for Flickity
 */


(function (i, n) {
  if (typeof define == "function" && define.amd) {
    define(["flickity/js/index", "imagesloaded/imagesloaded"], function (t, e) {
      return n(i, t, e);
    });
  } else if (typeof module == "object" && module.exports) {
    module.exports = n(i, require("flickity"), require("imagesloaded"));
  } else {
    i.Flickity = n(i, i.Flickity, i.imagesLoaded);
  }
})(window, function t(e, i, s) {
  "use strict";

  i.createMethods.push("_createImagesLoaded");
  var n = i.prototype;

  n._createImagesLoaded = function () {
    this.on("activate", this.imagesLoaded);
  };

  n.imagesLoaded = function () {
    if (!this.options.imagesLoaded) {
      return;
    }

    var n = this;

    function t(t, e) {
      var i = n.getParentCell(e.img);
      n.cellSizeChange(i && i.element);

      if (!n.options.freeScroll) {
        n.positionSliderAtSelected();
      }
    }

    s(this.slider).on("progress", t);
  };

  return i;
});
!function (root, factory) {
  "function" == typeof define && define.amd ? // AMD. Register as an anonymous module unless amdModuleId is set
  define([], function () {
    return root.svg4everybody = factory();
  }) : "object" == typeof module && module.exports ? // Node. Does not work with strict CommonJS, but
  // only CommonJS-like environments that support module.exports,
  // like Node.
  module.exports = factory() : root.svg4everybody = factory();
}(this, function () {
  /*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody */
  function embed(parent, svg, target) {
    // if the target exists
    if (target) {
      // create a document fragment to hold the contents of the target
      var fragment = document.createDocumentFragment(),
          viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox"); // conditionally set the viewBox on the svg

      viewBox && svg.setAttribute("viewBox", viewBox); // copy the contents of the clone into the fragment

      for ( // clone the target
      var clone = target.cloneNode(!0); clone.childNodes.length;) {
        fragment.appendChild(clone.firstChild);
      } // append the fragment into the svg


      parent.appendChild(fragment);
    }
  }

  function loadreadystatechange(xhr) {
    // listen to changes in the request
    xhr.onreadystatechange = function () {
      // if the request is ready
      if (4 === xhr.readyState) {
        // get the cached html document
        var cachedDocument = xhr._cachedDocument; // ensure the cached html document based on the xhr response

        cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}), // clear the xhr embeds list and embed each item
        xhr._embeds.splice(0).map(function (item) {
          // get the cached target
          var target = xhr._cachedTarget[item.id]; // ensure the cached target

          target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)), // embed the target into the svg
          embed(item.parent, item.svg, target);
        });
      }
    }, // test the ready state change immediately
    xhr.onreadystatechange();
  }

  function svg4everybody(rawopts) {
    function oninterval() {
      // while the index exists in the live <use> collection
      for ( // get the cached <use> index
      var index = 0; index < uses.length;) {
        // get the current <use>
        var use = uses[index],
            parent = use.parentNode,
            svg = getSVGAncestor(parent),
            src = use.getAttribute("xlink:href") || use.getAttribute("href");

        if (!src && opts.attributeName && (src = use.getAttribute(opts.attributeName)), svg && src) {
          if (polyfill) {
            if (!opts.validate || opts.validate(src, svg, use)) {
              // remove the <use> element
              parent.removeChild(use); // parse the src and get the url and id

              var srcSplit = src.split("#"),
                  url = srcSplit.shift(),
                  id = srcSplit.join("#"); // if the link is external

              if (url.length) {
                // get the cached xhr request
                var xhr = requests[url]; // ensure the xhr request exists

                xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), xhr._embeds = []), // add the svg and id as an item to the xhr embeds list
                xhr._embeds.push({
                  parent: parent,
                  svg: svg,
                  id: id
                }), // prepare the xhr ready state change event
                loadreadystatechange(xhr);
              } else {
                // embed the local id into the svg
                embed(parent, svg, document.getElementById(id));
              }
            } else {
              // increase the index when the previous value was not "valid"
              ++index, ++numberOfSvgUseElementsToBypass;
            }
          }
        } else {
          // increase the index when the previous value was not "valid"
          ++index;
        }
      } // continue the interval


      (!uses.length || uses.length - numberOfSvgUseElementsToBypass > 0) && requestAnimationFrame(oninterval, 67);
    }

    var polyfill,
        opts = Object(rawopts),
        newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/,
        webkitUA = /\bAppleWebKit\/(\d+)\b/,
        olderEdgeUA = /\bEdge\/12\.(\d+)\b/,
        edgeUA = /\bEdge\/.(\d+)\b/,
        inIframe = window.top !== window.self;
    polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537 || edgeUA.test(navigator.userAgent) && inIframe; // create xhr requests object

    var requests = {},
        requestAnimationFrame = window.requestAnimationFrame || setTimeout,
        uses = document.getElementsByTagName("use"),
        numberOfSvgUseElementsToBypass = 0; // conditionally start the interval if the polyfill is active

    polyfill && oninterval();
  }

  function getSVGAncestor(node) {
    for (var svg = node; "svg" !== svg.nodeName.toLowerCase() && (svg = svg.parentNode);) {}

    return svg;
  }

  return svg4everybody;
});
// document.addEventListener('DOMContentLoaded', function(){});
(function () {
  // Добавление/удаление модификаторов при клике на переключение видимости
  var toggler = document.getElementById('burger');

  if (toggler) {
    toggler.addEventListener('click', mobNavVisibleToggle);

    function mobNavVisibleToggle(e) {
      e.preventDefault(); //toggler.classList.toggle('burger--close'); // модификатор иконки (должен быть .burger)
      //document.getElementById('main-nav').classList.toggle('main-nav--open');
    }
  }
})();
/*(function() {
  window.cookieconsent.initialise({
    "palette": {
      "popup": {
        "background": "#ffffff",
        "text": "#020406"
      },
      "button": {
        "background": "#1870b7",
        "text": "#ffffff"
      }
    },
    "position": "bottom-right",
    "content": {
      "message": "Этот сайт использует файлы cookie в соответствии с <a href='https://www.cookiesandyou.com/'>Политикой использования файлов cookie</a>. Если Вы согласны на использование нами файлов cookie, то нажмите кнопку «Принять».",
      "dismiss": "Принять!",
      "link": "Подробнее"
    }
  });
})();
*/
// (function(){
//   const langSwitcher = document.getElementById('lang-switcher');
//   let togglerBtn = document.getElementById('lang-switcher-toggler');
//   let page = document.documentElement;
//   let lang = page.lang;
//   if (langSwitcher) {
//     const langChangeHandler = function (e) {
//       togglerBtn.innerHTML = lang;
//     }();
//   }
// }());
(function () {
  const mainNav = document.getElementById('main-nav');
  const menuItemArr = mainNav.querySelectorAll('.main-nav__list>.main-nav__item');
  const activeClass = 'active';
  const linkArrowClass = 'main-nav__link--arrow';

  for (let i = 0; i < menuItemArr.length; i++) {
    let currentItem = menuItemArr[i];
    let currentItemFirstChild = currentItem.firstChild.nextSibling;

    if (currentItem.classList.contains(activeClass) && currentItemFirstChild.classList.contains(linkArrowClass)) {
      mainNav.classList.add('main-nav--bot-margin');
    }
  }
})();
document.addEventListener('DOMContentLoaded', function () {
  (function () {
    // указатель на текущую страницу
    var pagination = document.querySelector('.pagination');
    var btns = document.querySelectorAll('.pagination__item');
    Array.prototype.forEach.call(btns, function (item) {
      var link = item.children[0];

      if (item.classList.contains('active')) {
        link.setAttribute('aria-current', 'page');
      } else {
        link.removeAttribute('aria-current');
      }
    });
  })();
});
document.addEventListener('DOMContentLoaded', function () {
  var links = document.querySelectorAll('[href^="#"][data-scroll-link]');

  for (var i = 0; i < links.length; i++) {
    links[i].addEventListener('click', function (e) {
      var hash = this.href.replace(/[^#]*(.*)/, '$1');

      if (hash && hash !== '#') {
        e.preventDefault();
        var scroll = window.pageYOffset;
        var targetTop = getOffsetRect(document.querySelector(hash)).top - 10; // С поправкой в 10px

        var scrollDiff = (scroll - targetTop) * -1;
        animate({
          duration: 500,
          timing: function (timeFraction) {
            return Math.pow(timeFraction, 4); // https://learn.javascript.ru/js-animation
          },
          draw: function (progress) {
            var scrollNow = scroll + progress * scrollDiff;
            window.scrollTo(0, scrollNow);
          }
        });
      }
    }, false);
  }

  function animate(_ref) {
    var timing = _ref.timing,
        draw = _ref.draw,
        duration = _ref.duration;
    var start = performance.now();
    requestAnimationFrame(function animate(time) {
      var timeFraction = (time - start) / duration;
      if (timeFraction > 1) timeFraction = 1;
      var progress = timing(timeFraction);
      draw(progress);

      if (timeFraction < 1) {
        requestAnimationFrame(animate);
      }
    });
  }

  function getOffsetRect(elem) {
    var box = elem.getBoundingClientRect();
    var body = document.body;
    var docElem = document.documentElement;
    var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
    var clientTop = docElem.clientTop || body.clientTop || 0;
    var clientLeft = docElem.clientLeft || body.clientLeft || 0;
    var top = box.top + scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;
    return {
      top: Math.round(top),
      left: Math.round(left)
    };
  }
});
svg4everybody();
// document.addEventListener('DOMContentLoaded', function(){});
(function () {
  const utils = window.fizzyUIUtils;
  const hero = document.querySelector('.main-carousel');

  if (!hero) {
    return;
  }

  const heroSlider = new Flickity(hero, {
    lazyLoad: true,
    cellAlign: 'center',
    contain: true,
    wrapAround: true,
    prevNextButtons: false,
    pageDots: false
  });
  const cellsButtonGroup = document.querySelector('.hero__dot-group--cells');
  const cellsButtons = utils.makeArray(cellsButtonGroup.children); // update buttons on select

  heroSlider.on('select', function () {
    const previousSelectedButton = cellsButtonGroup.querySelector('.is-selected');
    let selectedButton = cellsButtonGroup.children[heroSlider.selectedIndex];
    previousSelectedButton.classList.remove('is-selected');
    selectedButton.classList.add('is-selected');
  }); // cell select

  cellsButtonGroup.addEventListener('click', function (event) {
    if (!matchesSelector(event.target, '.hero__dot')) {
      return;
    }

    let index = cellsButtons.indexOf(event.target);
    heroSlider.select(index);
  }); // previous

  const previousButton = document.querySelector('.hero__btn--prev');
  previousButton.addEventListener('click', function () {
    heroSlider.previous();
  }); // next

  const nextButton = document.querySelector('.hero__btn--next');
  nextButton.addEventListener('click', function () {
    heroSlider.next();
  });
})();
// document.addEventListener('DOMContentLoaded', function(){});
//(function(){
// const contactWidget = document.getElementById('contact-widget');
// const elemNameArr = ['phone', 'envelope', 'telegram'];
// if (!contactWidget) { return; }
// const svgElem = contactWidget.querySelector('#widget-img');
// let svgElemValue = svgElem.childNodes[0].href.baseVal;
// let svgElemString = svgElemValue.split('#')[0];
// let svgElemVar = svgElemValue.split('#')[1];
//console.info(svgElemString + '#' + svgElemVar);
//svgElemValue = svgElemString + '#envelope';
//console.log(svgElemValue);
// const changeImg = function () {
//let count = 0;
//};
//setInterval(function () {
//alert("Hello");
//}, 3000);
//}());
(function () {
  const miniCartOverlay = document.getElementById('miniCartOverlay');
  const showCartBtn = document.getElementById('showCartBtn');
  const miniCart = document.getElementById('mini-cart');
  const body = document.querySelector('body');

  if (!miniCartOverlay) {
    return;
  }

  const clickOverlayHandler = function (e) {
    miniCart.classList.remove('show');
    showCartBtn.classList.add('collapsed');
    showCartBtn.setAttribute('aria-expanded', false);
  };

  const bodyStyleHandler = function (e) {
    if (!body.hasAttribute('style')) {
      body.style = 'overflow:hidden;'; //console.log(true);
    } else {
      //console.log(false);
      body.removeAttribute('style');
    }
  };

  miniCartOverlay.addEventListener('click', clickOverlayHandler);
  showCartBtn.addEventListener('click', bodyStyleHandler);
  document.addEventListener('keydown', function (e) {
    const key = e.key; // const {key} = event; in ES6+

    if (key === 'Escape' || e.keyCode === 27) {
      clickOverlayHandler();
      bodyStyleHandler();
    }
  });
})();
// document.addEventListener('DOMContentLoaded', function(){});
(function () {
  const clients = document.querySelector('.clients-slider__carousel');

  if (!clients) {
    return;
  }

  const heroSlider = new Flickity(clients, {
    lazyLoad: 3,
    autoPlay: 3500,
    cellAlign: 'center',
    percentPosition: false,
    //freeScroll: true,
    wrapAround: true,
    prevNextButtons: false,
    pageDots: false
  });
})();
// document.addEventListener('DOMContentLoaded', function(){});

/*(function(){
  // init Isotope
  const iso = new Isotope( '.grid', {
    itemSelector: '.grid-item',
    layoutMode: 'fitRows'
  });

  // filter functions
  var filterFns = {
    // show if number is greater than 50
    numberGreaterThan50: function( itemElem ) {
      var number = itemElem.querySelector('.number').textContent;
      return parseInt( number, 10 ) > 50;
    },
    // show if name ends with -ium
    ium: function( itemElem ) {
      var name = itemElem.querySelector('.name').textContent;
      return name.match( /ium$/ );
    }
  };

  // bind filter button click
  var filtersElem = document.querySelector('.btn-filter-group');
  filtersElem.addEventListener( 'click', function( event ) {
    // only work with buttons
    if ( !matchesSelector( event.target, 'button' ) ) {
      return;
    }
    var filterValue = event.target.getAttribute('data-filter');
    // use matching filter function
    filterValue = filterFns[ filterValue ] || filterValue;
    iso.arrange({ filter: filterValue });
  });

  // change is-checked class on buttons
  var buttonGroups = document.querySelectorAll('.btn-filter-group');
  for ( var i=0, len = buttonGroups.length; i < len; i++ ) {
    var buttonGroup = buttonGroups[i];
    radioButtonGroup( buttonGroup );
  }

  function radioButtonGroup( buttonGroup ) {
    buttonGroup.addEventListener( 'click', function( event ) {
      // only work with buttons
      if ( !matchesSelector( event.target, 'button' ) ) {
        return;
      }
      buttonGroup.querySelector('.is-checked').classList.remove('is-checked');
      event.target.classList.add('is-checked');
    });
  }

}());*/
(function () {
  // change is-checked class on buttons
  const buttonGroups = document.querySelectorAll('.btn-filter-group');
  const filteredElems = document.querySelectorAll('.grid-item');

  for (let i = 0; i < buttonGroups.length; i++) {
    var buttonGroup = buttonGroups[i];
    radioButtonGroup(buttonGroup);
  }

  function radioButtonGroup(buttonGroup) {
    buttonGroup.addEventListener('click', function (e) {
      let currentBtn = e.target; // only work with buttons

      if (!matchesSelector(currentBtn, 'button')) {
        return;
      }

      buttonGroup.querySelector('.is-checked').classList.remove('is-checked');
      currentBtn.classList.add('is-checked'); //console.log(`Кнопка: ${currentBtn.dataset.filter}`);

      for (let i = 0; i < filteredElems.length; i++) {
        let currentItem = filteredElems[i];

        if (!currentItem.matches(`.${currentBtn.dataset.filter}`)) {
          //currentItem.style = 'display:none;';
          currentItem.setAttribute('will-change', 'transform');
          currentItem.animate([// keyframes
          {
            transform: 'scale3d(1, 1, 1)'
          }, {
            transform: 'scale3d(0.3, 0.3, 0.3)'
          }], {
            // timing options
            duration: 150,
            iterations: 1
          });
          currentItem.style = 'display:none;';
          currentItem.removeAttribute('will-change');
        }

        if (currentItem.matches(`.${currentBtn.dataset.filter}`) || currentBtn.dataset.filter == 'all') {
          //console.log('Совпало');
          //currentItem.style = 'display:block;';
          currentItem.setAttribute('will-change', 'transform');
          currentItem.animate([// keyframes
          {
            transform: 'scale3d(0.3, 0.3, 0.3)'
          }, {
            transform: 'scale3d(1, 1, 1)'
          }], {
            // timing options
            duration: 150,
            iterations: 1
          });
          currentItem.style = 'display:block;';
          currentItem.removeAttribute('will-change');
        }
      }
    });
  }
})();

(function () {
  const cardsAll = document.querySelectorAll('.equipment-card');

  if (!cardsAll) {
    return;
  }

  for (let i = 0; i < cardsAll.length; i++) {
    const card = cardsAll[i];
    const moreBtn = card.querySelector('.btn--more');
    const returnBtn = card.querySelector('.btn--return');
    const flipElem = card.querySelector('.equipment-card__inner');

    const moreBtnClickHandler = function (e) {
      flipElem.classList.toggle('equipment-card__inner--backface');
    };

    if (moreBtn && returnBtn) {
      moreBtn.addEventListener('click', moreBtnClickHandler);
      returnBtn.addEventListener('click', moreBtnClickHandler);
    }
  }
})();
/*(function(){
  // Балансировка высоты колонок
  const gridElemAll = document.querySelectorAll('.grid-item');

  if (!gridElemAll) { return; }
  let elemMaxHeight = 0;
  let elemMaxWidth = 0;

  const setSize = function () {
    // Находим самый высокий элемент и балансируем высоту
    for (let i = 0; i < gridElemAll.length; i++) {
      let currentElem = gridElemAll[i];
      let currentCard = currentElem.children[0];
      let currentCardHeight = Math.ceil(currentCard.offsetHeight)

      if (elemMaxHeight < currentCardHeight) {
        elemMaxHeight = currentCardHeight;
      }
      // if (elemMaxWidth < currentCard.offsetWidth) {
      //   elemMaxWidth = Math.ceil(currentCard.offsetWidth);
      // }

      if (currentCardHeight < elemMaxHeight) {
         currentCard.style = `height: ${elemMaxHeight}px;`;
      }
      // if (currentCard.offsetWidth < elemMaxWidth) {
      //     currentCard.style = `width: ${elemMaxWidth}px;`;
      // }
    }
  };

  setSize();

  // Ресайз при изменении р-ра экрана
  let resizeTimeout;
  const resizeThrottler = function () {
    // ignore resize events as long as an actualResizeHandler execution is in the queue
    if ( !resizeTimeout ) {
      resizeTimeout = setTimeout(function() {
        resizeTimeout = null;
        setSize();
       // The actualResizeHandler will execute at a rate of 15fps
       }, 100);
    }
  };

  window.addEventListener("resize", resizeThrottler, false);

  //задаем высоту элементам, который ниже самого высокого
  // for (let j = 0; j < gridElemAll.length; j++) {
  //   let currentElem = gridElemAll[j];
  //   let currentCard = currentElem.children[0];

  //   if (currentCard.offsetHeight < elemMaxHeight) {
  //      currentCard.style = `height: ${elemMaxHeight}px;`;
  //   }
  // }

  //console.log(`Макс высота элемента: ${elemMaxHeight}`);
  //console.log(`Макс ширина элемента: ${elemMaxWidth}`);
}());*/
(function () {
  const submitBtn = document.querySelector('.contacts__submit');
  const agreementCheckbox = document.querySelector('input[name=agreement]');

  const agreementHandler = function (e) {
    if (!this.checked) {
      submitBtn.disabled = true;
    } else {
      submitBtn.disabled = false;
    }
  };

  if (agreementCheckbox) {
    agreementCheckbox.addEventListener('change', agreementHandler);
  }
})();
(function () {
  const coverForm = document.getElementById('coverage-form');
  const coverResult = document.getElementById('coverage-result');

  if (!coverForm) {
    return;
  }

  const coverResultCity = coverResult.querySelector('.coverage-result__city');
  const formSubmitBtn = coverForm.querySelector('#coverage-form-submit');
  const loader = coverForm.querySelector('.loader');
  const inputArr = coverForm.querySelectorAll('.field-text__input');
  const citySelect = coverForm.querySelector('.field-select__select');

  const coverResultShow = function () {
    if (!coverResult.classList.contains('show')) {
      coverResult.classList.add('show');
    }

    const coverResultCity = coverResult.querySelector('.coverage-result__city');
    const coverResultStreet = coverResult.querySelector('.coverage-result__street');
    const coverResultHouse = coverResult.querySelector('.coverage-result__house');
    const selectOptions = citySelect.options;

    for (let i = 0; i < selectOptions.length; i++) {
      let currentOption = selectOptions[i];

      if (currentOption.selected) {
        coverResultCity.textContent = currentOption.value;
      }
    }

    for (let j = 0; j < inputArr.length; j++) {
      let currentInput = inputArr[j];

      if (currentInput.name === 'street') {
        coverResultStreet.textContent = currentInput.value;
      }

      if (currentInput.name === 'house') {
        coverResultHouse.textContent = currentInput.value;
      }
    }
  };

  const checkEmptyInput = function () {
    let returnedBulean = true;

    for (let i = 0; i < inputArr.length; i++) {
      let currentInput = inputArr[i];
      let currentInputValue = currentInput.value;
      let voidFlag = !!currentInputValue;

      if (!voidFlag) {
        //currentInput.nextElementSibling.textContent = 'Это поле должно быть заполнено!';
        currentInput.style = 'border-color:#fd0000;';
        returnedBulean = false;
        break;
      }

      currentInput.style = 'border-color:#158e30;';
    }

    return returnedBulean;
  };

  const formSubmitBtnHandler = function (e) {
    e.preventDefault();

    if (checkEmptyInput()) {
      e.target.setAttribute('disabled', true);
      loader.classList.add('show');
      window.setTimeout(function () {
        e.target.removeAttribute('disabled');
        loader.classList.remove('show');
        coverResultShow();
      }, 5000);
    }
  };

  if (formSubmitBtn) {
    formSubmitBtn.addEventListener('click', formSubmitBtnHandler);
  }
})();
(function () {
  const orderModal = document.getElementById('orderModal');

  if (!orderModal) {
    return;
  }

  orderModal.addEventListener('show.bs.modal', function (event) {
    // Button that triggered the modal
    let button = event.relatedTarget; // Extract info from data-bs-* attributes

    let subTitle = button.getAttribute('data-bs-whatever'); // If necessary, you could initiate an AJAX request here
    // and then do the updating in a callback.
    //
    // Update the modal's content.

    let modalAddTitle = orderModal.querySelector('.modal-title__add'); //var modalBodyInput = orderModal.querySelector('.modal-body input')

    modalAddTitle.textContent = '' + subTitle; //modalBodyInput.value = recipient;
  });
})();
document.addEventListener('DOMContentLoaded', function () {
  const countdownArr = document.getElementsByClassName('countdown');

  if (!countdownArr) {
    return;
  }

  function getTimeRemaining(endtime) {
    let t = Date.parse(endtime) - Date.parse(new Date());
    let seconds = Math.floor(t / 1000 % 60);
    let minutes = Math.floor(t / 1000 / 60 % 60);
    let hours = Math.floor(t / (1000 * 60 * 60) % 24);
    let days = Math.floor(t / (1000 * 60 * 60 * 24));
    return {
      'total': t,
      'days': days,
      'hours': hours,
      'minutes': minutes,
      'seconds': seconds
    };
  }

  function initializeClock(id, endtime) {
    const clock = id;
    const daysSpan = clock.querySelector('.days');
    const hoursSpan = clock.querySelector('.hours');
    const minutesSpan = clock.querySelector('.minutes');
    const secondsSpan = clock.querySelector('.seconds');
    const countdownContainer = clock.querySelector('.countdown__inner');
    const deadlineMessage = clock.querySelector('.countdown__deadline-message');

    function updateClock() {
      const timeinterval = setInterval(updateClock, 1000);
      let t = getTimeRemaining(endtime);
      daysSpan.innerHTML = t.days;
      hoursSpan.innerHTML = ('0' + t.hours).slice(-2);
      minutesSpan.innerHTML = ('0' + t.minutes).slice(-2);
      secondsSpan.innerHTML = ('0' + t.seconds).slice(-2);
      /*if (t.total <= 0) {
        clearInterval(timeinterval);
      }*/

      if (t.total <= 0) {
        //document.getElementById("countdown").classList.add('hidden');
        countdownContainer.classList.add('hidden');
        deadlineMessage.classList.add('visible');
        clearInterval(timeinterval);
        return true;
      }
    }

    updateClock();
  } // var deadline = new Date(Date.parse(new Date()) + 15 * 24 * 60 * 60 * 1000); // for endless timer
  //const deadline = 'August 31 2021 18:59:00 GMT+0300'; //GMT+0300 - летнее время


  for (let j = 0; j < countdownArr.length; j++) {
    let currentItem = countdownArr[j];
    let currentItemDeadline = currentItem.dataset.deadline;

    if (currentItemDeadline === '') {
      continue;
    }

    initializeClock(currentItem, currentItemDeadline);
  } //initializeClock('countdown', deadline);

  /**
   * Взято за основу https://denis-creative.com/jstimer/
   * Добавлен функционал инициализации множественных объектов,
   * каждый из которых имеет свой атрибут - deadline
   *
   * Формат вывода даты ISO 8601:
   * var deadline = '2015-12-31';
   *
   * Вывод даты с точным временем и часовым поясом:
   * var deadline="September 01 2021 00:00:00 GMT+0300";
   *
   * Вывод таймера для лендингов – таймер все время будет выводить,
   * что осталось 15 дней (можно указать любое время)
   * var deadline = new Date(Date.parse(new Date()) + 15 * 24 * 60 * 60 * 1000);
   */

});
(function () {
  const utils = window.fizzyUIUtils;
  const rates = document.querySelector('.home-rates-card__slider');

  if (!rates) {
    return;
  }

  const ratesSlider = new Flickity(rates, {
    cellAlign: 'left',
    contain: true,
    dragThreshold: 5,
    //watchCSS: true,
    prevNextButtons: false,
    pageDots: false
  }); //const cellsButtonGroup = document.querySelector('.hero__dot-group--cells');
  //const cellsButtons = utils.makeArray( cellsButtonGroup.children );
  // update buttons on select

  /*heroSlider.on( 'select', function() {
    const previousSelectedButton = cellsButtonGroup.querySelector('.is-selected');
    let selectedButton = cellsButtonGroup.children[ heroSlider.selectedIndex ];
    previousSelectedButton.classList.remove('is-selected');
    selectedButton.classList.add('is-selected');
  });*/
  // cell select

  /*cellsButtonGroup.addEventListener( 'click', function( event ) {
    if ( !matchesSelector( event.target, '.hero__dot' ) ) {
      return;
    }
    let index = cellsButtons.indexOf( event.target );
    heroSlider.select( index );
  });*/
  // previous

  /*const previousButton = document.querySelector('.hero__btn--prev');
  previousButton.addEventListener( 'click', function() {
    heroSlider.previous();
  });*/
  // next

  /*const nextButton = document.querySelector('.hero__btn--next');
  nextButton.addEventListener( 'click', function() {
    heroSlider.next();
  });*/
})();

(function () {
  const cardsAll = document.querySelectorAll('.home-rates-card');

  if (!cardsAll) {
    return;
  }

  for (let i = 0; i < cardsAll.length; i++) {
    const card = cardsAll[i];
    const moreBtn = card.querySelector('.home-rates-card__btn--info');
    const returnBtn = card.querySelector('.btn--return');
    const flipElem = card.querySelector('.home-rates-card__inner'); //console.log(flipElem);

    const moreBtnClickHandler = function (e) {
      flipElem.classList.toggle('home-rates-card__inner--backface');
    };

    if (moreBtn && returnBtn) {
      moreBtn.addEventListener('click', moreBtnClickHandler);
      returnBtn.addEventListener('click', moreBtnClickHandler);
    }
  }
})();
// document.addEventListener('DOMContentLoaded', function(){});
(function () {
  const tooltip = new Drooltip({
    "element": ".tooltip",
    "trigger": "click",
    "background": "#fff",
    "color": "#252525" //"position" : "bottom"

  });
})();
document.documentElement.className = document.documentElement.className.replace('no-js', 'js');

function cth(c) {
  document.documentElement.classList.add(c);
}

'ontouchstart' in window ? cth('touch') : cth('no-touch');
if (typeof InstallTrigger !== 'undefined') cth('firefox');
if (/constructor/i.test(window.HTMLElement) || function (p) {
  return p.toString() === "[object SafariRemoteNotification]";
}(!window['safari'] || typeof safari !== 'undefined' && safari.pushNotification)) cth('safari');
if (
/*@cc_on!@*/
false || !!document.documentMode) cth('ie');
if (!(
/*@cc_on!@*/
false || !!document.documentMode) && !!window.StyleMedia) cth('edge');
if (!!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime)) cth('chrome');
if (~navigator.appVersion.indexOf("Win")) cth('windows');
if (~navigator.appVersion.indexOf("Mac")) cth('osx');
if (~navigator.appVersion.indexOf("Linux")) cth('linux');

(function () {
  // Поддержка формата webp для background-img
  // 1. Проверяем, можно ли использовать Webp формат
  function canUseWebp() {
    // Создаем элемент canvas
    let elem = document.createElement('canvas'); // Приводим элемент к булеву типу

    if (!!(elem.getContext && elem.getContext('2d'))) {
      // Создаем изображение в формате webp, возвращаем индекс искомого элемента и сразу же проверяем его
      return elem.toDataURL('image/webp').indexOf('data:image/webp') == 0;
    } // Иначе Webp не используем


    return false;
  } // 2. Заменв формата изображений


  window.onload = function () {
    // Получаем все элементы с дата-атрибутом data-bg
    let images = document.querySelectorAll('[data-bg]'); // Проходимся по каждому

    for (let i = 0; i < images.length; i++) {
      // Получаем значение каждого дата-атрибута
      let image = images[i].getAttribute('data-bg'); // Каждому найденному элементу задаем свойство background-image с изображение формата jpg

      images[i].style.backgroundImage = 'url(' + image + ')';
    } // Проверяем, является ли браузер посетителя сайта Firefox и получаем его версию


    let isitFirefox = window.navigator.userAgent.match(/Firefox\/([0-9]+)\./);
    let firefoxVer = isitFirefox ? parseInt(isitFirefox[1]) : 0; // Если есть поддержка Webp или браузер Firefox версии больше или равно 65

    if (canUseWebp() || firefoxVer >= 65) {
      // Делаем все то же самое что и для jpg, но уже для изображений формата Webp
      let imagesWebp = document.querySelectorAll('[data-bg-webp]');

      for (let i = 0; i < imagesWebp.length; i++) {
        let imageWebp = imagesWebp[i].getAttribute('data-bg-webp');
        imagesWebp[i].style.backgroundImage = 'url(' + imageWebp + ')';
      }
    }
  }; // Разметка:
  //<div style="background-image: url('/images/image.webp')" data-bg="/images/image.jpg" data-bg-webp="/images/image.webp"></div>

})();

(function () {
  let bLazy = new Blazy({
    selector: '.b-lazy'
  });
})();

(function () {
  var phoneElems = document.getElementsByClassName('phone-mask');
  Array.prototype.forEach.call(phoneElems, function (item) {
    var phoneMask = IMask(item, {
      mask: '+{38} (\\000) 000 00 00',
      lazy: false // make placeholder always visible

    });
  });
})(); // На проекте нет jQuery, но хочется $( document ).ready...
// function ready(fn) {
//   if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading"){
//     fn();
//   } else {
//     document.addEventListener('DOMContentLoaded', fn);
//   }
// }
//
// ready(function(){
//   // code
// });
// $(document).ready(function(){
//   if(window.matchMedia('(min-width: 1366px)').matches){
//   // do functionality on screens bigger than 1366px
//     $("#sticker").sticky({
//       topSpacing: 100
//     });
//   }
//   return false;
// });